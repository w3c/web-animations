<!DOCTYPE html>
<!-- vim: set expandtab ts=2 sw=2 tw=80: -->
<html>
  <head>
    <title>Web Animations 1.0</title>
    <meta charset="utf-8">
    <script src="respec/respec.js" class="remove"></script>
    <script
      src="http://dev.w3.org/2009/dap/ReSpec.js/js/lang/sh_javascript.min.js"
      class="remove"></script>
    <script class="remove">
      var respecConfig = {
        // specification status (e.g. WD, LCWD, NOTE, etc.). If in doubt use
        // ED.
        specStatus: "ED",

        // the specification's short name, as in
        // http://www.w3.org/TR/short-name/
        // shortName:            "web-anim",

        // if your specification has a subtitle that goes below the main
        // formal title, define it here
        // subtitle   :  "an excellent document",

        // if you wish the publication date to be other than today, set this
        // publishDate:  "2009-08-06",

        // if the specification's copyright date is a range of years, specify
        // the start date here:
        // copyrightStart: "2012"

        // if there is a previously published draft, uncomment this and set
        // its YYYY-MM-DD date and its maturity status
        // previousPublishDate: "1977-03-15",
        // previousMaturity: "WD",

        // if there a publicly available Editor's Draft, this is the link
        edDraftURI:
        "https://dvcs.w3.org/hg/FXTF/raw-file/tip/web-anim/index.html",

        // if this is a LCWD, uncomment and set the end of its review period
        // lcEnd: "2009-08-05",

        // if you want to have extra CSS, append them to this list
        // it is recommended that the respec.css stylesheet be kept
        extraCSS: ["respec/respec.css",
                   "web-animations.css"],

        // Turning off inlineCSS for now since if extraCSS points to
        // a relative URL your testing from a file URL the XHR will fail.
        // Probably should turn this back on once this is hosted on a server
        // somewhere.
        inlineCSS: false,

        // editors, add as many as you like
        // only "name" is required
        editors:  [
            { name: "Brian Birtles", mailto: "bbirtles@mozilla.com",
              company: "Mozilla Japan", companyURL: "http://mozilla.jp/" },
            { name: "Shane Stephens", mailto: "shans@google.com",
              company: "Google, Inc", companyURL: "http://www.google.com/" },
            { name: "Rik Cabanier", mailto: "cabanier@adobe.com",
              company: "Adobe Systems", companyURL: "http://www.adobe.com/" },
            { name: "Alex Danilo", mailto: "adanilo@google.com",
              company: "Google, Inc", companyURL: "http://www.google.com/" },
            { name: "Dmitry Baranovskiy", mailto: "baranovs@adobe.com",
              company: "Adobe Systems", companyURL: "http://www.adobe.com/" },
            { name: "Tab Atkins", mailto: "jackalmage@gmail.com",
              company: "Google, Inc", companyURL: "http://www.google.com/" },
        ],

        // authors, add as many as you like.
        // This is optional, uncomment if you have authors as well as editors.
        // only "name" is required. Same format as editors.

        //authors:  [
        //    { name: "Your Name", url: "http://example.org/",
        //      company: "Your Company", companyURL: "http://example.com/" },
        //],

        // XXX If we continue using ReSpec then we need to tweak it to support
        // multiple working groups. It includes updating the patent section
        // prose to say "groups" instead of "group" etc.
        // name of the WG
        wg: "CSS Working Group (part of the Style Activity) and the SVG " +
            "Working Group (part of the Graphics Activity)",

        // URI of the public WG page
        // wgURI: "http://www.w3.org/Graphics/fx/",

        // name (without the @w3c.org) of the public mailing to which comments
        // are due
        wgPublicList: "public-fx",

        // URI of the patent status for this WG, for Rec-track documents
        // !!!! IMPORTANT !!!!
        // This is important for Rec-track documents, do not copy a patent URI
        // from a random document unless you know what you're doing. If in
        // doubt ask your friendly neighbourhood Team Contact.
        wgPatentURI:  "",

        noIDLSorting: true,
        noIDLIn: true
      };
    </script>
    <!--
      ReSpec.js wishlist:

      Add here any issues you find with ReSpec including missing features. It
      will help us decide if we should continue using it and work out what we
      need to fix.

      * Need ability to cross-reference members of interfaces (e.g. constants
        etc.)
      * Get rid of the description section next to parameters? It seems more
        natural to describe the parameters in the description of the method?
      * Allow making cross-references to specific methods and members.
      * Don't make unofficial drafts use the Creative Commons Attribution
        license.
      * Support getter/setter/deleter/creator
    -->
  </head>
  <body>
    <section id='abstract'>
      This is the abstract for your specification.
    </section>

    <section class="informative">
      <h2>Introduction</h2>
      <p>
        Web Animations defines features for supporting animation and
        synchronization on the Web platform by means of a programming interface.
        This interface is intended to be used both directly to easily produce
        animations using script, as well as a foundation for other
        specifications whose behavior can be defined in terms of these features.
      </p>
      <section>
        <h3>Relationship to other specifications</h3>
        <p>
          CSS Transitions [[CSS3-TRANSITIONS]], CSS Animations 
          [[CSS3-ANIMATIONS]], and SVG [[SVG112]] all provide mechanisms that
          generate animated content on a web page.
          Although the three specifications provide similar functionality,
          the syntaxes are incompatible and the animations cannot be
          interchanged.
          Furthermore, the interfaces available for interacting with animations
          from script are largely general-purpose interfaces with few features
          tuned specifically to the creation and manipulation of animations.
        </p>
        <p>
          This specification proposes an abstract animations model that
          encompasses the abilities of both CSS and SVG, and additionally
          provides a programming interface to expose these features to script.
        </p>
        <p>
          This specification is accompanied by a CSS embedding specification,
          which describes how CSS features can be implemented in terms of Web 
          Animations primitives, and an SVG embedding specification, which
          describes how SVG features can be implemented in terms of Web
          Animations primitives.
        </p>
        <p>
          As a result, this specification does not directly alter the behavior
          of CSS Transitions, CSS Animations, or SVG.
          However, Web Animations is intended to replace the SMIL Animation
          [[SMIL-ANIMATION]] specification where it is currently used to define
          the behavior of SVG's animation features.
        </p>
        <p>
          This specification makes some additions to some interfaces defined in
          HTML5 [[HTML5]].
        </p>
      </section>
    </section>

    <section class="informative">
      <h2>Web Animations overview</h2>
      <p>
        At a glance, Web Animations consists of two largely independent
        pieces, a <em>timing model</em> and an <em>animation model</em>.
        The role of these pieces is as follows:
      </p>
      <dl>
        <dt>Timing model</dt>
        <dd>
          Takes a moment in time and converts it to a proportional distance
          within a single iteration of an animation called the <em>time
          fraction</em>.
        </dd>
        <dt>Animation model</dt>
        <dd>
          Takes the <em>time fractions</em> produced by the timing model and
          converts them into a series of values to apply to the target
          properties and attributes.
        </dd>
      </dl>
      <p>
        Graphically, this flow can be represented as follows:
      </p>
      <div class="figure">
        <img src="img/timing-and-animation-models.svg" width="600">
      </div>
      <p class="caption">
        Overview of the operation of Web Animations.<br>
        The current time is input to the timing model which produces a time
        fraction.<br>
        This distance is used as input to the animation model which produces the
        values to apply.
      </p>
      <p>
        For example, consider an animation that:
      </p>
      <ul>
        <li>starts after 3 seconds,</li>
        <li>runs twice,</li>
        <li>takes 2 seconds every time, and</li>
        <li>changes the width of a rectangle from 50 pixels to 100 pixels.</li>
      </ul>
      <p>
        The first three points apply to the timing model.
        At a time of 6 seconds, it will calculate that the animation should be
        half-way through its second iteration and produces the result 0.5.
        The animation model then uses that information to calculate a width for
        the rectangle of 75.
      </p>
      <p>
        This specification begins with the timing model and then proceeds to the
        animation model.
      </p>
    </section>

    <section class="informative">
      <h2>The timing model at a glance</h2>
      <p>
        Two features characterise the Web Animations timing model: it is
        <em>stateless</em> and it is <em>hierarchical</em>.
      </p>
      <section>
        <h3>Stateless</h3>
        <p>
          The Web Animations timing model operates by taking an input time and
          producing an output time fraction.
          Since the output is based solely on the input time and is entirely
          independent of previous inputs, the model may be described as
          stateless.
          This gives the model the following properties:
        </p>
        <dl>
          <dt>Frame-rate independent</dt>
          <dd>
            Since the output is independent of previous inputs, the rate at
            which the model is sampled will not affect its progress.
            Provided the input times are proportional to the progress of
            real-world time, animations will progress at an identical rate
            regardless of the capabilities of the device running them.
          </dd>
          <dt>Direction agnostic</dt>
          <dd>
            Since the sequence of inputs is insignificant, the model is
            directionless.
            This means that the model can be sampled in reverse or even in
            a backwards and forwards pattern without requiring any specialized
            handling.
          </dd>
          <dt>Constant-time seeking</dt>
          <dd>
            Since each input is independent of the previous input, the
            processing required to perform a seek operation, even far into the
            future, is at least potentially constant.
          </dd>
        </dl>
        <p>
          There are two apparent exceptions to the stateless behavior of the
          timing model.
        </p>
        <p>
          Firstly, events are fired when, for example, one sample falls
          on the opposite side of an animation's interval boundary to the
          previous sample.
          This is certainly stative behavior.
          However, events should be considered as a layer added on top of the
          core timing model.
          In the case where no event listeners are registered, the model is
          stateless.
        </p>
        <p>
          The other exception to this stateless behavior is that a number of
          methods such as <code>pause</code> and <code>reverse</code> are
          defined in terms of the time at which they are called and are
          therefore stative.
          These methods are provided primarily for convenience and are not part
          of the core timing model but, like events, are layered on top.
        </p>
        <p>
          Finally, each time the model is sampled, it can be considered to
          establish a temporary state.
          While this temporary state affects the values returned from the API,
          it has no influence on the subsequent samples and hence does not
          conflict with the stateless qualities described above.
        </p>
      </section>
      <section>
        <h3>Hierarchical</h3>
        <p>
          The other characteristic feature of the Web Animations timing model is
          that time is inherited.
          In effect, time begins with real world time (a monotonically
          increasing time source) and cascades down a number of steps to each
          animation.
          At each step, time may be shifted backwards and forwards, scaled,
          reversed, paused, and repeated.
        </p>
        <p class="todo">
          Need diagram here.
        </p>
        <p>
          A consequence of this hierarchical arrangement is that complex
          animation arrangements can be reversed, schedule, accelerated and so
          on, as a whole since the manipulations applied to the parent cascade
          down to its descendants.
          Furthermore, since time has a common source, it is easy to synchronize
          otherwise independent animations.
        </p>
        <p>
          Despite this notion of inherited time, some features are implemented
          outside of the time hierarchy.
          In particular, synchronisation with HTML's media controllers (see <a
          href="#synchronizing-with-media" class="sectionRef"></a>) requires
          mirroring changes to pause state between items in different branches
          of the time hierarchy.
        </p>
        <p>
          The first step in this hierarchy is the animation timeline.
        </p>
      </section>
    </section>

    <section class="informative">
      <h2>The animation timeline</h2>
      <p>
        Each document contains a timeline to which animations may be added.
        These animations have an interval during which they are scheduled to
        animate.
      </p>
      <div class="figure">
        <img src="img/timeline.svg" width="600">
      </div>
      <p class="caption">
        At time <em>t</em> animations A and B are animating.
        Animation C has finished animating.
        Animation D has yet to begin and is not animating.
      </p>
      <p>
        The start time of the timeline is defined in <a
        href="#start-of-the-timeline" class="sectionRef"></a>.
      </p>
      </div>
    </section>

    <section>
      <h2>Animations in the timeline</h2>
      <p>
        Animations in the timeline are represented by <code>Animation</code>
        objects.
      </p>
      <section>
        <h3>The <code>Animation</code> interface</h3>
        <dl title="interface Animation : TimedItem" class="idl">
          <dt>Constructor ()</dt>
          <dd>
            <p>
              Creates a new <a>Animation</a> object.
            </p>
            <p>
              Examples of the usage of this constructor are given in <a
              href="#creating-a-new-animation-object" class="sectionRef"></a>.
            </p>
            <dl class="parameters">
              <dt>Element? elem</dt>
              <dd>
                The target element.
                This may be <code>null</code> for animations that do not target
                a specific element.
              </dd>
              <dt>object animationFunction</dt>
              <dd>
                The animation function used to set the
                <code>animationFunction</code> property of the newly created
                <a>Animation</a> object.
                <p>
                  If this parameter is an <a>AnimationFunction</a> object or
                  <a>CustomAnimationFunction</a> object, it will shared with any
                  other <a>Animation</a> objects referring to the same
                  <a>AnimationFunction</a> or <a>CustomAnimationFunction</a>
                  object.
                  It will <em>not</em> be copied.
                </p>
                <p>
                  Otherwise, if this parameter is any other type of object, it
                  will be passed to <a
                  href="#widl-AnimationFunction-createFromProperties-AnimationFunction-object-properties"
                  class="idlType"><code>AnimationFunction.createFromProperties</code></a>
                  and the resulting <a>AnimationFunction</a> object used as the
                  animation function.
                </p>
              </dd>
              <dt>(double or TimingDictionary or Timing) timing</dt>
              <dd>
                The timing properties of the new animation.
                <p>
                  If this parameter is a <code>double</code>, then it
                  specifies the duration of a single iteration of the animation,
                  that is, the <a>iteration duration</a>, in seconds.
                  In this case, the <code>timing</code> property of the new
                  <a>Animation</a> object is set to a new <a>Timing</a> object
                  with all properties set to their default values as specified
                  on the <a>TimingDictionary</a> dictionary definition except
                  the <code>duration</code> property which is set to the value
                  specified here.
                </p>
                <p>
                  If this parameter is of type <a>TimingDictionary</a>, then the
                  passed-in dictionary is used to construct a new <a>Timing</a>
                  object which is then assigned to the <code>timing</code>
                  property of the new <a>Animation</a> object.
                </p>
                <p>
                  Finally, if this parameter is a <a>Timing</a> object, it is
                  directly assigned to the <code>timing</code> property of the
                  new <a>Animation</a> object.
                  It is <em>not</em> copied.
                  In this way <a>Timing</a> objects can be shared between
                  <a>Animation</a> objects.
                </p>
              </dd>
              <dt>optional AnimationGroup? parentGroup</dt>
              <dd>
                The group to which the newly created animation should be
                appended as a child.
                If not specified, the animation will be appended to the document
                timeline.
                If <code>null</code>, the animation will not be appended to any
                group.
              </dd>
              <dt>optional double startTime</dt>
              <dd>
                The <a>start time</a> of the newly generated animation
                expressed in seconds in the <a>iteration time space</a> of the
                <a>AnimationGroup</a> to which it is (or will be) appended.
                <p>
                  If not specified, the current <a>iteration time</a> of the
                  <a>AnimationGroup</a> to which the animation is appended (as
                  determined by the <code>parentGroup</code> parameter) will be
                  used. If <code>parentGroup</code> is <code>null</code>, and
                  the <code>startTime</code> is not specified, a time of zero
                  will be used.
                </p>
              </dd>
            </dl>
          </dd>
          <dt>NamedConstructor = LinkedAnimation(Element? elem,
                                                 AnimationTemplate template,
                                                 optional double startTime)</dt>
          <dd>
            TBD
          </dd>
          <dt>NamedConstructor = ClonedAnimation(Element? elem,
                                                 Animation cloneSource,
                                                 AnimationGroup? parentGroup,
                                                 optional double startTime)
          <dd>
            TBD
          </dd>
          <dt>attribute (AnimationFunction or CustomAnimationFunction)
              animationFunction</dt>
          <dd>
            <p>
              The animation function to apply (see <a href="#animation-values"
              class="sectionRef"></a>).
            </p>
            <p>
              Exceptions:
            </p>
            <dl class="exceptions">
              <dt>DOMException of type
                  <code>NoModificationAllowedError</code></dt>
              <dd>
                Raised on setting if this object is linked to a template (i.e.
                <code>template</code> is not <code>null</code>).
              </dd>
            </dl>
          </dd>
          <dt>attribute AnimationTemplate? template</dt>
          <dd>
            <p>
              For linked animations (see <a href="#animation-templates"
              class="sectionRef"></a>), the <a>AnimationTemplate</a> object
              from which this object derives its values.
              For animations that are not linked to a template, this property is
              <code>null</code>.
            </p>
            <p>
              Setting this property has the following effect:
            </p>
            <ol>
              <li>Let <var>new template</var> be the value to assign to the
                  <code>template</code> property.</li>
              <li>If <var>new template</var> is <code>null</code>,
                <ol>
                  <li>Call <code>unlink()</code>.</li>
                </ol>
              </li>
              <li>Otherwise,
                <ol>
                  <li>Set <code>timing</code> to <code><var>new
                      template</var>.timing.clone()</code>.</li>
                  <li>Set <code>animationFunction</code> to <code><var>new
                      template</var>.animationFunction.clone()</code>.</li>
                  <li>Set <code>template</code> to <code><var>new
                      template</var></code>.</li>
                </ol>
              </li>
            </ol>
          </dd>
          <dt>readonly attribute Element? targetElement</dt>
          <dd>
            <p>
              The element being animated by this object.
              This may be <code>null</code> for animations that do not target
              a <code>Element</code> such as an animation that produces a sound
              using an audio API.
            </p>
          </dd>
          <dt>AnimationTemplate templatize()</dt>
          <dd>
            <p>
              If this object is not already linked to a template,
              creates a new <a>AnimationTemplate</a> object based on this object
              and links this object to it (see <a href="#animation-templates"
              class="sectionRef"></a>).
            </p>
            <p class="feedbackWanted">
              What is the more useful behavior? To always create a template?
              Or to only create one if it doesn't already have one?
            </p>
            <p>
              The effect is equivalent to the following steps:
            </p>
            <ol>
              <li>Let <var>source</var> be the object on which
                  <code>templatize</code> is called.</li>
              <li>If <code><var>source</var>.template</code> is not
                  <code>null</code>, return.</li>
              <li>Create a new <a>AnimationTemplate</a> object,
                  <var>template</var>.</li>
              <li>Set <code><var>template</var>.timing</code> to
                  <code><var>source</var>.timing.clone()</code>.</li>
              <li>Set <code><var>template</var>.animationFunction</code> to
                  <code><var>source</var>.animationFunction.clone()</code>.</li>
              <li>Set <code><var>source</var>.template</code> to
                  <var>template</var>.</li>
              <li>Return <var>template</var>.</li>
            </ol>
          </dd>
          <dt>AnimationTemplate? unlink()</dt>
          <dd>
            <p>
              Makes this animation independent of the template with which it is
              associated if any
              (see <a href="#animation-templates" class="sectionRef"></a>)
            </p>
            <p>
              After setting <code>template</code> to <code>null</code> the
              previous value of <code>template</code> is returned.
            </p>
            <p>
              The effect is equivalent to the following steps:
            </p>
            <ol>
              <li>If <code>template</code> is <code>null</code>, return
                  <code>null</code>.</li>
              <li>Let <var>old template</var> be <code>template</code>.</li>
              <li>Set <code>timing</code> to
                  <code>template.timing.clone()</code>.</li>
              <li>Set <code>animationFunction</code> to
                  <code>template.animationFunction.clone()</code>.</li>
              <li>Set <code>template</code> to <code>null</code> (but do not
                  recursively call this function).</li>
              <li>Return <var>old template</var>.</li>
            </ol>
          </dd>
        </dl>
        <section class="informative">
          <h4>Creating a new <code>Animation</code> object</h4>
          <p>
            The <a>Animation</a> constructor offers a number of approaches to
            creating a new <a>Animation</a> object.
            At its simplest, an <a>Animation</a> object that changes the
            &lsquo;left&rsquo; property of <var>elem</var> to 100 over three
            seconds can be achieved as follows:
          </p>
          <pre class='example sh_javascript'>
var anim = new Animation(elem, { left: '100px' }, 3);
          </pre>
          <p>
            To specify further timing properties such as the playback rate,
            a <a>TimingDictionary</a> can be used as follows:
          </p>
          <pre class='example sh_javascript'>
var anim = new Animation(elem, { left: '100px' }, { duration: 3, playbackRate: 2 });
          </pre>
          <p>
            To share or re-used timing properties with another animation,
            a <a>Timing</a> object can be directly passed in as follows:
          </p>
          <pre class='example sh_javascript'>
// Share the timing properties of animB with animA
var animA = new Animation(elem, { left: '100px' }, animB.timing);

// Re-use the timing properties of animB in animC without sharing
var animC = new Animation(elem, { left: '100px' }, animB.timing.clone());
          </pre>
          <p>
            The animation function parameter may specify multiple properties,
            an <a>AnimationFunction</a> object, or even a callback object.
          </p>
          <pre class='example sh_javascript'>
// Specify multiple properties at once
var animA = new Animation(elem, { left: '100px', top: '300px' }, 5);

// Share the animation function of another animation
var animB = new Animation(elem, animA.animationFunction, 3);

// Supply a specialized animation function
var animC = new Animation(elem, new PathAnimationFunction( ... ), 3);

// Supply a custom script-based animation function
var animC = new Animation(elem,
  { 
    sample: function(time) { 
      if (time !== null) {
        document.documentElement.currentScale = 1.0 + time * 2.0;
      } else {
        document.documentElement.currentScale = 1.0;
      }
    },
    clone: function { return this; }
  }, 3);
          </pre>
          <p class="todo">
            Fill in the parameters for <a>PathAnimationFunction</a> above once
            we have decided on them.
          </p>
          <p class="todo">
            Add examples of specifying the parent group and start time once we
            resolve the behavior of those.
          </p>
        </section>
      </section>
    </section>

    <section>
      <h2>Timing animations</h2>
      <section class="informative">
        <h3>The animation interval</h3>
        <p>
          The period that an animation is animating is called the
          <dfn>animation interval</dfn>.
          Each animation has only one such interval.
        </p>
        <p>
          The lower bound of the animation interval is determined by the
          <dfn>start time</dfn> of the animation but may be shifted by
          a <dfn>start delay</dfn> on the animation.
        </p>
        <p>
          The upper bound of the interval is determined by the <a>animation
          duration</a>.
        </p>
        <p>
          The relationship between the <a>start time</a>, <a>start delay</a>,
          and <a>animation duration</a> is illustrated below.
        </p>
        <div class="figure">
          <img src="img/animation-interval-examples.svg" width="600">
        </div>
        <p class="caption">
          Examples of the effect of the <a>start delay</a> on the endpoints of
          the <a>animation interval</a>.<br>
          (a) An animation with no delay; the start time and start of
          animation are coincident.<br>
          (b) An animation with a positive delay; the start of
          animation is deferred by the delay.<br>
          (c) An animation with a negative delay; the start of
          animation is brought forward by the delay.
        </p>
      </section>
      <section class="informative">
        <h3>Animation fill behavior</h3>
        <p>
          Outside of the <a>animation interval</a>, an animation may still
          affect its target depending on its <dfn>fill mode</dfn>.
          The different modes are as follows:
        </p>
        <dl>
          <dt>none</dt>
          <dd>
            The animation does not affect its target outside of the
            <a>animation interval</a>.
          </dd>
          <dt>forwards</dt>
          <dd>
            For times that occur later than the <a>animation interval</a>, the
            animation will continue to apply to its target the
            animation value that was used at the end of the <a>animation
            interval</a>.

            For times that occur before the <a>animation interval</a>, the
            animation will not affect its target.
          </dd>
          <dt>backwards</dt>
          <dd>
            For times that occur before the <a>animation interval</a>, the
            animation will apply the same animation value that will be used at
            the start of the <a>animation interval</a>.

            For times that occur later than the <a>animation interval</a>, the
            animation will not affect its target.
          </dd>
          <dt>both</dt>
          <dd>
            For times that occur before the <a>animation interval</a>, the
            backwards fill behavior is used.

            For times that occur after the <a>animation interval</a>, the
            forwards fill behavior is used.
          </dd>
        </dl>
        <p>
          Some examples of the these fill modes are illustrated below.
        </p>
        <div class="figure">
          <img src="img/animation-state-and-fill-behavior.svg" width="600">
        </div>
        <p class="caption">
          Examples of various fill modes and the animation states produced.<br>
          (a) fill mode &lsquo;none&rsquo;. The animation has no effect outside
              its animation interval.<br>
          (b) fill mode &lsquo;forwards&rsquo;. After the animation interval has
              finished, the animation continues to apply a fill value to the
              target.<br>
          (c) fill mode &lsquo;backwards&rsquo;. The animation applies a fill
              value to its target until the start of the animation
              interval.<br>
          (d) fill mode &lsquo;both&rsquo;. Both before and after the animation
              interval the animation applies a fill value to its target.
        </p> 
        <p>
          At a given time, it is possible to describe an animation as <dfn>in
          effect</dfn> if either (a) the time falls within the animation's
          <a>animation interval</a>, or (b) the fill mode of the animation
          causes it to apply a fill mode to its target at the given time.
        </p>
        <p>
          The normative definition of fill behavior is incorporated in the
          calculation of the <a>animation time</a> in <a
          href="#calculating-the-animation-time" class="sectionRef"></a>.
        </p>
        <p class="note">
          Note that setting a fill mode has no bearing on the endpoints of the
          <a>animation interval</a>.
          However, the fill mode <em>does</em> have an effect on the
          calculation of the <a>animation time</a> and consequently the
          <a>iteration time</a> since these are defined only when the animation
          is <a>in effect</a>.
        </p>
      </section>
      <section class="informative">
        <h3>Animation repeat behavior</h3>
        <p>
          It is possible to specify that an animation's effect should repeat
          a fixed number of times or even indefinitely.
          This repetition occurs <em>within</em> the <a>animation
          interval</a>.
          The span of time during which a single repetition takes place is
          called an <dfn>iteration interval</dfn>.
        </p>
        <p>
          Unlike the <a>animation interval</a>, an animation can have multiple
          <a>iteration interval</a>s although typically only the interval
          corresponding to the <a>current iteration</a> is of interest.
        </p>
        <p>
          The length of a single iteration is called the <a>iteration
          duration</a>. Comparing the <a>iteration duration</a> and the
          <a>animation duration</a> we have:
        </p>
        <dl>
          <dt>Iteration duration</dt>
          <dd>
            The time taken for a single iteration of the animation to complete.
          </dd>
          <dt>Animation duration</dt>
          <dd>
            The time taken for the entire animation effect to complete,
            including repetitions.
            This may be longer or shorter than the iteration duration.
          </dd>
        </dl>
        <p>
          The relationship between the <a>iteration duration</a> and
          <a>animation duration</a> is illustrated below.
        </p>
        <div class="figure">
          <img src="img/iteration-intervals.svg" width="600">
        </div>
        <p class="caption">
          A comparison of the iteration and animation durations for an animation
          with an iteration count of 2.5.
          Note that the iteration duration for the final iteration does not
          change, it is simply cut-off by the animation duration.
        </p>
      </section>
      <section class="informative">
        <h3>Time spaces</h3>
        <p>
          Times in Web Animations are relative to some point of reference. These
          different points of reference produce different time spaces.
        </p>
        <p>
          This can be compared to coordinate spaces as used in computer
          graphics.
          The zero time of a time space is analogous to the origin of
          a coordinate space.
        </p>
        <p>
          Within Web Animations, some of the common time spaces are:
        </p>
        <dl>
          <dt><dfn>Document time space</dfn></dt>
          <dd>
            A time space whose zero time is the start time of the document
            timeline as defined in <a href="#start-of-the-timeline"
            class="sectionRef"></a>.
          </dd>
          <dt><dfn>Item time space</dfn></dt>
          <dd>
            A time space whose zero time is the start of the animation's
            <a>start time</a>.<br>
          </dd>
          <dt><dfn>Animation time space</dfn></dt>
          <dd>
            A time space whose zero time is the beginning of the animation's
            <a>animation interval</a>.<br>
          </dd>
          <dt><dfn>Iteration time space</dfn></dt>
          <dd>
            A time space whose zero time is the beginning of the <a>current
            iteration</a>.
          </dd>
        </dl>
        <p>
          In addition to these time spaces, when animation groups are used (see
          <a href="#grouping-and-synchronization" class="sectionRef"></a>) we
          can talk about the <dfn>parent iteration time space</dfn>.
          The zero time of <a>parent iteration time space</a> is the beginning
          of the parent animation group's <a>current iteration</a>.
          When animation groups are not used, this is equivalent to <a>document
          time space</a>.
        </p>
        <p>
          Typically, <a>item time space</a> is used for operations confined to
          a single animation such as <a href="#seeking-a-timed-item">seeking</a>
          and <a href="pausing-a-timed-item">pausing</a> whilst <a>parent
          iteration time space</a> is used to synchronize animations in a group
          and hence is the time space used to represent an animation's start and
          end time.
          <a>Animation time space</a> is not used directly in the Web Animations
          interfaces.
        </p>
        <p>
          Some of these time spaces are illustrated below.
        </p>
        <div class="figure">
          <img src="img/time-spaces.svg" width="600">
        </div>
        <p class="caption">
          A comparison of item time, animation time, and iteration time for an
          animation with a iteration duration of 1s and an iteration count of
          2.5.
        </p>
        <p class="note">
          Note that while the time spaces themselves are not bounded, Web
          Animations defines <a>animation time</a> and <a>iteration
          time</a> such that they are clamped to a set range as shown in the
          diagram.
          For example, whilst a time of -1 second is a valid time in
          <a>animation time space</a>, the procedure for calculating the
          <a>animation time</a> defined in <a
          href="#calculating-the-animation-time" class="sectionRef"></a> will
          never return a negative value.
        </p>
      </section>
      <section class="informative">
        <h3>Interval timing</h3>
        <p>
          For intervals of time, Web Animations uses an endpoint-exclusive
          timing model. This means that whilst the begin time of an interval
          is included in the interval, the end time time is not. In interval
          notation this can written <code>[begin,end)</code>. This model
          provides sensible behavior when intervals are repeated and sequenced
          since there is no overlap between the intervals.
        </p>
        <p>
          In the examples below, for the repeated animation, at animation time
          1s, the iteration time is 0.
          For the sequenced animation, in the absence of any fill mode,
          at parent iteration time 1s, only animation B can affect its target;
          there is no overlap.
        </p>
        <div class="figure">
          <img src="img/endpoint-exclusive-timing.svg" width="600">
        </div>
        <p class="caption">
          Illustration of end-point exclusive timing. For both repeated and
          sequenced animations there is no overlap at the boundaries between
          intervals.
        </p>
        <p>
          An exception to this behavior is that when performing a <a
          href="#animation-fill-behavior">fill</a>, if the fill begins at an
          interval endpoint, the endpoint is used.
          This behavior falls out of the algorithm given in <a
          href="#calculating-the-unscaled-iteration-time"
          class="sectionRef"></a> and is illustrated below.
        </p>
        <div class="figure">
          <img src="img/endpoint-exclusive-timing-and-fill.svg" width="600">
        </div>
        <p class="caption">
          After one iteration, the first frame of the animation is shown, but
          after two iterations (and thereonwards), the last frame is shown due
          to the special behavior defined when an animation fills.
        </p>
      </section>
      <section>
        <h3>Specifying timing properties</h3>
        <p>
          Timing properties are collected under the <code>Timing</code>
          interface.
        </p>
        <p>
          If this object is attached to a linked <a>Animation</a> or
          <a>AnimationGroup</a> (see <a href="#animation-templates"
          class="sectionRef"></a>) then it is readonly and attempting to set any
          of its properties will result in a DOMException of type
          <code>NoModificationAllowedError</code> being thrown.
          In order to modify the properties of a readonly object, it is
          necessary to first call the <code>unlink</code> method on the
          corresponding <a>Animation</a> or <a>AnimationGroup</a> object.
        </p>
        <p>
          When throwing a DOMException as a result of attempting to set
          a readonly property, <a>user agent</a>s that provide debugging
          feedback SHOULD also provide feedback indicating the reason that this
          object is readonly and the remedy described above.
        </p>
        <section>
          <h4>The <code>Timing</code> interface</h4>
          <dl title="interface Timing" class="idl">
            <dt>Constructor ()</dt>
            <dd>
              <p>
                Creates a new <a>Timing</a> object using the supplied
                parameters.
              </p>
              <p>
                In most cases the members of the <code>params</code>
                <a>TimingDictionary</a> can be assigned directly to the property
                in the <a>Timing</a> interface of the same name.
              </p>
              <p>
                The one exception is the <code>timingFunction</code> member
                which in a <a>TimingDictionary</a> value can also be set to
                a <code>DOMString</code>.
                In this case, the <code>DOMString</code> is first passed to
                <a
                href="#widl-TimingFunction-createFromString-TimingFunction-DOMString-spec"
                class="idlType"><code>TimingFunction.createFromString</code></a> and
                the returned <a>TimingFunction</a> is assigned to the
                <code>timingFunction</code> property of the new <a>Timing</a>
                object.
              </p>
              <p>
              </p>
              <div class="issue">
                <p>
                  Should we make this fail silently here?
                  Which is better from a forwards compatibility standpoint?
                </p>
                <p>
                  For example:
                </p>
                <blockquote>
                  If any of the values specified on <code>params</code> is
                  invalid such that setting the corresponding <a>Timing</a>
                  property would trigger an exception, the property is set to
                  the default value as specified on the
                  <code>TimingDictionary</code> definition.
                  User agents that provide a debugging feedback SHOULD indicate
                  that an unrecognized or invalid value was encountered.
                </blockquote>
              </div>
              <p>
                Exceptions:
              </p>
              <dl class="exceptions">
                <dt>DOMException of type <code>IndexSizeError</code></dt>
                <dd>
                  Raised if any of the values specified on <code>params</code>
                  is out of range.
                </dd>
                <dt>DOMException of type <code>SyntaxError</code></dt>
                <dd>
                  Raised if <code>params.timingFunction</code> is set to
                  a string that it not recognized by
                  <a
                  href="#widl-TimingFunction-createFromString-TimingFunction-DOMString-spec"
                  class="idlType"><code>Timing.createFromString</code></a> as
                  indicated by a <code>null</code> return value.
                </dd>
              </dl>
              <dl class="parameters">
                <dt>TimingDictionary params</dt>
                <dd>
                  The properties to set on the new <a>Timing</a> object.
                  Unspecified members take on the default values specified in
                  the <a>TimingDictionary</a> dictionary definition.
                </dd>
              </dl>
            <dd>
            <dt>attribute double startDelay</dt>
            <dd>
              <p>
                The number of seconds which, when added to the timed item's
                <code>startTime</code>, defines the lower bound of the timed
                item's <a>animation interval</a>.
              </p>
              <p>
                A non-normative description of the effect of this property on
                timing is given in <a href="#the-animation-interval"
                class="sectionRef"></a>.
              </p>
              <p>
                Exceptions:
              </p>
              <dl class="exceptions">
                <dt>DOMException of type
                    <code>NoModificationAllowedError</code></dt>
                <dd>
                  Raised on setting if this object is readonly.
                </dd>
              </dl>
            </dd>
            <dt>attribute unrestricted double? duration</dt>
            <dd>
              <p>
                The duration in seconds of a single iteration.
                This may be <code>null</code> in which case the <a>intrinsic
                duration</a> will be used.
                If set, it must be greater than or equal to zero (including
                positive infinity).
              </p>
              <p>
                This property corresponds to the <a>iteration duration</a>
                defined in <a href="#calculating-the-iteration-duration"
                class="sectionRef"></a> and described non-normatively in <a
                href="#animation-repeat-behavior" class="sectionRef"></a>.
              </p>
              <p>
                Exceptions:
              </p>
              <dl class="exceptions">
                <dt>DOMException of type
                    <code>NoModificationAllowedError</code></dt>
                <dd>
                  Raised on setting if this object is readonly.
                </dd>
                <dt>DOMException of type <code>IndexSizeError</code></dt>
                <dd>
                  Raised on setting if the value to set is a real number less
                  than zero.
                </dd>
              </dl>
            </dd>
            <dt>attribute unrestricted double iterationCount</dt>
            <dd>
              <p>
                A real number greater than or equal to zero (including positive
                infinity) representing the number of times to repeat the
                animation.
              </p>
              <p>
                Exceptions:
              </p>
              <dl class="exceptions">
                <dt>DOMException of type
                    <code>NoModificationAllowedError</code></dt>
                <dd>
                  Raised on setting if this object is readonly.
                </dd>
                <dt>DOMException of type <code>IndexSizeError</code></dt>
                <dd>
                  Raised on setting if the value to set is a real number less
                  than zero.
                </dd>
              </dl>
            </dd>
            <dt>attribute double iterationStart</dt>
            <dd>
              <p>
                A finite real number greater than or equal to zero representing
                the number of iterations into the animation at which to begin.
                For example, a value of 0.5 would cause the animation to begin
                half-way through the first iteration.
                If this value is greater than <code>iterationCount</code> then
                it is effectively clamped as defined in the definition of
                <a>effective iteration start</a>.
              </p>
              <p>
                Exceptions:
              </p>
              <dl class="exceptions">
                <dt>DOMException of type
                    <code>NoModificationAllowedError</code></dt>
                <dd>
                  Raised on setting if this object is readonly.
                </dd>
                <dt>DOMException of type <code>IndexSizeError</code></dt>
                <dd>
                  Raised on setting if the value to set is a real number less
                  than zero.
                </dd>
              </dl>
            </dd>
            <dt>attribute double playbackRate</dt>
            <dd>
              <p>
                A real number that acts as a multiplier on the item's rate of
                play.
                For example, a value of 2.0 will cause the item to run at twice
                its usual speed.
                A value of -1.0 will cause the item to play backwards.
                The <code>playbackRate</code> is applied to the item's
                <a>animation time</a> and hence has no effect on the <a>start
                time</a> (see <a href="#time-spaces" class="sectionRef"></a>).
              </p>
              <p>
                Setting this attribute will affect the item's <a>intrinsic
                animation duration</a>.
              </p>
              <p>
                Exceptions:
              </p>
              <dl class="exceptions">
                <dt>DOMException of type
                    <code>NoModificationAllowedError</code></dt>
                <dd>
                  Raised on setting if this object is readonly.
                </dd>
              </dl>
            </dd>
            <dt>attribute PlaybackDirection direction</dt>
            <dd>
              <p>
                Direction behavior as specified by one of the
                <a>PlaybackDirection</a> enumeration values.
              </p>
              <p>
                Exceptions:
              </p>
              <dl class="exceptions">
                <dt>DOMException of type
                    <code>NoModificationAllowedError</code></dt>
                <dd>
                  Raised on setting if this object is readonly.
                </dd>
              </dl>
            </dd>
            <dt>attribute TimingFunction?  timingFunction</dt>
            <dd>
              An optional timing function used to scale input time to produce
              timing effects such as easing behavior.
              See <a href="#scaling-the-time" class="sectionRef"></a>.
            </dd>
            <dt>attribute FillMode fillMode</dt>
            <dd>
              <p>
                The <a>fill mode</a> as specified by one of the <a>FillMode</a>
                enumeration values.
              </p>
              <p>
                Exceptions:
              </p>
              <dl class="exceptions">
                <dt>DOMException of type
                    <code>NoModificationAllowedError</code></dt>
                <dd>
                  Raised on setting if this object is readonly.
                </dd>
              </dl>
            </dd>
            <dt>Timing clone ()</dt>
            <dd>
              <p>
                Creates a new <a>Timing</a> object with each of its properties
                set to the same value as this object with the exception of the
                <code>timingFunction</code> property which is set to
                <code>timingFunction.clone()</code>.
              </p>
            </dd>
          </dl>
        </section>
        <section>
          <h4>The <code>FillMode</code> enumeration</h4>
          <p>A non-normative description of these modes is given in
             <a href="#animation-fill-behavior" class="sectionRef"></a>.</p>
          <dl title="enum FillMode" class="idl">
            <dt>none</dt>
            <dd>
              No fill.
            </dd>
            <dt>forwards</dt>
            <dd>
              Fill forwards.
            </dd>
            <dt>backwards</dt>
            <dd>
              Fill backwards.
            </dd>
            <dt>both</dt>
            <dd>
              Fill backwards and forwards.
            </dd>
          </dl>
        </section>
        <section>
          <h4>The <code>PlaybackDirection</code> enumeration</h4>
          <dl title="enum PlaybackDirection" class="idl">
            <dt>normal</dt>
            <dd>
              All iterations are played as specified.
            </dd>
            <dt>reverse</dt>
            <dd>
              All iterations are played in the reverse direction from the way
              they are specified.
            </dd>
            <dt>alternate</dt>
            <dd>
              Even iterations are played as specified, odd iterations are played
              in the reverse direction from the way they are specified.
            </dd>
            <dt>alternate-reverse</dt>
            <dd>
              Even iterations are played in the reverse direction from the way
              they are specified, odd iterations are played as specified.
            </dd>
          </dl>
        </section>
        <section>
          <h4>The <code>TimingDictionary</code> dictionary</h4>
          <p>
            To simplify creation of <a>Timing</a> objects
            a <code>TimingDictionary</code> can be used.
          </p>
          <p>
            Except where otherwise noted, the acceptable values for each
            property and their meanings are defined in the <a>Timing</a>
            interface.
          </p>
          <dl title="dictionary TimingDictionary" class="idl">
            <dt>double startDelay = 0</dt>
            <dd>
              <p>
                The number of seconds from a timed item's <code>startTime</code>
                to the start of the <a>animation interval</a>.
                See <a href="#widl-Timing-startDelay"
                class="idlType"><code>startDelay</code></a> on the <a>Timing</a>
                interface.
              </p>
            </dd>
            <dt>unrestricted double? duration = null</dt>
            <dd>
              <p>
                The duration in seconds of a single iteration, that is, the
                <a>iteration duration</a>.
                See <a href="#widl-Timing-duration"
                class="idlType"><code>duration</code></a> on the <a>Timing</a>
                interface.
              </p>
            </dd>
            <dt>unrestricted double iterationCount = 1.0</dt>
            <dd>
              <p>
                The number of times to repeat the item.
                See <a href="#widl-Timing-iterationCount"
                class="idlType"><code>iterationCount</code></a> on the
                <a>Timing</a> interface.
              </p>
            </dd>
            <dt>double iterationStart = 0.0</dt>
            <dd>
              <p>
                The number of iterations into the item at which to begin.
                See <a href="#widl-Timing-iterationStart"
                class="idlType"><code>iterationStart</code></a> on the
                <a>Timing</a> interface.
              </p>
            </dd>
            <dt>double playbackRate = 1.0</dt>
            <dd>
              <p>
                A multiplier applied to the inherited time potentially causing
                the item to run at a different rate to its natural speed.
                See <a href="#widl-Timing-playbackRate"
                class="idlType"><code>playbackRate</code></a> on the
                <a>Timing</a> interface.
              </p>
            </dd>
            <dt>PlaybackDirection direction = "normal"</dt>
            <dd>
              <p>
                The direction in which animation proceeds, e.g. "reverse".
                See <a href="#widl-Timing-direction"
                class="idlType"><code>direction</code></a> on the <a>Timing</a>
                interface.
              </p>
            </dd>
            <dt>(DOMString or TimingFunction)? timingFunction = null</dt>
            <dd>
              <p>
                An optional timing function used to scale the time to produce
                easing effects and the like.
              </p>
              <p>
                Unlike the <a>Timing</a> interface, the member here may be set
                to either a <a>TimingFunction</a> object or
                a <code>DOMString</code> corresponding to one of the values
                recognized by <a
                href="#widl-TimingFunction-createFromString-TimingFunction-DOMString-spec"
                class="idlType"><code>Timing.createFromString</code></a>.
              </p>
            </dd>
            <dt>FillMode fillMode = "forwards"</dt>
            <dd>
              <p>
                The <a>fill mode</a> of the animation.
                See <a href="#widl-Timing-fillMode"
                class="idlType"><code>fillMode</code></a> on the <a>Timing</a>
                interface.
              </p>
              <p class="note">
                Note that in both CSS Animations [[CSS3-ANIMATIONS]] and SVG
                [[SVG112]] the default fill mode is "none".
                Web Animations differs in this regard since it was determined
                that when generating animations from script forwards filling is
                the more commonly-desired behavior.
              </p>
            </dd>
          </dl>
        </section>
      </section>
      <section>
        <h3>The <code>TimedItem</code> interface</h3>
        <p>
          The application of the timing properties specified in
          a <code>Timing</code> object to an actor in the animation timeline
          is represented by the <code>TimedItem</code> interface.
        </p>
        <dl title="interface TimedItem" class="idl">
          <dt>attribute Timing timing</dt>
          <dd>
            <p>
              The timing parameters for this item.
            </p>
            <p>
              Exceptions:
            </p>
            <dl class="exceptions">
              <dt>DOMException of type
                  <code>NoModificationAllowedError</code></dt>
              <dd>
                Raised on setting if this object is linked to a template (see <a
                href="#animation-templates" class="sectionRef"></a>).
              </dd>
            </dl>
          </dd>
          <dt>attribute double? currentTime</dt>
          <dd>
            <p>
              Returns the effective item time of the timed item.
            </p>
            <p>
              This differs from the definition of <a>item time</a> used
              elsewhere in the model in that when the parent iteration time is
              <code>null</code> (e.g. because <code>parentGroup</code> is
              <code>null</code>, or because the parent is not <a>in effect</a>)
              a parent time of zero is used.
              This allows the item to be seeked prior to being attached to
              a group.
            </p>
            <p>
              The value returned is calculated as follows:
            </p>
            <blockquote>
              <code>currentTime =
                    <a>effective parent time</a> - startTime - timeDrift</code>
            </blockquote>
            <p>
              Setting this value performs a seek operation according to the
              steps described in described in <a href="#seeking-a-timed-item"
              class="sectionRef"></a>.
            </p>
          </dd>
          <dt>attribute unrestricted double animationDuration</dt>
          <dd>
            <p>
              The length in seconds of the <a>animation interval</a>.
            </p>
            <p>
              Initially, this attribute will reflect the <a>intrinsic animation
              duration</a>.
              Changes to the model that cause the <a>intrinsic animation
              duration</a> to change are reflected in the value returned here.
            </p>
            <p>
              The <a>instrinsic animation duration</a> may be overridden by
              setting this attribute to any real number.
              Setting this attribute to <code>undefined</code> has the effect of
              clearing the override value so that the attribute returns to
              reflecting the <a>intrinsic animation duration</a>. 
            </p>
            <p>
              Exceptions:
            </p>
            <dl class="exceptions">
              <dt>DOMException of type <code>IndexSizeError</code></dt>
              <dd>
                Raised on setting if the value to set is a real number that is
                less than zero.
              </dd>
            </dl>
          </dd>
          <dt>readonly attribute double? iterationTime</dt>
          <dd>
            <p>
              The time in seconds representing the offset into the iteration
              duration using the steps described in <a
              href="#calculating-the-iteration-time" class="sectionRef"></a>.
              As a result of that definition, this property will be
              non-<code>null</code> if and only if the animation is in
              <a>in effect</a>.
            </p>
            <p>
              This property corresponds to the <a>iteration time</a> described
              in <a href="#time-spaces" class="sectionRef"></a>.
            </p>
            <p class="annotation">
              This is not writeable since doing so would basically require doing
              a reverse conversion from the value to set into to item time space
              and then updating the <code>currentTime</code> accordingly.
              However, that's not possible since timing functions may be applied
              and some of them are not invertible.
            </p>
          </dd>
          <dt>readonly attribute unsigned long? currentIteration</dt>
          <dd>
            The number of iterations that have completed as described in <a
              href="#calculating-the-current-iteration" class="sectionRef"></a>.
          </dd>
          <dt>readonly attribute unrestricted double duration</dt>
          <dd>
            <p>
              The <a>iteration duration</a> calculated for this item.
              If <code>timing.duration</code> is set and greater than or
              equal to zero, this will match <code>timing.duration</code>.
              Otherwise, this will reflect the calculated <a>intrinsic
              duration</a>.
            </p>
            <p>
              This property corresponds to the <a>iteration duration</a>
              defined in <a href="#calculating-the-iteration-duration"
              class="sectionRef"></a> and described non-normatively in <a
              href="#animation-repeat-behavior" class="sectionRef"></a>.
            </p>
          </dd>
          <dt>attribute double startTime</dt>
          <dd>
            <p>
              The time which, when combined with the
              <code>timing.startDelay</code>, defines the lower bound of the
              <a>animation interval</a>.
              It is expressed in seconds in the <a>iteration time space</a> of
              <code>parentGroup</code>.
            </p>
            <p>
              When the parent animation group is a sequence group, any
              previously set value set for <code>startTime</code> is ignored and
              instead the value of this property is determined by the procedure
              defined in <a
              href="#the-start-time-of-children-of-a-sequence-animation-group"
              class="sectionRef"></a>.
              Furthermore, attempts to set this property will raise an
              DOMException of type <code>InvalidStateError</code>.
              If this item is later made the child of a parallel animation
              group, any previously set value will be restored.
            </p>
            <p>
              This property corresponds to the <a>start time</a> described in <a
              href="#the-animation-interval" class="sectionRef"></a>.
            </p>
            <p>
              Exceptions:
            </p>
            <dl class="exceptions">
              <dt>DOMException of type <code>InvalidStateError</code></dt>
              <dd>
                Raised on setting if <code>parentGroup</code> is a sequence
                animation group (see <a
                href="#the-start-time-of-children-of-a-sequence-animation-group"
                class="sectionRef"></a>).
              </dd>
            </dl>
          </dd>
          <dt>readonly attribute unrestricted double endTime</dt>
          <dd>
            <p>
              The upper bound of the <a>animation interval</a> expressed in
              seconds relative to the <a>iteration time space</a> of
              <code>parentGroup</code>.
            </p>
            <p>
              The <code>endTime</code> is calculated as follows:
            </p>
            <dl class="switch">
              <dt>If <code>locallyPaused</code> is <code>true</code>,</dt>
              <dd>
                The <code>endTime</code> is positive infinity.
              </dd>
              <dt>Otherwise,</dt>
              <dd>
                The <code>endTime</code> is the result of evaluating
                <code>startTime + timing.startDelay +
                      animationDuration + timeDrift</code>.
              </dd>
            </dl>
            <p class="note">
              Note that while the <code>endTime</code> is read-only, it can be
              set indirectly by overriding the <code>animationDuration</code>
              property.
              For example, to set <code>endTime</code> to time <var>t</var> in
              <a>item time space</a>, set <code>animationDuration</code> to
              <code><var>t</var> - startTime - timing.startDelay</code>.
            </p>
          </dd>
          <dt>readonly attribute AnimationGroup parentGroup</dt>
          <dd>
            The parent animation group.
          </dd>
          <dt>readonly attribute double timeDrift</dt>
          <dd>
            <p>
              The number of seconds that the actual <a>item time</a> of this
              item lags behind its scheduled time as a result of pausing and
              seeking this item.
            </p>
            <p>
              The <code>timeDrift</code> property is both a stored and a
              calculated value.
              When this timed item is paused, the value is calculated from the
              <a>pause start time</a>.
              When the timed item is not paused, the value stored for the
              property is used.
              The stored value is initially zero, and is updated when the item
              is unpaused or seeked.
            </p>
            <p>
              The value returned is as follows:
            </p>
            <dl class="switch">
              <dt>If <code>locallyPaused</code> is <code>false</code>,</dt>
              <dd>
                Return the stored value for this property.
              </dd>
              <dt>If <code>locallyPaused</code> is <code>true</code>,</dt>
              <dd>
                Return the result of 
                <code><a>effective parent time</a> - startTime - <a>pause start
                time</a></code>.
              </dd>
            </dl>
          </dd>
          <dt>attribute boolean locallyPaused</dt>
          <dd>
            <p>
              The pause state of this timed item.
              Initially <code>false</code> except for the document timeline
              where it is initially true (see <a href="#start-of-the-timeline"
              class="sectionRef"></a>).
            </p>
            <p>
              When setting the following procedure is used:
            </p>
            <ol>
              <li>
                Let <var>new value</var> be the value to set.
              </li>
              <li>
                If <var>new value</var> equals <code>locallyPaused</code>,
                return.
              </li>
              <li>
                The next step depends on the current value of
                <code>locallyPaused</code> as follows,
                <dl class="switch">
                  <dt>If <code>locallyPaused</code> is true,</dt>
                  <dd>
                    Record the current value of <code>currentTime</code> as
                    <a>pause start time</a>.
                  </dd>
                  <dt>If <code>locallyPaused</code> is false,</dt>
                  <dd>
                    Set the stored value of <code>timeDrift</code> to the result
                    of evaluating <code><a>effective parent time</a> - startTime
                    - <a>pause start time</a></code>.
                  </dd>
                </dl>
              </li>
              <li>
                Set <code>locallyPaused</code> to <var>new value</var>.
              </li>
            </ol>
            <p class="issue">
              Should this be writeable?
              Once we integrate with media controllers we might want to make
              this writeable only when not associated with a media controller
              much like things currently work in HTML5.
            </p>
          </dd>
          <dt>readonly attribute boolean paused</dt>
          <dd>
            Indicates if this element or one of its ancestors is paused.
            This will be <code>true</code> if an only if the
            <code>locallyPaused</code> property of this object <em>or one of its
            ancestor animation groups</em> is <code>true</code>.
          </dd>
          <dt>void pause ()</dt>
          <dd>
            Sets the <code>locallyPaused</code> property to <code>true</code> by
            following the procedure described for setting that property.
            <p class="annotation">
              This method is intended to behave in a comparable manner to
              <a
              href="http://dev.w3.org/html5/spec/media-elements.html#media-elements">HTMLMediaElement</a>'s <a
              href="http://dev.w3.org/html5/spec/media-elements.html#dom-media-pause">pause
              method</a>.
            </p>
          </dd>
          <dt>void play ()</dt>
          <dd>
            <p>
              Unpauses this item and, if the item is not currently animating,
              seeks to the beginning of the <a>animation interval</a> by taking
              the following steps.
            </p>
            <ol>
              <li>If <code>currentTime &gt; timing.startDelay
                  + animationDuration</code> and
                  <code>timing.playbackRate &ge; 0</code>, set
                  <code>currentTime</code> to <code>timing.startDelay</code>.</li>
              <li>Set <code>locallyPaused</code> to <code>false</code>.</li>
            </ol>
            <p>
              To unpause the item without seeking, set
              <code>locallyPaused</code> to <code>false</code>.
            </p>
            <p class="annotation">
              This method is intended to behave in a comparable manner to
              <a
              href="http://dev.w3.org/html5/spec/media-elements.html#media-elements">HTMLMediaElement</a>'s <a
              href="http://dev.w3.org/html5/spec/media-elements.html#dom-media-play">play
              method</a>.
            </p>
          </dd>
          <dt>void changePlaybackRate (double playbackRate)</dt>
          <dd>
            <p>
              Updates the speed of the timed item such that it produces a smooth
              change.
            </p>
            <p>
              In particular:
            </p>
            <ul>
              <li>the <a>adjusted animation time</a> will not change,</li>
              <li>if the direction changes, <code>timing.fillMode</code> will be
                  inverted to prevent sudden jumps in output, and</li>
              <li>if the current <a>item time</a> is outside the animation
                  interval the distance from the interval is scaled according
                  to the change in speed.</li>
            </ul>
            <p>
              The smooth change is achieved using the following steps:
            </p>
            <ol>
              <li>Let <var>previous rate</var> be the value of
                  <code>timing.playbackRate</code> prior to updating it.</li>
              <li>Update <code>timing.playbackRate</code> to the passed-in
                  <code>playbackRate</code> parameter.</li>
              <li>Let <var>new rate</var> be the updated value of
                  <code>timing.playbackRate</code>.</li> 
              <li>If either <var>previous rate</var> or <var>new rate</var>
                  are zero, return.
                  <p class="issue">
                    This isn't great. If you set the playback rate to zero at
                    a given time, you expect it to act as if paused at that
                    time.
                    Currently, the only way to get that behavior out of the
                    model is to set the <code>iterationStart</code> and that
                    seems pretty intrusive.
                  </p>
              </li>
              <li>Invert the fill mode as follows:
                <dl class="switch">
                  <dt>If <code>timing.fillMode</code> is
                      <code>"forwards"</code>,</dt>
                  <dd>
                    Set <code>timing.fillMode</code> to
                    <code>"backwards"</code>.
                  </dd>
                  <dt>If <code>timing.fillMode</code> is
                      <code>"backwards"</code>,</dt>
                  <dd>
                    Set <code>timing.fillMode</code> to <code>"forwards"</code>.
                  </dd>
                  <dt>Otherwise,</dt>
                  <dd>Leave <code>timing.fillMode</code> as is.</dd>
                </dl>
              </li>
              <li>If <a>item time</a> is <code>null</code>, return.</li>
              <li>Update the value of <code>animationDuration</code> if
                  necessary (that is, if <code>animationDuration</code> reflects
                  the <a>intrinsic animation duration</a>), applying the
                  updated value for <code>timing.speed</code>.</li>
              <li>Calculate the <var>seek adjustment</var> according to the
                  following formula:
                  <code><var>seek adjustment</var> =
                  (<a>item time</a> - <code>timing.startDelay</code>) *
                  (1 - <var>previous rate</var> / <var>new rate</var>)</code>.
                  </li>
              <li>If the sign of <var>new rate</var> and <var>previous
                  rate</var> differs, subtract from the updated value for the
                  <code>animationDuration</code>.</li>
              <li>Let <var>seek time</var> be the result of the following
                  formula:
                  <code><a>item time</a>
                    - <var>seek adjustment</var></code>.</li>
              <li>Set <code>currentTime</code> to <var>seek time</var>.</li>
            </ol>
            <p>
              Exceptions:
            </p>
            <dl class="exceptions">
              <dt>DOMException of type
                  <code>NoModificationAllowedError</code></dt>
              <dd>
                Raised if this item is a linked item, that is, if
                <code>template</code> is not <code>null</code>
                (see <a href="#animation-templates" class="sectionRef"></a>).
              </dd>
            </dl>
          </dd>
          <dt>void reverse ()</dt>
          <dd>
            <p>
              Reverses this animation such that the reverse animation
              immediately begins reversing from its current point.
              Note that this means that an animation that has yet to begin,
              calling <code>reverse</code> will mean that it never starts.
            </p>
            <li>
              Calculate <var>seek time</var> as follows:
            </li>
              <dl class="switch">
                <dt>If <code>currentTime</code> is null,</dt>
                <dd>
                  Let <var>seek time</var> be zero.
                </dd>
                <dt>If <code>currentTime &lt; timing.startDelay</code>,</dt>
                <dd>
                  Let <var>seek time</var> be
                  <code>timing.startDelay + animationDuration</code>.
                </dd>
                <dt>If <code>currentTime &gt;
                    timing.startDelay + animationDuration</code>,</dt>
                <dd>
                  Let <var>seek time</var> be <code>timing.startDelay</code>.
                </dd>
                <dt>Otherwise,</dt>
                <dd>
                  Let <var>seek time</var> be
                  <code>animationDuration - currentTime - startDelay</code>.
                </dd>
              </dl>
            </li>
            <li>
              Call <code>changePlaybackRate(-timing.playbackRate)</code>.
            </li>
            <li>
              Set <code>currentTime</code> to <var>seek time</var>.
            </li>
            <p>
              Exceptions:
            </p>
            <dl class="exceptions">
              <dt>DOMException of type
                  <code>NoModificationAllowedError</code></dt>
              <dd>
                Raised if this item is a linked item, that is, if
                <code>template</code> is not <code>null</code>
                (see <a href="#animation-templates" class="sectionRef"></a>).
              </dd>
            </dl>
          </dd>
          <dt>void cancel ()</dt>
          <dd>
            <p>
              Removes the timed item from its parent group. As a result, the
              timed item will no longer affect its target.
            </p>
            <p>
              Exceptions:
            </p>
            <dl class="exceptions">
              <dt>DOMException of type
                  <code>NoModificationAllowedError</code></dt>
              <dd>
                Raised if this item is a linked item, that is, if
                <code>template</code> is not <code>null</code>
                (see <a href="#animation-templates" class="sectionRef"></a>).
              </dd>
            </dl>
            <p class="feedbackWanted">
              Is this exception necessary? It will depend how we approach group
              templates.
            </p>
          </dd>
        </dl>
        <div class="todo">
          <p>
            Do we need a means for getting the startTime etc. in document
            time (i.e. in terms of the root time container)?
          </p>
        </div>
      </section>
      <section>
        <h3>Timing model common definitions</h3>
        <p>
          In order to calculate various properties of the timing model the
          following common definitions are used.
        </p>
        <ul>
          <li><dfn>effective iteration start</dfn> =
              <code>min(timing.iterationStart, timing.iterationCount)</code>
          </li>
          <li><dfn>effective parent time</dfn> =
              <code>parentGroup.iterationTime</code> unless
              <code>parentGroup</code> or <code>parentGroup.iterationTime</code>
              is <code>null</code> in which case it is zero.</li>
        </ul>
      </section>
      <section>
        <h3>Calculating the iteration duration</h3>
        <p>
          The <dfn>iteration duration</dfn> is calculated according to the
          following steps:
        </p>
        <dl class="switch">
          <dt>
            If the <code>timing.duration</code> timing property is set
            to a numerical value greater than or equal to zero (including
            positive infinity),
          </dt>
          <dd>
            return <code>timing.duration</code>.
          </dd>
          <dt>
            Otherwise,
          </dt>
          <dd>
            return the item's <a>intrinsic duration</a>.
          </dd>
        </dl>
        <p>
          The value of an item's <dfn>intrinsic duration</dfn> depends on
          the type of the item.
        </p>
        <p>
          For animations the <a>intrinsic duration</a> is zero.
          The intrinsic duration for animation groups and media items
          is described under <a
      href="#the-intrinsic-duration-of-a-parallel-animation-group"
          class="sectionRef"></a>, <a
      href="#the-intrinsic-duration-of-a-sequence-animation-group"
          class="sectionRef"></a>,
          and <a
          href="#the-intrinsic-duration-of-a-media-item"
          class="sectionRef"></a>.
        </p>
      </section>
      <section>
        <h3>Calculating the intrinsic animation duration</h3>
        <p>
          In order to calculated the <a>intrinsic animation duration</a> we
          first define the <a>repeated duration</a> as follows:
        </p>
        <blockquote>
          <dfn>repeated duration</dfn> =
            <code><a>iteration duration</a> *
                  <a>timing.iterationCount</a></code>
        </blockquote>
        <p>
          The <dfn>intrinsic animation duration</dfn> is calculated according to
          the following steps:
        </p>
        <ol>
          <li>
            If <code>timing.playbackRate</code> is zero, return
            <code>Infinity</code>.
          </li>
          <li>
            Otherwise, return <code><a>repeated duration</a>
            / abs(<code>timing.playbackRate</code>)</code>.
          </li>
        </ol>
      </section>
      <section>
        <h3>Calculating the item time</h3>
        <p>
          The <dfn>item time</dfn> is calculated according to the following
          equation:
        </p>
        <blockquote>
          <code><var>item time</var> = parentGroup.iterationTime
            - startTime - timeDrift</code>
        </blockquote>
        <p>
          If either <code>parentGroup</code> or
          <code>parentGroup.iterationTime</code> is <code>null</code>, the
          <var>item time</var> is <code>null</code>.
        </p>
        <p class="todo">
          Need to define this for the document timeline.
        </p>
      </section>
      <section>
        <h3>Calculating the animation time</h3>
        <p>
          The <dfn>animation time</dfn> is based on the <a>item time</a>
          and <var>start delay</var>.
          It is defined only when the timed item is <a>in effect</a> and is
          calculated according to the following steps:
        </p>
        <ol>
          <li>
            If <a>item time</a> is <code>null</code>, return <code>null</code>.
          </li>
          <li>
            If <code><a>item time</a> &lt; timing.startDelay</code>
            the result depends on the <var>fill mode</var> as follows,
            <dl class="switch">
              <dt>
                If the <var>fill mode</var> is <em>backwards</em> or
                <em>both</em>,
              </dt>
              <dd>
                return zero.
              <dd>
              <dt>
                Otherwise,
              </dt>
              <dd>
                return <code>null</code>.
              </dd>
            </dl>
          </li>
          <li>
            If <code><a>item time</a> &lt;
            timing.startTime + animationDuration</code>, return
            <code><a>item time</a> - timing.startDelay</code>.
          </li>
          <li>
            Otherwise, the result depends on the <var>fill mode</var> as
            follows,
            <dl class="switch">
              <dt>
                If the <var>fill mode</var> is <em>forwards</em> or
                <em>both</em>,
              </dt>
              <dd>
                return <code>animationDuration</code>.
              <dd>
              <dt>
                Otherwise,
              </dt>
              <dd>
                return <code>null</code>.
              </dd>
            </dl>
          </li>
        </ol>
      </section>
      <section>
        <h3>Calculating the iteration time</h3>
        <p>
          The iteration time is calculated by first applying the animation's
          <code>playbackRate</code> and <code>iterationStart</code> properties
          to produce the <a>adjsuted animation time</a>
          The <a>adjusted animation time</a> is then divided into intervals
          resulting in the <a>unscaled iteration time</a>.
          Following this, timing manipulations specified on the timed item are
          applied to the <a>unscaled iteration time</a> to produce the
          <a>iteration time</a>.
        </p>
        <section>
          <h4>Calculating the adjusted animation time</h4>
          <p>
            Before the <a>animation time</a> can be converted to an <a>iteration
            time</a> we must factor in the animation's <var>playback rate</var>
            and <var>iteration start</var>.
            This is called the <a>adjusted animation time</a>.
          </p>
          <p>
            In order to calculated the <a>adjusted animation time</a> we first
            define the <a>start offset</a> as follows:
          </p>
          <blockquote>
            <dfn>start offset</dfn> =
              <code><a>effective iteration start</a> *
                    <a>iteration duration</a></code>
          </blockquote>
          <p>
            The <dfn>adjusted animation time</dfn> is calculated according to
            the following steps:
          </p>
          <ol>
            <li>
              If the <a>animation time</a> is <code>null</code>, return
              <code>null</code>.
            </li>
            <li>
              Return the adjusted animation time based on the
              <code>timing.playbackRate</code> as follows,
              <dl class="switch">
                <dt>If <code>timing.playbackRate</code> is negative,</dt>
                <dd>
                Return <code>(<a>animation time</a> -
                              animationDuration) * timing.playbackRate
                        + <a>start offset</a></code>.
                </dd>
                <dt>Otherwise,</dt>
                <dd>
                  Return <code><a>animation time</a> * timing.playbackRate
                  + <a>start offset</a></code>.
                </dd>
            </li>
          </ol>
        </section>
        <section>
          <h4>Calculating the unscaled iteration time</h4>
          <p>
            The <dfn>unscaled iteration time</dfn> is calculated according to
            the following steps:
          </p>
          <ol>
            <li>
              If the <a>item time</a> is <code>null</code>,
              return <code>null</code>.
            </li>
            <li>
              If the <a>iteration duration</a> is zero, return zero.
            </li>
            <li>
              If <code><a>adjusted animation time</a> -
                       <a>start offset</a></code> equals the
              <a>repeated duration</a>, and
              <code>(timing.iterationCount - <a>effective iteration start</a>)
              % 1</code> is zero, return the <var>iteration duration</var>.
            </li>
            <li>
              Otherwise, return <code><a>adjusted animation time</a>
              % <var>iteration duration</var></code>.
            </li>
          </ol>
        </section>
        <section>
          <h4>Applying time manipulations</h4>
          <p>
            The <a>unscaled iteration time</a> is converted into the
            <dfn>iteration time</dfn> using the following steps:
          <ol>
            <li>
              If the <var>unscaled iteration time</var> is <code>null</code>,
              return <code>null</code>.
            </li>
            <li>
              Scale the time as follows:
              <dl class="switch">
                <dt>If <var>timing.timingFunction</var> is
                    a <a>TimingFunction</a> object,</dt>
                <dd>
                  <p>
                    Let <var>scaled iteration time</var> be
                    <code>unscaled iteration time *
                      timing.timingFunction.scaleTime(<var>unscaled iteration
                      time</var> / <a>iteration duration</a>)))</code>.
                  </p>
                </dd>
                <dt>Otherwise,</dt>
                <dd>
                  Let <var>scaled iteration time</var> be <var>unscaled
                  iteration time</var>.
                </dd>
              </dl>
            </li>
            <li>
              Calculate the <var>current direction</var> using the first
              matching condition from the following list:
              <dl class="switch">
                <dt>
                  If the direction is normal,
                </dt>
                <dd>Let the <var>current direction</var> be forwards.</dd>
                <dt>
                  If the direction is reverse,
                </dt>
                <dd>Let the <var>current direction</var> be reverse.</dd>
                <dt>
                  Otherwise,
                </dt>
                <dd>
                  <ol>
                    <li>
                      Let <var>d</var> be the <a>current iteration</a>.
                    </li>
                    <li>
                      If the direction is alternate-reverse increment
                      <var>d</var> by 1.
                    </li>
                    <li>
                      If the animation is not animating, and the
                      <code>animationDuration</code> is a positive multiple of
                      the <a>iteration duration</a> increment <var>d</var>
                      by 1.
                    </li>
                    <li>
                      If <code><var>d</var> % 2 == 0</code>, let the
                      <var>current direction</var> be forwards, otherwise let
                      the <var>current direction</var> be reverse.
                    </li>
                  </ol>
                </dd>
              </dl>
            </li>
            <li>
              If the <var>current direction</var> is forwards then return
              the <var>scaled iteration time</var>.
              <p>
                Otherwise, return the <a>iteration duration</a>
                - <var>scaled iteration time</var>.
              </p>
            </li>
          </ol>
          <p class="note">
            Applying the reverse behavior after applying the timing function
            means that ease-in becomes ease-out on reverse, however it avoids
            jumps in values when reversing part-way.
          </p>
        </section>
        <section>
          <h4>Calculating the time fraction</h4>
          <p>
            The <dfn>time fraction</dfn> is given by dividing the <var>iteration
            time</var> by the <a>iteration duration</a>.
          </p>
          <p class="note">
            Since <a href="#scaling-the-time">timing functions</a> are allowed
            to produce output times outside the range [0,1] it is possible that
            the value calculated for a <a>time fraction</a> also lies outside
            this range.
          </p>
        </section>
        <section>
          <h4>Calculating the current iteration</h4>
          <p>
            The <dfn>current iteration</dfn> can be calculated from the
            following steps:
          </p>
          <ol>
            <li>
              If the <a>item time</a> is <code>null</code>, return
              <code>null</code>.
            </li>
            <li>
              If the <a>adjusted animation time</a> is zero, return zero.
            </li>
            <li>
              If the <a>iteration duration</a> is zero, return
              <code>floor(timing.iterationCount)</code>.
            </li>
            <li>
              Return <code>floor(<a>adjusted animation time</a> /
              <a>iteration duration</a>)</code>.
              <p class="note">
                If the <a>iteration duration</a> is infinite, the
                result of <code>floor(<a>adjusted animation time</a> /
                <a>iteration duration</a>)</code> will be zero as defined by
                IEEE 754-2008.
              </p>
            </li>
          </ol>
        </section>
      </section>
      <section>
        <h3>Pausing a timed item</h3>
        <div class="informative">
          <p>
            Timed items may be paused and resumed independently of the parent
            animation group they belong to.
            The effect is that the time of the item lags behind that of its
            parent.
            This lag is called the <var>time drift</var> and acts as an
            additional delay added to the <var>start time</var> of the item.
          </p>
          <p>
            Timed elements that do not have a parent animation group may still
            be paused and resumed.
            However, except for the case of the document timeline, there will be
            no observable effect until the element is attached to a parent
            animation group.
          </p>
        </div>
        <p>
          Pausing and seeking are realised using two additional inputs to the
          timing model, the <dfn>time drift</dfn> which is exposed as the
          <code>timeDrift</code> property on the <a>TimedItem</a> interface, and
          the <dfn>pause start time</dfn> which is internal to the model.
          Both the <var>time drift</var> and <var>pause start time</var> are
          initially zero.
        </p>
        <p>
          The pausing behavior is realised through the specific steps defined
          for calculating and updating the <code>locallyPaused</code> and
          <code>timeDrift</code> properties of the <a>TimedItem</a> interface.
        </p>
      </section>
      <section>
        <h3>Seeking a timed item</h3>
        <div class="informative">
          <p>
            Seeking, like pausing, has the effect of causing a timed item's
            time to drift from that of its parent animation group.
            Consequently, it is also uses the <a>time drift</a> and
            <a>pause start time</a> concepts on which pausing is based.
          </p>
        </div>
        <p>
          Seeking is performed in response to a change to a timed item's
          <code>currentTime</code> property and is realised by adjusting the
          <code>timeDrift</code> property or the internal <a>pause start
          time</a> of the item as follows:
        </p>
        <ol>
          <li>Let <var>seek time</var> be the new value to which
              <code>currentTime</code> should be set.</li>
          <li>The steps for adjusting the item time depend on the state of the
              <code>locallyPaused</code> property as follows:
            <dl class="switch">
              <dt>If <code>locallyPaused</code> is true,</dt>
              <dd>
                Set <a>pause start time</a> to <var>seek time</var>.
              </dd>
              <dt>If <code>locallyPaused</code> is false,</dt>
              <dd>
                Set the stored value for <code>timeDrift</code> to
                the result of evaluating
                <code><a>effective parent time</a> - startTime -
                      <var>seek time</var></code>.
              </dd>
            </dl>
          </li>
        </ol>
        <p class="note">
          Note that the <code>currentTime</code> property is not actually set
          directly but is updated to the seek time as a result of the
          calculation outlined in the decsription of the
          <code>currentTime</code> property on the <a>TimedItem</a> interface.
        </p>
        <p>
          The animation events dispatched when a seek is performed are described
          in <a href="#animation-events" class="sectionRef"></a>.
        </p>
      </section>
    </section>

    <section>
      <h2>Scaling the time</h2>
      <div class="informative">
        <p>
          It is often desirable to control the rate at which an animation
          progresses.
          For example, easing the rate of animation can create a sense of
          momentum and produce a more natural effect.
          Conversely, in other situations such as when modelling a discrete
          change, a smooth transition is undesirable and instead it is necessary
          for the animation to progress in a series of distinct steps.
        </p>
        <p>
          For such situations Web Animations provides a variety of timing
          functions that scale the progress of an animation.
          In situations where the timing functions defined here are
          insufficient, it is possible to provide a custom script-based timing
          function.
        </p>
        <p>
          In all cases, timing functions take an input time and produce a scaled
          output time.
        </p>
        <p class="todo">
          Diagram
        </p>
        <p>
          Such timing functions can be applied to an iteration of an animation
          as a whole via the <a>TimedItem</a> interface or to a segment of
          a keyframe animation via the <a>KeyframeAnimationFunction</a>
          interface.
        </p>
      </div>
      <section>
        <h3>The <code>TimingFunction</code> interface</h3>
        <p>
          The timing functions provided by Web Animations share a common
          <a>TimingFunction</a> interface as defined below.
        </p>
        <dl title="interface TimingFunction" class="idl">
          <dt>double scaleTime()</dt>
          <dd>
            <p>
              Takes an input time fraction in the range [0, 1] and applies some
              transformation on the value to produce an output time fraction
              (typically, but not necessarily, also in the range [0, 1]).
            </p>
            <dl class="parameters">
              <dt>double time</dt> <!-- Oh yeah! -->
              <dd>
                The input time fraction.
              </dd>
              <dt>TimedItem? item</dt>
              <dd>
                <p>
                  The <a>TimedItem</a> for which the time scaling operation is
                  being performed.
                </p>
                <p>
                  Some timing functions, for example, may produce different
                  results depending on the animation values involved to produce
                  an even rate of change.
                </p>
                <p>
                  This may be <code>null</code>, for example, when invoked
                  directly by user code for the purpose of testing or re-using
                  the scaling operation in another context.
                </p>
                <p>
                  Implementations of this interface for which there is no
                  meaningful result in the absence of a <a>TimedItem</a> will
                  simply return <code>time</code> unchanged when
                  <code>item</code> is <code>null</code>.
                </p>
              </dd>
            </dl>
          </dd>
          <dt>TimingFunction clone()</dt>
          <dd>
            <p>
              For implementations of this interface that have local state,
              produces an identical but independent copy of this object.
              For implementations without local state, returns the same object.
            </p>
          </dd>
          <dt>static TimingFunction? createFromString(DOMString spec)</dt>
          <dd>
            <p>
              Creates a new <a>TimingFunction</a> object based on a string-based
              specification (e.g. "ease-in").
            </p>
            <p>
              The acceptable values and their meanings are those defined for the
              <a
              href="http://www.w3.org/TR/css3-transitions/#transition-timing-function-property">transition-timing-function</a>
              property in CSS Transitions [[!CSS3-TRANSITIONS]].
            </p>
            <p>
              In addition to the values defined in CSS Transitions, this method
              extends the <code>steps()</code> function notation to allow
              &lsquo;middle&rsquo; as a transition point keyword (e.g.
              <code>steps(3, middle)</code>) corresponding to the
              &lsquo;middle&rsquo; <a>StepPosition</a> value.
              Similarly, the keyword &lsquo;steps-middle&rsquo; is recognized by
              and given the meaning <code>steps(1, middle)</code>.
            </p>
            <p>
              Strings that specify a cubic-bezier timing function result in
              a new <a>SplineTimingFunction</a> being returned.
              Strings that specify a stepping function produce a new
              <a>StepTimingFunction</a>.
            </p>
            <p>
              If <code>spec</code> is unrecognized, <code>null</code> is
              returned.
              User agents that provide debugging feedback SHOULD report the
              unrecognized value.
            </p>
            <p class="issue">
              So the string <code>cubic-bezier(...)</code> produces
              a <a>SplineTimingFunction</a>.
              That's a bit confusing.
              But <code>CubicBezierTimingFunction</code> is a lot to type and
              not very user-friendly.
            </p>
            <p class="issue">
              Should we make the &lsquo;linear&rsquo; keyword return
              <code>null</code> as well?
              If we do, we need to be careful to update the constructor for
              <a>Timing</a> so that it doesn't throw an exception in that case
              (or report anything to the console).
            </p>
          </dd>
        </dl>
      </section>
      <section>
        <h3>Scaling using a cubic Bzier curve</h3>
        <p>
          A common method of producing easing effects is to use a cubic Bzier
          curve to scale the time.
          The endpoints of the curve are fixed at (0,0) and (1,1) while two
          control points <var>P1</var> and <var>P2</var> define the shape of the
          curve.
          Provided the <var>x</var> values of <var>P1</var> and <var>P2</var>
          lie within the range [0,1] such a curve produces a function that is
          used to map input times (the <var>x</var> values) onto output times
          (the <var>y</var> values).
          This arrangement is illustrated below.
        </p>
        <div class="figure">
          <img src="img/cubic-bezier-timing-curve.svg" width="500">
        </div>
        <p class="caption">
          A cubic Bzier curve used as a timing function.<br>
          The shape of the curve is determined by the location of the control
          points <var>P1</var> and <var>P2</var>.<br>
          Input time fractions serve as <var>x</var> values of the curve, whilst
          the <var>y</var> values are the output time fractions.
        </p>
        <p>
          The curves produced by the keywords accepted by the
          <a href="#widl-TimingFunction-createFromString-TimingFunction-DOMString-spec"
          class="idlType"><code>Timing.createFromString</code></a>
          method are illustrated below.
        </p>
        <div class="figure">
          <img src="img/curve-keywords.svg" width="500">
        </div>
        <p class="caption">
          The timing functions produced by each of the keyword values.
        </p>
        <section>
          <h4>The <code>SplineTimingFunction</code> interface</h4>
          <p>
            Cubic bzier curve based timing functions are represented using
            the <code>SplineTimingFunction</code> interface defined below.
          </p>
          <dl title="interface SplineTimingFunction : TimingFunction"
            class="idl">
            <dt>Constructor (sequence&lt;double&gt; points)</dt>
            <dd>
              <p>
                Creates a new <a>SplineTimingFunction</a> object and initializes
                the <code>points</code> member to the passed in list of
                <code>points</code>.
              </p>
              <p class="annotation">
                It would be more convenient for authors if the passed in list of
                points could be longer than four items and we simply read the
                first four items and ignored the rest.
                However, applications may begin to depend on that behavior and
                we could not easily allow this object to take longer lists (to
                represent more complex curves) in the future without adding
                a separate constructor for that purpose.
              </p>
              <p>
                Exceptions:
              </p>
              <dl class="exceptions">
                <dt>DOMException of type <code>IndexSizeError</code></dt>
                <dd>
                  Raised if any of the <var>x</var> values in
                  <code>points</code> is outside the range [0, 1]
                  or if the length of <code>points</code> is not 4 items.
                </dd>
              </dl>
            </dd>
            <dt>attribute sequence&lt;double&gt; points</dt>
            <dd>
              <p>
                A sequence of four real numbers representing the coordinates of
                the two control points in the following sequence
                <var>&lt;p1-x&gt;</var> <var>&lt;p1-y&gt;</var>
                <var>&lt;p2-x&gt;</var> <var>&lt;p2-y&gt;</var>.
              </p>
              <p>
                Each of the <var>x</var> values (i.e. <var>p1-x</var> and
                <var>p2-x</var>) must be in the range [0, 1].
              </p>
              <p>
                Exceptions:
              </p>
              <dl class="exceptions">
                <dt>DOMException of type <code>IndexSizeError</code></dt>
                <dd>
                  Raised on setting if an <var>x</var> value is outside the
                  range [0, 1].
                </dd>
                <dt>DOMException of type
                    <code>InvalidModificationError</code></dt>
                <dd>
                  Raised on attempting to alter the length of
                  <code>points</code>.
                </dd>
              </dl>
            </dd>
            <dt>double scaleTime(double time, TimedItem? item)</dt>
            <dd>
              Applies the timing function produced by the cubic Bzier curve
              with points (0,0), (<code>points[0], points[1]</code>),
              (<code>points[2]</code>, <code>points[3]</code>), (1, 1).
              Returns the resulting <var>y</var> value when the <var>x</var>
              value is <code>max(0, min(1, time))</code>.
            </dd>
            <dt>TimingFunction clone()</dt>
            <dd>
              Returns a copy of this object.
            </dd>
          </dl>
        </section>
      </section>
      <section>
        <h3>Timing in discrete steps</h3>
        <p>
          It is possible to scale an animation's timing so that the animation
          occurs in a series of discrete steps using a stepping function.
        </p>
        <p>
          A stepping function divides the input time into a specified number of
          intervals that are equal in duration.
          The output time, starting at zero, rises by an amount equal to the
          interval duration once during each interval at the transition point
          which may be either the start, midpoint, or end of the interval.
        </p>
        <p>
          In keeping with Web Animation's model for endpoint exclusive interval
          timing (see <a href="#interval-timing" class="sectionRef"></a>), the
          output time at the transition point is the time <em>after</em>
          applying the increase (i.e. the top of the step).
        </p>
        <p>
          Some example step timing functions are illustrated below.
        </p>
        <div class="figure">
          <img src="img/step-timing-func-examples.svg" width="700">
        </div>
        <p class="caption">
          Example step timing functions.
          In each case the domain is the input time fraction whilst the range
          represents the output time fraction produced by the step function.<br>
          The first row shows the function for each transition point when only
          one step is specified whilst the second row shows the same for three
          steps.
        </p>
        <section>
          <h4>The <code>StepPosition</code> enumeration</h4>
          <p>
            The point within a step interval at which the change in value occurs
            is specified using one of the <a>StepPosition</a> enumeration
            values.
          <dl title="enum StepPosition" class="idl">
            <dt>start</dt>
            <dd>
              The change in value occurs at the beginning of the interval.
            </dd>
            <dt>middle</dt>
            <dd>
              The change in value occurs at the midpoint of the interval.
            </dd>
            <dt>end</dt>
            <dd>
              The change in value occurs at the end of the interval.
            </dd>
          </dl>
        </section>
        <section>
          <h4>The <code>StepTimingFunction</code> interface</h4>
          <p>
            Step timing functions are represented by the
            <a>StepTimingFunction</a> interface.
          </p>
          <dl title="interface StepTimingFunction : TimingFunction" class="idl">
            <dt>Constructor (unsigned integer numSteps,
                             optional StepPosition position = 'end')</dt>
            <dd>
              <p>
                Creates a new <a>StepTimingFunction</a> with the specified
                number of steps and transition point.
              </p>
              <p>
                Exceptions:
              </p>
              <dl class="exceptions">
                <dt>DOMException of type <code>IndexSizeError</code></dt>
                <dd>
                  Raised if <code>numSteps</code> is zero.
                </dd>
              </dl>
            </dd>
            <dt>attribute unsigned integer numSteps</dt>
            <dd>
              <p>
                A number greater than or equal to one representing the number of
                steps in the function.
              </p>
              <p>
                Exceptions:
              </p>
              <dl class="exceptions">
                <dt>DOMException of type <code>IndexSizeError</code></dt>
                <dd>
                  Raised on setting if the number of steps is zero.
                </dd>
              </dl>
            </dd>
            <dt>attribute StepPosition position</dt>
            <dd>
              The point within each interval at which the change in value
              occurs.
            </dd>
            <dt>double scaleTime(double time, TimedItem? item)</dt>
            <dd>
              Returns the value of applying the step function defined by
              <a>numSteps</a> and <a>position</a> with input <var>time</var>.
              The behavior of the step function is described in <a
              href="#timing-in-discrete-steps" class="sectionRef"></a>.
            </dd>
            <dt>TimingFunction clone()</dt>
            <dd>
              Returns a copy of this object.
            </dd>
          </dl>
        </section>
      </section>
      <section>
        <h3>The <code>SmoothTimingFunction</code> interface</h3>
        <div class="todo">
          <p>
            Need help from someone who knows math.
            We'd like to be able to have a function with many extrema.
            Ideally, something like Catmull-Rom curves would be great where you
            could just say:
          </p>
          <p>
            <tt>[ 0: 0, 0.7: 1, 0.8: 0.9, 1: 1 ]</tt>
          </p>
          <p>
            And you'd get a smooth curve that goes to the full value and bounces
            back a bit then finishes.
          </p>
          <p>
            The trouble is that Catmull-Rom curves won't necessarily give you
            a function even if you sort the <var>x</var> values.
          </p>
        </div>
        <dl title="
[Constructor (sequence&lt;double&gt; points)]
          interface SmoothTimingFunction : TimingFunction" class="idl">
          <dt>attribute sequence&lt;double&gt; points</dt>
          <dd>
            TBD
          </dd>
        </dl>
      </section>
    </section>

    <section>
      <h2>Grouping and synchronization</h2>
      <div class="informative">
      <p>
        While it is possible to set the timing properties of animations
        individually, it is often useful to bundle animations together and
        control their timing as a group.
      </p>
      <p>
        This can be used to share common timing properties as illustrated below:
      </p>
      <div class="figure">
        <img src="img/grouping-delay.svg" width="800">
      </div>
      <p class="caption">
        Using groups to share common timing properties.<br>
        (a) Shows setting a delay of 5 seconds on individual animations.<br>
        (b) Produces the same effect by setting the delay on the group.
      </p>
      <p>
        As well as sharing timing information, by grouping animations together
        they can be seeked, paused, and stopped as a unit.
      </p>
      </div>
      <section class="informative">
        <h3>Relationship of group time to child time</h3>
        <p>
          The timing of the children of a group is based on the timing of the
          group. Specifically, times for the children are based on the parent's
          <em>iteration time</em>. That is, the children animate <em>inside</em>
          an iteration of the parent.
        </p>
        <p>
          As an example, consider repetition. If a group has an iteration count
          of 2, then the children of of the group will all play twice since they
          effectively play <em>inside</em> the group's iterations.
        </p>
        <div class="figure">
          <img src="img/grouping-repetition.svg" width="600">
        </div>
        <p class="caption">
          Since children of an animation group base their timing on the group's
          <var>iteration time</var>, when the group repeats, the children play
          again.
        </p>
        <p>
          If an iteration count is specified for the children of a group as well
          as for the group the effect is as if the iteration count of the group
          was multiplied with the iteration count of the children.
        </p>
        <div class="figure">
          <img src="img/grouping-repetition-and-animation-repetition.svg"
            width="600">
        </div>
        <p class="caption">
          Specifying an iteration count of 2 on an animation group and an
          iteration count of 3 on one of its children results in that child
          playing 6 times.
        </p>
        <p>
          A further result of the children of a group basing their timing on the
          group's <var>iteration time</var> is that they cannot animate outside
          of the group's <a>animation interval</a>.
          This is because the <var>iteration time</var> of a group will not
          change outside its animation interval.
          This allows groups to clip the playback of their children.
        </p>
        <div class="figure">
          <img src="img/grouping-clipping.svg" width="600">
        </div>
        <p class="caption">
          In the first instance, an animation has a negative delay and an
          infinite iteration count.<br>
          However, when a similar animation is placed inside a group with
          a specified duration it has the effect of clipping the animation's
          duration.
        </p>
        <p>
          Some further consequences of group children basing their timing on
          their parent group's <var>iteration time</var> are:
        </p>
        <ul>
          <li>
            Setting the playback rate of an animation group will speed up or
            slow down all children.
          </li>
          <li>
            Changing the playback direction of an animation group will change
            the direction of all children.
          </li>
          <li>
            Applying a timing function to an animation group will affect the
            playback rate of all children.
          </li>
        </p>
      </section>
      <section class="informative">
        <h3>Types of groups</h3>
        <p>
          Groups can be used to provide synchronization behavior for its
          children.
          For example, one type of group runs its children in parallel, whilst
          another type runs the children in sequence.
        </p>
        <p>
          Compare the two arrangements illustrated below:
        </p>
        <div class="figure">
          <img src="img/grouping-types.svg" width="600">
        </div>
        <p class="caption">
          Two types of animation groups.<br>
          (a) is a parallel group where all the children run simultaneously.<br>
          (b) is a sequence group where the children run in turn.
        </p>
        <p>
          Groups can also contain other groups which allows for more
          sophisticated synchronization.
        </p>
        <div class="figure">
          <img src="img/grouping-nesting.svg" width="600">
        </div>
        <p class="caption">
          A sequence animation group that contains a parallel animation group as
          a child.<br>
          The parallel group waits for the previous child of the sequence
          group to finish, and then the children of the parallel group play
          simultaneously.
          After they have finished the next child of the sequence group plays.
        </p>
        <p>
          Web Animations defines two types of animation groups.
        </p>
        <dl>
          <dt>Parallel groups</dt>
          <dd>
            Children of the group play simultaneously.
            The start time of children is taken as relative to the start of the
            current iteration of the group, that is, it is in the group's
            <em>iteration time space</em>.
          </dd>
          <dt>Sequence groups</dt>
          <dd>
            Children of the group play in turn beginning with the first child
            and proceeding to the last.
            Any start time specified on children is ignored and replaced with
            the time calculated using the procedure in <a
            href="#the-start-time-of-children-of-a-sequence-animation-group"
            class="sectionRef"></a>.
          </dd>
        </dl>
      </section>
      <section>
        <h3>The document timeline</h3>
        <p class="todo">
          Move all this to its own section later on.
        </p>
        <p>
          We have previously referred to the document timeline as the context in
          which animation takes places.
          Likewise we have referred to the <em>document time space</em> as the
          master time space which contains other time spaces.
          The document timeline is, in fact, a parallel animation group
          with the following special properties:
        </p>
        <ul>
          <li>
            It cannot be appended as a child of another group. As a result the
            <code>parentGroup</code> property returns <code>null</code>.
          </li>
          <li>
            Calls to <code>cancel()</code> will result in a DOMException of type
            HierarchyRequestError being thrown.
          </li>
          <li>
            <p>
              For properties that represent times in <em>parent iteration time
              space</em> a time space whose zero time is 00:00:00 UTC on
              1 January 1970 is used.
            </p>
            <p>
              As a result, the <var>parent iteration time</var> is the number of
              seconds from 00:00:00 UTC on 1 January 1970 to the current moment
              in UTC time.
            </p>
            <p class="issue">
              We should use a monotonically increasing timestamp here.
              Not one that can potentially skip due to clock adjustments.
            </p>
          </li>
          <li>
            It is initially paused as described in <a
              href="#initial-state-of-the-document-timeline"
              class="sectionRef"></a>.
          </li>
        </ul>
        <p class="todo">
          Move/copy exception behavior to the relevant properties / methods.
        </p>
        <section>
          <h4>Initial state of the document timeline</h4>
          <p>
            Unlike other timed items, the document timeline is initially paused.
            The moment at which the timeline becomes unpaused is defined in <a
              href="#start-of-the-timeline" class="sectionRef"></a>.
          </p>
          <p>
            On creating an <code>AnimationGroupInstance</code> corresponding to
            the document timeline, the following steps are performed.
          </p>
          <ol>
            <li>
              Set the <var>start time</var> to the current <var>parent
              iteration time</var> (i.e. the number of seconds since 00:00:00
              UTC on 1 January 1970).
            </li>
            <li>
              Set the <var>pause state</var> to <code>true</code>.
            </li>
          </ol>
          <p class="note">
            By setting the <var>start time</var> to the <var>parent iteration
            time</var> and then pausing the timeline, the start time is always
            well-defined.
            Furthermore, seeking the timeline before it is unpaused provides
            intuitive results without special casing the algorithm for seeking
            (see <a href="#seeking-a-timed-item" class="sectionRef"></a>).
          </p>
        </section>
        <section>
          <h4>Start of the timeline</h4>
          <p>
            The time at which the timeline will be automatically unpaused is
            determined by the <code>timelineStart</code> property on the
            <code>Document</code> object (see <a
            href="#extensions-to-the-document-interface"
            class="sectionRef"></a>). It can have the following values:
          </p>
          <dl title="enum AnimStartType" class="idl">
            <dt>onload</dt>
            <dd>
              <p>
                The moment immediately prior to dispatching the "load" event for
                the document.
              </p>
              <p>
                For HTML documents, this is the moment after the <a
                  href="http://dev.w3.org/html5/spec/dom.html#current-document-readiness">current
                  document readiness</a> has changed to "complete" but before
                dispatching the load event.  In terms of the timings defined in
                <a
                  href="http://test.w3.org/webperf/specs/NavigationTiming/">NAVIGATION-TIMING</a>
                <span class="todo">(Need to add NAVIGATION-TIMING to the
                  biblio)</span>, this occurs between the <em>domComplete</em>
                and <em>loadEventStart</em> timings.
              </p>
              <p>
                This is the default value.
              </p>
            </dd>
            <dt>onstart</dt>
            <dd>
              <p>
                The moment after the user agent stops parsing but before running
                scripts that are designated to execute when parsing finishes.
              </p>
              <p>
                For HTML documents, this occurs after updating the <a
                  href="http://dev.w3.org/html5/spec/dom.html#current-document-readiness">current
                  document readiness</a> to "interactive" (see <a
                href="http://dev.w3.org/html5/spec/the-end.html#the-end">the
                specified behavior for the end of parsing</a>), that is,
                after the <em>domInteractive</em> timing.
              </p>
            </dd>
            <dt>manual</dt>
            <dd>
              A moment infinitely distant in the future. That is, animation will
              not begin until <code>unpause</code> is called on the timeline.
            </dd>
          </dl>
          <p>
            For the <var>onload</var> and <var>onstart</var> values, it is not
            sufficient to simply the record the appropriate time and seek the
            animations accordingly at a later moment.
            Rather, the timeline must be actually unpaused at the appropriate
            moment such that scripts that execute during page loading (for
            example, in response to the load event) can make assumptions about
            the pause state of the timeline.
          </p>
          <p>
            Any call to <code>pause</code> or <code>unpause</code> on the
            timeline disables the automatic unpause behavior defined by the
            <code>timelineStart</code> property on the document.
            It is as if the <code>timelineStart</code> property were set to
            <var>manual</var>.
          </p>
          <div class="note">
            <p>
              The ability for script to override the <code>timelineStart</code>
              property by calling <code>pause</code> to indefinitely postpone
              the start of animation is necessary for backwards compatibility
              with SVG.
            </p>
            <p>
              This override behavior applies even if the timeline has already
              been unpaused since changing the <code>timelineStart</code>
              property could return the timeline to a state where the automatic
              unpause behavior would otherwise apply.
            </p>
          </div>
        </section>
        <section>
          <h4>Changing the timeline start</h4>
          <p>
            The <code>timelineStart</code> property may be changed at any time.
            The result of changing this property is as follows:
          </p>
          <ol>
            <li>
              If <code>pause</code> or <code>unpause</code> has been called on
              the timeline, return immediately.
            </li>
            <li>
              Let <var>autostart</var> be the moment at which the timeline would
              be unpaused corresponding to the new value of
              <code>timelineStart</code> as defined in <a
              href="#start-of-the-timeline" class="sectionRef"></a>.
            </li>
            <li>
              Let <var>now</var> be the <var>parent iteration time</var>.
            </li>
            <li>
              If <var>autostart</var> &le; <var>now</var>, set the
              <var>pause state</var> to false.
            </li>
            <li>
              If <var>autostart</var> &gt; <var>now</var>, set the <var>start
              pause state</var> to true.
            </li>
            <li>
              If the pause state is newly true seek the timeline to
              <var>autostart</var> - <var>now</var>.
            </li>
            <li>
              If the pause state is newly false seek the timeline to 0.
            </li>
          </ol>
        </section>
        <section>
          <h4>Extensions to the <code>Document</code> interface</h4>
          <p>
            To provide access to the document timeline the following extensions
            to the <code>Document</code> interface are required.
          </p>
          <dl title="partial interface Document" class="idl">
            <dt>readonly attribute ParGroup animationTimeline</dt>
            <dd>
              The animation group corresponding to the root of the document.
              This group exhibits the special behavior described for the root
              animation group in <a href="#the-document-timeline"
              class="sectionRef"></a>.
            </dd>
            <dt>attribute AnimStartType timelineStart</dt>
            <dd>
              Sets the time at which the animation timeline will begin animating
              unless it is overridden by script as defined in <a
              href="#start-of-the-timeline" class="sectionRef"></a>.
              Changes to this property are defined in <a
              href="#changing-the-timeline-start" class="sectionRef"></a>.
              Initialized to "onload".
            </dd>
          </dl>
        </section>
        <section>
          <h3>Timeline of document resources</h3>
          <p>
            Documents may include external animated resources, for example, via
            the <code>&lt;object&gt;</code> or <code>&lt;use&gt;</code>
            elements. These external resources will often have their own
            Document object and their own timeline. In order to synchronize
            these timelines the same approaches can be applied as with described
            under <a href="#synchronizing-with-media" class="sectionRef"></a>.
          </p>
        </section>
      </section>
      <section>
        <h3>The <code>AnimationGroup</code> interface</h3>
        <p>
          Represents a list of timed items.
        </p>
        <p>
          The <code>AnimationGroup</code> interface supports indexed
          properties with indices in the range 0 &le; <var>index</var> &lt;
          <code>group.size</code>. 
        </p>
        <dl title="interface AnimationGroup : TimedItem"
          class="idl">
          <dt>readonly attribute unsigned long length</dt>
          <dd>
            The number of timed items in the group.
          </dd>
          <dt>readonly attribute AnimationGroupTemplate? template</dt>
          <dd>
            <p>
              For linked animation groups (see <a href="#animation-templates"
              class="sectionRef"></a>), the <a>AnimationGroupTemplate</a> object
              from which this object derives its values.
              For animations that are not linked to a template, this property is
              <code>null</code>.
            </p>
            <p class="feedbackWanted">
              Make this writeable?
            </p>
          </dd>
          <dt>void clear ()</dt>
          <dd>
            <p>
              Removes all child timed items from the group.
            </p>
            <p>
              Exceptions:
            </p>
            <dl class="exceptions">
              <dt>DOMException of type
                  <code>NoModificationAllowedError</code></dt>
              <dd>
                Raised if this group is a linked group, that is, if
                <code>template</code> is not <code>null</code>
                (see <a href="#animation-templates" class="sectionRef"></a>).
              </dd>
            </dl>
          </dd>
          <dt>getter TimedItem? (unsigned long index)</dt>
          <dd>
            <p>
              Returns the item at <code>index</code>.
              If <code>index</code> is greater than or equal to
              <code>length</code> returns <code>null</code>.
            </p>
          </dd>
          <dt>setter TimedItem (unsigned long index, TimedItem newItem)</dt>
          <dd>
            <p>
              Replaces the item at <code>index</code> with <code>newItem</code>
              by calling <code>splice(index, 1, newItem)</code>.
            </p>
            <p>
              No attempt is made to check if the item at <code>index</code> is
              already <code>newItem</code>. In such a case, <code>newItem</code>
              will be removed from this group and re-added as per the usual
              operation of <code>slice</code>.
            </p>
            <p>
              Returns <code>newItem</code>.
            </p>
            <p>
              Exceptions:
            </p>
            <dl class="exceptions">
              <dt>DOMException of type <code>HierarchyRequestError</code></dt>
              <dd>
                Raised if <code>newItem</code> is the timeline for a document
                (see <a href="#the-document-timeline" class="sectionRef"></a>).
              </dd>
              <dt>DOMException of type <code>IndexSizeError</code></dt>
              <dd>
                Raised if <code>index</code> is outside of the range 0 &le;
                <var>index</var> &lt; <code>group.length</code>.
              </dd>
              <dt>DOMException of type
                  <code>NoModificationAllowedError</code></dt>
              <dd>
                Raised if this group is a linked group, that is, if
                <code>template</code> is not <code>null</code>
                (see <a href="#animation-templates" class="sectionRef"></a>).
              </dd>
            </dl>
            <div class="note">
              <p>
                Whilst <code>splice</code> allows negative indices,
                WebIDL requires index property setters to take an index of type
                <code>unsigned long</code> and hence <code>index</code> is
                restricted to the range 0 &le; <var>index</var> &lt;
                <code>group.length</code>.
              </p>
            </div>
          </dd>
          <dt>sequence&lt;TimedItem&gt; add (TimedItem newItem,
                                             TimedItem... otherItems)</dt>
          <dd>
            <p>
              Add <code>newItem</code> and each <code>otherItems</code> as the
              last item(s) in the group by calling <code>splice(group.length, 0,
              newItem, otherItem1, ... otherItemN)</code>.
            </p>
            <p>
              Returns a sequence containing the added items:
              <code>[newItem, otherItem1, ... otherItemN]</code>.
            </p>
            <p>
              Exceptions:
            </p>
            <dl class="exceptions">
              <dt>DOMException of type <code>HierarchyRequestError</code></dt>
              <dd>
                Raised if any of the items to add is the timeline for a document
                (see <a href="#the-document-timeline" class="sectionRef"></a>).
                If this exception is thrown none of the <code>newItem</code>
                objects will be added to the group.
              </dd>
              <dt>DOMException of type
                  <code>NoModificationAllowedError</code></dt>
              <dd>
                Raised if this group is a linked group, that is, if
                <code>template</code> is not <code>null</code>
                (see <a href="#animation-templates" class="sectionRef"></a>).
              </dd>
            </dl>
          </dd>
          <dt>sequence&lt;TimedItem&gt; remove (
                long index, optional unsigned long count = 1)</dt>
          <dd>
            <p>
              Removes the item(s) at <code>index</code> by calling
              <code>splice(index, count)</code>.
            </p>
            <p>
              Returns the removed items.
            </p>
            <p>
              Exceptions:
            </p>
            <dl class="exceptions">
              <dt>DOMException of type
                  <code>NoModificationAllowedError</code></dt>
              <dd>
                Raised if this group is a linked group, that is, if
                <code>template</code> is not <code>null</code>
                (see <a href="#animation-templates" class="sectionRef"></a>).
              </dd>
            </dl>
          </dd>
          <dt>
            sequence&lt;TimedItem&gt; splice ()
          </dt>
          <dd>
            <p>
              Modifies the list of children of this group by first removing
              <code>deleteCount</code> items from <code>start</code> followed by
              adding <code>newItems</code> at the same point.
            </p>
            <p>
              The operation of slice is based on <a
                href="http://www.ecma-international.org/publications/files/ECMA-ST-ARCH/ECMA-262%205th%20edition%20December%202009.pdf#page=140">ECMAScript 5's
                Array.prototype.splice</a>.
            </p>
            <p>
              Returns a sequence of the items removed from group during the
              removal step (regardless of whether these items were re-added
              during the addition step).
            </p>
            <dl class="parameters">
              <dt>long start</dt>
              <dd>
                The index at which items should be removed and inserted.
                Negative indices represent an offset from the end of the list of
                items.
                This value is clamped to the range [-<code>length</code>,
                <code>length</code>].
              </dd>
              <dt>unsigned long deleteCount</dt>
              <dd>
                The number of items to remove from the group beginning at
                <code>start</code>.
                Negative values are clamped to zero, and all other values are
                clamped such that
                0 &lt; <code>start</code> + <code>deleteCount</code> &le;
                length.
              </dd>
              <dt>sequence&lt;TimedItem&gt; newItems</dt>
              <dd>
                The items to be added at <code>start</code>.
                Each item, if it already has a parent group (including this
                group), is first removed from its parent group before being
                added to this group.
              </dd>
            </dl>
            <p>
              Exceptions:
            </p>
            <dl class="exceptions">
              <dt>DOMException of type <code>HierarchyRequestError</code></dt>
              <dd>
                Raised if any of the items in <code>newItem</code> is the
                timeline for a document (see <a href="#the-document-timeline"
                class="sectionRef"></a>).
              </dd>
              <dt>DOMException of type
                  <code>NoModificationAllowedError</code></dt>
              <dd>
                Raised if this group is a linked group, that is, if
                <code>template</code> is not <code>null</code>
                (see <a href="#animation-templates" class="sectionRef"></a>).
              </dd>
            </dl>
          </dd>
          <dt>
            sequence&lt;TimedItem&gt; splice (long start,
              unsigned long deleteCount, TimedItem... newItem)
          </dt>
          <dd>
            An overload of <code>splice</code> to take a variadic list of items
            rather than requiring a sequence.
            The operation is identical to <code>splice(unsigned long start,
            unsigned long deleteCount, sequence&lt;TimedItem&gt;
            newItems)</code>.
          </dd>
          <dt>long indexOf (TimedItem item)</dt>
          <dd>
            Returns the index of <code>item</code> within the group.
            If <code>item</code> is not in the group, returns <code>-1</code>.
          </dd>
          <dt>AnimationGroupTemplate? unlink()</dt>
          <dd>
            <p class="todo">
              Makes this group independent of the template with which it is
              associated if any.
              See <a href="#animation-templates" class="sectionRef"></a>.
              Does this recurse through children and unlink them too?
            </p>
            <p>
              After this method returns, the <code>template</code>
              property will be <code>null</code>.
            </p>
            <p>
              Returns the previous value of <code>template</code>.
            </p>
          </dd>
          <dt>sequence&lt;Animation&gt; getActiveAnimations ()</dt>
          <dd>
            Returns all descendent <code>Animation</code> objects
            that are <a>in effect</a>.
            The returned sequence is a snapshot (i.e. not live) representing the
            state of animations that corresponds to the time returned by the
            <code>iterationTime</code> property of this
            <code>AnimationGroup</code> object when this method was
            called.
          </dd>
          <dt>sequence&lt;Animation&gt; getAnimationsForElement (Element
          elem)</dt>
          <dd>
            Returns all descendent <code>Animation</code> objects
            whose <code>targetElement</code> is <code>elem</code>.
            As with <code>getActiveAnimations</code>, the returned sequence is
            a snapshot (i.e. not live) representing the state of animation
            when this method was called.
          </dd>
        </dl>
      </section>
      <section>
        <h3>Parallel animation groups</h3>
        <p>
          Parallel animation group run their children such they potentially play
          simultaneously.
          The start time of each child depends on its own <code>startTime</code>
          property.
        </p>
        <section>
          <h4>The intrinsic duration of a parallel animation group</h4>
          <p>
            The intrinsic duration of a parallel animation group is
            the maximum of the <code>endTime</code> properties of each
            child <code>TimedItem</code>.
          </p>
          <p>
            If the group has no children then the intrinsic duration is zero.
          </p>
        </section>
        <section>
          <h4>The <code>ParGroup</code> interface</h4>
          <p>
            Parallel animation groups are represented by <code>ParGroup</code>
            objects.
          </p>
          <dl title="interface ParGroup : AnimationGroup" class="idl">
            <dt>Constructor ()</dt>
            <dd>
              <dl class="parameters">
                <dt>sequence&lt;TimedItem&gt;? children</dt>
                <dd>
                  <p>
                    A sequence of timed items to add as children of this group.
                  </p>
                  <p>
                    These children are appended in sequence using the semantics
                    as the <code><a>AnimationGroup</a>.add</code> method.
                  </p>
                </dd>
                <dt>optional (double or TimingDictionary or Timing)? timing</dt>
                <dd>
                  <p>
                    The timing properties of the new animation group.
                  </p>
                  <p>
                    If this parameter is a <code>double</code>, then it
                    specifies the duration of a single iteration of the
                    animation group, that is, the <a>iteration duration</a>, in
                    seconds.
                    In this case, the <code>timing</code> property of the new
                    <a>ParGroup</a> object is set to a new <a>Timing</a>
                    object with all properties set to their default values as
                    specified on the <a>TimingDictionary</a> dictionary
                    definition except the <code>duration</code> property which
                    is set to the value specified here.
                  </p>
                  <p>
                    Similarly, if this parameter is <code>null</code>, the
                    <code>timing</code> property is set to a new <a>Timing</a>
                    object with the <code>duration</code> property set to
                    <code>null</code>.
                  </p>
                  <p class="issue">
                    The constructor for <a>Animation</a> should probably allow
                    this parameter to be <code>null</code> as well.
                  </p>
                  <p>
                    If this parameter is of type <a>TimingDictionary</a>, then
                    the passed-in dictionary is used to construct a new
                    <a>Timing</a> object which is then assigned to the
                    <code>timing</code> property of the new <a>ParGroup</a>
                    object.
                  </p>
                  <p>
                    If this parameter is a <a>Timing</a> object, it is directly
                    assigned to the <code>timing</code> property of the new
                    <a>ParGroup</a> object.
                    It is <em>not</em> copied.
                    In this way <a>Timing</a> objects can be shared between
                    <a>TimedItem</a> objects.
                  </p>
                  <p>
                    Finally, if this parameter is not specified, it is as if
                    a value of <code>null</code> were specified.
                  </p>
                </dd>
                <dt>optional AnimationGroup? parentGroup</dt>
                <dd>
                  The group to which the newly created animation group should be
                  appended as a child.
                  If not specified, the animation will be appended to the
                  document timeline.
                  If <code>null</code>, the animation group will not be appended
                  to any group.
                </dd>
                <dt>optional double startTime</dt>
                <dd>
                  <p>
                    The <a>start time</a> of the newly generated animation group
                    expressed in seconds in the <a>iteration time space</a> of
                    the <a>AnimationGroup</a> to which it is (or will be)
                    appended.
                  </p>
                  <p>
                    If not specified, the current <a>iteration time</a> of the
                    <a>AnimationGroup</a> to which the animation is appended (as
                    determined by the <code>parentGroup</code> parameter) will
                    be used.
                    If <code>parentGroup</code> is <code>null</code>, and
                    the <code>startTime</code> is not specified, a time of zero
                    will be used.
                  </p>
                </dd>
              </dl>
            </dd>
          </dl>
        </section>
      </section>
      <section>
        <h3>Sequence animation groups</h3>
        <p>
          Sequence animation groups run their children in turn
          following their order in the group.
          This ordering is achieved by adjusting the <var>start time</var> of
          each child in the group.
        </p>
        <div class="informative">
          <p>
            Since the <var>start delay</var> is added to the <var>start
            time</var>, it can be used to adjust the timing of the <a>animation
            interval</a> relative to calculated <var>start time</var> as shown
            in the following diagram.
          </p>
          <div class="figure">
            <img src="img/sequence-groups-and-start-delays.svg" width="600">
          </div>
          <p>
            A negative <var>start delay</var> can be used to cause the
            <a>animation interval</a> of two children to overlap.
            Note that the <var>start delay</var> affects the <var>start
            time</var> of subsequent children in the group.
          </p>
        </div>
        <section>
          <h4>The start time of children of a sequence animation group</h4>
          <p>
            The start time for the children of a sequence animation group
            is calculated according to the following procedure:
          </p>
          <ol>
            <li>Let the <var>accumulated start time</var> be zero.
            <li>
              Iterate over each child in the group beginning with the first item
              in the group and proceeding to the last.
              For each child perform the following steps:
              <ol>
                <li>
                  Let <var>child</var> be the current child.
                </li>
                <li>
                  Let <code><var>child</var>.startTime</code> be
                  <var>accumulated start time</var>.
                </li>
                <li>
                  Let <var>accumulated start time</var> be
                  <code><var>child</var>.endTime</code>.
                </li>
              </ol>
            </li>
          </ol>
          <p class="note">
            When <code>animationDuration</code> is positive infinity the
            behavior is defined by IEEE 754-2008.
            As a result, if any of the children of a sequence animation group
            has an infinite animation duration, any children that occur
            later in the sequence will not play.
          </p>
        </section>
        <section>
          <h4>The intrinsic duration of a sequence animation group</h4>
          <p>
            The instrinsic duration of a sequence animation group is
            equivalent to the <var>start time</var> of a hypothetical child
            appended to the group's children using the procedure described in <a
            href="#the-start-time-of-children-of-a-sequence-animation-group"
            class="sectionRef"></a>.
          </p>
        </section>
        <section>
          <h4>The <code>SeqGroup</code> interface</h4>
          <p>
            Sequence animation groups are represented by <code>SeqGroup</code>
            objects.
          </p>
          <dl title="interface SeqGroup : AnimationGroup"
            class="idl">
            <dt>
            Constructor (sequence&lt;TimedItem&gt;? children,
                optional (double or TimingDictionary or Timing)? timing,
                optional AnimationGroup? parentGroup,
                optional double startTime)
            </dt>
            <dd>
              The meaning and handling of each of the parameters in this
              constructor is identical to the constructor for
              <a>ParGroup</a>.
            </dd>
          </dl>
        </section>
      </section>
    </section>

    <section>
      <h2>Animation values</h2>
      <div class="informative">
        <p>
          The Web Animations <em>animation model</em> takes the <a>time
          fraction</a>s produced by the <em>timing model</em> for a given
          <a>Animation</a> and applies it as the input to the <em>animation
          function</em> defined for the <a>Animation</a> object.
          The output of each <em>animation function</em> is then combined using
          a global animation stack before being applied to the target property
          (see <a href="#combining-animations" class="sectionRef"></a>).
        </p>
        <p>
          The entry-point to the <em>animation model</em> is the
          <a>AnimationFunction</a> or <a>CustomAnimationFunction</a> object
          associated with each <a>Animation</a>.
          These objects describe how animation values should be calculated for
          the <a>Animation</a> for any given time.
          <a>AnimationFunction</a> serves as an abstract interface of which
          several concrete subclasses are provided.
        </p>
      </div>
      <section>
        <h3>The <code>AnimationFunction</code> interface</h3>
        <dl title="interface AnimationFunction" class="idl">
          <dt>attribute CompositeOperation operation</dt>
          <dd>
            <p>
              The operation used to composite this animation with the stack, as 
              specified by one of the <a>CompositeOperation</a> enumeration
              values.
            </p>
            <p>
              This value defaults to <code>"replace"</code>
            </p>
          </dd>
          <dt>attribute CompositeOperation accumulateOperation</dt>
          <dd>
            <p>
              The operation used to composite each iteration of this animation
              with the result of compositing the previous animation, as
              specified by one of the <a>CompositeOperation</a> constants
              defined in this interface.
            </p>
            <p>
              This value defaults to <code>"replace"</code>.
            </p>
          </dd>
          <dt>any sample (double? timeFraction, double currentIteration,
                          Element? target, any underlyingValue)</dt>
          <dd>
            <div class="todo">
              <p>
                Define this here?<br>
                Potentially this should be an interface that script could
                provide its own object for.
              </p>
              <p>
                Implementations of the function would be expected to produce the
                same result given the same parameters so the implementation
                could cache the result and not call the function when the
                parameters were the same. 
              </p>
              <p>
                <code>timeFraction</code> would be a number typically in the
                range [0.0, 1.0].
                <code>null</code> values indicate the function should no longer
                affect the target.
              </p>
              <p>
                Pass in <code>isSeeking</code> as a flag?
                Tempting to pass in <code>aPreviousTimeFraction</code> but
                I think functions that need that can track it themselves?
                Although that requires a new instance of the function for each
                target.
              </p>
            </div>
          </dd>
          <dt>AnimationFunction clone ()</dt>
          <dd>
            <p>
              Creates and returns a new object of the same type as this object's
              most-derived interface such that it will produce the same output
              as this object.
            </p>
            <p class="todo">
              We either need a more rigorous definition here or (probably
              better) a sets of steps on a per-subclass basis.
            </p>
          </dd>
          <dt>static AnimationFunction? createFromProperties ()</dt>
          <dd>
            <p>
              Creates an <a>AnimationFunction</a> representing the passed-in
              collection of properties.
            </p>
            <div class="note">
              <p>
                Note that this method requires handling the passed in parameter
                in a manner not yet supported by Web IDL and hence this method
                is ECMAScript-specific.
              </p>
              <p>
                Since accessing the properties of an ECMAScript user object can
                have side effects, the manner in which these properties is
                accessed is important.
                In light of this consideration the following procedure has the
                following properties:
              </p>
              <ul>
                <li>Every property is read only once.</li>
                <li>Properties are read in a well-defined order.</li>
                <li>Properties corresponding to unsupported target properties or
                    attributes are not read.</li>
              </ul>
            </div>
            <p>
              The interpretation of the passed-in <code>properties</code> object
              can be described in three parts.
            </p>
            <p><strong>Part 1 &ndash; Determine the set of
               animation properties</strong></p>
            <ol>
              <li>Create a list, <var>supported properties</var>, of property
                  names and attribute names that can be animated by the
                  implementation.</li>
              <li>Let <var>animation properties</var> be an empty sequence.</li>
              <li>Iterate through the properties of <code>properties</code>. For
                  each <var>property</var> in <code>properties</code>, if
                  <var>property</var> also exists in <var>supported
                  properties</var> based on a case-sensitive comparison, append
                  <var>property</var> to <var>animation properties</var>.
                  <p class="note">
                    Whilst the iteration order for properties of an ECMAScript
                    object is implementation-dependent, the order here is not
                    significant to the outcome as <var>animation
                    properties</var> will be sorted before being iterated over.
                  </p>
              </li>
            </ol>
            <p><strong>Part 2 &ndash; Create the <a>AnimationFunction</a>
               objects</strong></p>
            <p>
              The <a>AnimationFunction</a> object produced depends on the length
              of <var>animation properties</var> as follows:
            </p>
            <dl class="switch">
              <dt>If <var>animation properties</var> is of zero length,</dt>
              <dd>
                return <code>null</code>.
                <p class="todo">
                  Make <code>Animation.animationFunction</code> nullable since
                  otherwise we won't be able to create an <a>Animation</a>
                  function corresponding to a bit of CSS / SVG syntax that
                  refers to a property that can't be animated in a given
                  implementation (e.g. <code>-moz-xxx</code>).
                </p>
              </dd>
              <dt>If <var>animation properties</var> has only one element,</dt>
              <dd>
                <ol>
                  <li>Let <var>name</var> be the value of the element
                      in <var>animation properties</var>.</li>
                  <li>Let <var>value</var> be the value of
                      <code>properties.<var>name</var></code>.</li>
                  <li>Return a new <a>KeyframeAnimationFunction</a> object
                      according to the steps in part 3 below based on
                      <var>name</var> and <var>value</var>.</li>
                </ol>
              </dd>
              <dt>Otherwise,</dt>
              <dd>
                <ol>
                  <li>Let <var>group</var> be a newly constructed
                      <a>GroupedAnimationFunction</a>.</li>
                  <li>Sort <var>animation properties</var> lexicographically by
                      the Unicode codepoints that define each property
                      name.</li>
                  <li>Iterate through <var>animation properties</var>. For each
                      <var>name</var> in <var>animation properties</var>:
                    <ol>
                      <li>Let <var>value</var> be the value of
                          <code>properties.<var>name</var></code>.</li>
                      <li>Create a new <a>KeyframeAnimationFunction</a>,
                          <var>function</var> object according to the steps in
                          part 3 below based on <var>name</var> and
                          <var>value</var>.</li>
                      <li>Append <var>function</var> to <var>group</var>.
                    </ol>
                  </li>
                  <li>Return <var>group</var>.
                </ol>
              </dd>
            </dl>
            <p><strong>Part 3 &ndash; Create each
               <a>KeyframeAnimationFunction</a> object</strong></p>
            <p>
              Based on a given <var>name</var> and <var>value</var>, a new
              <a>KeyframeAnimationFunction</a> is created depending on the type
              of <var>value</var>.
              In effect, <var>value</var> is treated as having type
              <code>(DOMString or sequence&lt;DOMString&gt; or
              sequence&lt;<a>KeyframeDict</a>&gt;)</code>.
            </p>
            <ol>
              <li>
                Let <var>function</var> be a newly constructed
                <a>KeyframeAnimationFunction</a> object.
              </li>
              <li>
                Set <code><var>function</var>.property</code> to
                <var>name</var>.
              </li>
              <li>Create the key frames based on the type of <var>value</var> as
                follows:
                <dl class="switch">
                  <dt>If <var>value</var> is a <code>DOMString</code>,</dt>
                  <dd>
                    Create a new <a>Keyframe</a> with the <code>value</code>
                    property set to <var>value</var> and <code>offset</code>
                    set to 1.0 and append it to
                    <code><var>function</var>.frames</code>.
                  </dd>
                  <dt>If <var>value</var> is a sequence of
                      <code>DOMString</code>s,</dt>
                  <dd>
                    For each <var>item</var> in <var>value</var>:
                    <ol>
                      <li>
                        Let <var>frame</var> be a new <a>Keyframe</a>
                        object.
                      </li>
                      <li>
                        Set <code><var>frame</var>.value</code> to
                        <var>item</var>.
                      </li>
                      <li>
                        Set <code><var>frame</var>.offset</code> to
                        <code><var>i</var> / (<var>value</var>.length - 1)
                        </code> where <var>i</var> is the zero-based index of
                        <var>item</var> within <var>value</var>.
                      </li>
                      <li>
                        Append <code>frame</code> to
                        <code><var>function</var>.frames</code>.
                      </li>
                    </ol>
                    <p class="todo">
                      This can probably be tightened up significantly after we
                      define constructors for all these things.
                    </p>
                  </dd>
                  <dt>If <var>value</var> is a sequence of
                      <a>KeyframeDict</a> objects,</dt>
                  <dd>
                    For each <var>item</var> in <var>value</var>:
                    <ol>
                      <li>
                        Let <var>frame</var> be the result of calling <code>new
                        <a>Keyframe</a>(<var>item</var>)</code>.
                      </li>
                      <li>
                        Append <code>frame</code> to
                        <code><var>function</var>.frames</code>.
                      </li>
                    </ol>
                    <p class="todo">
                      Define a constructor for <a>Keyframe</a> that takes an
                      <a>KeyframeDict</a>.
                    </p>
                  </dd>
                  <dt>Otherwise,
                  <dd>
                    Throw a <code>TypeError</code> as defined by [[!ECMA-262]].
                  </dd>
                </dl>
              </li>
            </ol>
            <dl class="parameters">
              <dt>object properties</dt>
              <dd>
                An object whose object properties represent the CSS properties
                or element attributes to be animated.
                The values corresponding to these properties are the animation
                values to be applied as described above.
              </dd>
            </dl>
          </dd>
        </dl>
        <p class="todo">
          Need to add exception behavior for this interface and all its
          subclasses for when it is linked to a template.
        </p>
      </section>
      <section>
        <h3>The <code>CompositeOperation</code> enumeration</h3>
        <dl title="enum CompositeOperation" class="idl">
          <dt>replace</dt>
          <dd>
            The animation should replace the value it is composited with.
          </dd>
          <dt>accumulate</dt>
          <dd>
            The animation should add to the value it is composited with.
            The meaning of addition is dependent on the type of animation.
          </dd>
          <dt>merge</dt>
          <dd>
            The animation should merge with the value it is composited with.
            The meaning of merge is dependent on the type of animation.
            The duration of the merge is the calculated animation duration
            of the <code>AnimationTemplate</code> containing this
            <code>AnimationFunction</code>.
          </dd>
        </dl>
      </section>
      <section>
        <h3>The <code>KeyframeAnimationFunction</code> interface</h3>
        <div class="todo">
          <p>
            Need to define convenience ctors here. I think you want to support
            something like this:
          </p>
          <pre class="sh_javascript">
{
  [
    { offset: 0,   height: '200px' },
    { offset: 0.2, height: '300px', timing: 'ease-in' },
    { offset: 1,   height: '400px' },
  ]
}</pre>
          <p>
            If <code>offset</code> is not specified it makes them equidistant?
            That assumes they're in order though.
          </p>
          <p>
            Also, ideally the ctor for <a>GroupedAnimationFunction</a> would
            accept the above input as well as the below.
          </p>
          <pre class="sh_javascript">
{
  [
    { offset: 0, height: '200px' },
    { offset: 1, height: '400px', width: '500px' },
  ]
}</pre>
          <p>
            As a bonus, the ctor for <a>KeyframeAnimationFunction</a> should
            also be nice to support the following arrangement:
          </p>
          <pre class="sh_javascript">
{
  prop: 'height',
  values: [ '200px', '300px', '400px']
}</pre>
        </div>
        <p class="todo">
          Need to define exceptions when this is a read-only object.
        </p>
        <p>
          <dl title="[Constructor] interface KeyframeAnimationFunction
            : AnimationFunction" class="idl">
            <dt>attribute DOMString property</dt>
            <dd>
              The target attribute / property. <code>property</code> is probably
              a reserved word we should avoid though.
            </dd>
            <dt>attribute KeyframeList frames</dt>
            <dd>
              The series of values that make up this function sorted by their
              offset within the iteration duration of the animation.
            </dd>
          </dl>
        </p>
      </section>
      <section>
        <h3>The <code>Keyframe</code> interface</h3>
        <p>
          <dl title="[Constructor] interface Keyframe" class="idl">
            <dt>attribute any value</dt>
            <dd>
              The attribute / property value for the given frame
            </dd>
            <dt>attribute double offset</dt>
            <dd>
              A value between 0 and 1 (inclusive) representing the offset within
              the iteration duration of the animation where this value should
              appear. Ignored if we're using paced timing?<br>
              What happens if you change it? The array returned by the
              <code>AnimationFunction</code> is updated? I guess that's fine
              if it's just an array. Any already-returned arrays wouldn't need
              to be updated.<br>
              What happens if you have two values with the same offset? It would
              be nice if the result was deterministic rather than just left up
              in the air (since the more you leave undefined, the more you let
              the Web define it for you).
            </dd>
            <dt>attribute TimingFunction timingFunction</dt>
            <dd>
              The function to use for this segment. Would a string do here? E.g.
              "ease" or "cubic-bezier(1 0 0.3 1)"? Probably not. It's a little
              too CSS-specific for a start, and we want to allow this to
              potentially be a function pointer.<br>
              Ignored if we're using paced timing
            </dd>
          </dl>
        </p>
      </section>
      <section>
        <h3>The <code>KeyframeList</code> interface</h3>
        <dl title="interface KeyframeList" class="idl">
          <dt>readonly attribute unsigned long length</dt>
          <dd>
            The number of frames in the list.
          </dd>
          <dt>KeyframeList? item(unsigned long index)</dt>
          <dd>
            Returns the frame at <code>index</code> if it exists or null.
          </dd>
          <dt>KeyframeList? add(Keyframe frame)</dt>
          <dd>
            Adds <code>frame</code> to the list such that the list is sorted
            by the offset of the frames. If there's already a frame with the
            same offset? This one comes after?
          </dd>
          <dt>KeyframeList? remove(unsigned long index)</dt>
          <dd>
            Adds <code>frame</code> to the list such that the list is sorted
            by the offset of the frames. If there's already a frame with the
            same offset? This one comes after?
          </dd>
        </dl>
        <p>
          Not sure about the <code>remove</code> method. Do we want:
          <ul>
            <li><code>remove(Keyframe frame)</code>?</li>
            <li><code>removeAtOffset(unsigned long offset)</code>?</li>
            <li><code>itemAtOffset(unsigned long offset)</code>?</li>
          </ul>
        </p>
      </section>
      <section>
        <h3>The <code>PathAnimationFunction</code> interface</h3>
        <dl title="[Constructor] interface PathAnimationFunction
          : AnimationFunction" class="idl">
          <dt>attribute SVGPathSegList segments</dt>
          <dd>
            The list of segments that make up this path.
          </dd>
          <dt>attribute boolean rotate</dt>
          <dd>
            True if objects animating along this path should be rotated
            such that their positive x axis is aligned with the direction of
            movement along the path.
          </dd>
        </dl>
      </section>
      <section>
        <h3>The <code>GroupedAnimationFunction</code> interface</h3>
        <p>
          The <code>GroupedAnimationFunction</code> interface represents a
          set of animation functions that share the same
          <code>AnimationTemplate</code> parent.
        </p>
        <dl title="[Constructor] interface GroupedAnimationFunction
          : AnimationFunction" class="idl">
          <dt>readonly attribute unsigned long length</dt>
          <dd>
            The number of animation functions in the group.
          </dd>
          <dt>AnimationFunction? item(unsigned long index)</dt>
          <dd>
            Returns the function at <code>index</code> if it exists, or null.
          </dd>
          <dt>void add(AnimationFunction func)</dt>
          <dd>
            Adds <code>func</code> to the group.
          </dd>
          <dt>void remove(unsigned long index)</dt>
          <dd>
            Removes the function at <code>index</code> if it exists.
          </dd>
        </dl>
      </section>
      <section>
        <h3>Calculating animation values</h3>
        <section>
          <h4>Calculating the animation value from an iteration value</h4>
          <p>
            If the <a>current iteration</a> is zero, or the 
            <var>accumulateOperation</var> is
            <code>"replace"</code>, then the 
            <var>animation value</var> is simply the iteration value, as
            defined below.
          </p>
          <p>
            When the animation time equals the iteration duration for the 
            first time for an animation, the current 
            <var>animation value</var> should be retained as the
            <var>end value</var> for the animation.
          </p>
          <p class="todo">
            Need to revise this definition since we can't assume the time at
            the end of the first iteration will be visited (we might be
            playing backwards, or have a <var>iteration start</var> greater
            than 1).
          </p>
          <p>
            If the <a>current iteration</a> is not zero and the
            <var>accumulateOperation</var> is
            <code>"accumulate"</code> then the 
            <var>animation value</var> is the <var>end value</var> accumulated
            <a>current iteration</a> times, with the 
            <var>iteration value</var> accumulated on top.
          </p>
          <p>
            If the <a>current iteration</a> is not zero and the
            <var>accumulateOperation</var> is
            <code>"merge"</code> then the
            <var>animation balue</var> is the <var>end value</var> merged
            with the <var>iteration value</var>, with an interpolation
            parameter equal to the current <var>time fraction</var>
          </p>
          <p class="todo">
            Need to review the following algorithms to check they still make
            sense now that the iteration fraction is not necessarily in the
            range [0, 1].
          </p>
        </section>
        <section>              
          <h4>Calculating the iteration value for a 
            <code>KeyframeAnimationFunction</code></h4>
          <p>
            When an <code>AnimationTemplate</code> contains a pointer to a
            <code>KeyframeAnimationFunction</code> <var>keyframes</var>, the
            <var>animation value</var> for that animation at given current time
            <var>t</var> is calculated according to the following steps:
          </p>
          <ol>
            <li>
              Convert <var>t</var> to the <var>time fraction</var> 
              (see <a href="#calculating-the-time-fraction"
              class="sectionRef"></a>).
            </li>
            <li>
              Generate a <var>sorted frame list</var> by sorting the list of
              <code>Keyframe</code> objects contained within the
              <code>KeyframeList</code> object stored in <var>keyframes.frames</var> 
              by their <var>offset</var>.
              If there are no frames in the <var>sorted frame list</var>
              then no animation occurs and the <var>iteration value</var> is
              just the <var>base value</var> of the property being animated.
            </li>
            <li>
              Otherwise, find the <var>after frame</var> by iterating through
              the <var>sorted frame list</var> until the last
              <code>Keyframe</code> with an <var>offset</var>
              larger than the <var>time fraction</var> is
              encountered.
            </li>
            <li>
              If the <var>after frame</var> is the first frame in the
              <var>sorted frame list</var>, then construct a 
              <var>before frame</var> with an <var>offset</var> of 0 and a
              value equal to the <var>base value</var> of the property being
              animated.
            </li>
            <li>
              If the <var>after frame</var> does not exist (i.e. all frames
              have an <var>offset</var> less than the <var>time 
              fraction</var>) then construct an <var>after frame</var> with
              an <var>offset</var> of 1 and a value equal to the
              <var>base value</var> of the property being animated, and
              Set the <var>before frame</var> to the last frame in the 
              <var>sorted frame list</var>.
            </li> 
            <li>
              Otherwise (the <var>after frame</var> exists and is not the
              first frame in the <var>sorted frame list</var>) set the 
              <var>before frame</var> to the frame immediately prior to the
              <var>after frame</var> in the <var>sorted frame list</var>.
            </li>
            <li>
              The <var>local time function</var> is the
              <var>timingFunction</var> of the <var>before frame</var>, if 
              it exists; otherwise the <var>timingFunction</var> of the
              <code>Animation</code> interface's <var>timing</var> attribute.
            </li>
            <li>
              Find the <var>local time fraction</var> by subtracting
              the <var>offset</var> of the <var>before frame</var> from
              the <var>time fraction</var>, then dividing the result
              by the difference between the <var>offset</var> of the
              <var>after frame</var> and the <var>offset</var> of the
              <var>before frame</var>.
            <li>
              Calculate the <var>effective time fraction</var> by applying
              the <var>local time function</var> to the <var>local time
              fraction</var>.
            <li>
              Calculate the <var>animation value</var> by linearly 
              interpolating the values of the <var>before frame</var> and
              <var>after frame</var>, using the 
              <var>effective time fraction</var> as interpolation parameter (see <a href="#linear-interpolation" class="sectionRef"></a>).
            </li>
          </ol>
        </section>
        <section>
          <h4>Calculating the iteration value for a 
            <code>PathAnimationFunction</code></h4>
          <p>
            When an <code>AnimationTemplate</code> contains a pointer to a
            <code>PathAnimationFunction</code> and <var>rotate</var> is set
            to false, the <var>animation value</var> for that animation at
            given current time <var>t</var> is the transform defined by a
            translation equal to the location on the path at <var>t</var>.
          </p>
          <p>
            When <var>rotate</var> is set to true, the
            <var>animation value</var> is the transform defined by the above
            translation followed by a rotation defined by the following
            process:
          </p>
          <ol>
            <li>
              Calculate the <var>normal</var> to the path at <var>t</var> (see <a href="#calculating-the-normal-to-a-path" class="sectionRef"></a>).
            </li>
            <li>
              Determine the <var>normal rotation</var>, which is given by 
              <var>atan2(normal.y, normal.x).
            </li>
            <li>
              The <var>rotation</var> is the transform that rotates by
              the <var>normal rotation</var>.
            </li>
          </ol>
        </section>
        <section>
          <h4>Calculating the iteration value for a 
            <code>GroupedAnimationFunction</code></h4>
          <p>
            When an <code>AnimationTemplate</code> contains a pointer to a
            <code>GroupedAnimationFunction</code>, the <var>animation
            value</var> for that animation at given current time <var>t</var> 
            is calculated by following the procedure outlined in
            <a href="#resolving-animation-stacks" class="sectionRef"></a>, 
            treating the list of <code>AnimationFunction</code> objects 
            contained within the <code>GroupedAnimationFunction</code> as 
            the animation stack and using an initial animation value 
            of 0 for all simple properties and id for transform.
          </p>
        </section>
      </section>
      <section>
        <h3>Custom animation functions</h3>
        <div class="informative">
          <p>
            In some situations the animation functions provided by Web
            Animations may be insufficient.
            For example, the animation functions defined here are only able to
            target certain CSS properties and DOM attributes.
            They are unable, therefore, to modify the <a
            href="#http://www.w3.org/TR/SVG11/struct.html#__svg__SVGSVGElement__currentScale"><code>currentScale</code></a>
            property of an SVG element to smoothly zoom the viewport without
            affecting the document content.
          </p>
          <p>
            In such cases where the provided animation functions do not provided
            needed functionality, an animation function defined by script may be
            used.
            Such animation functions receive a time fraction from the timing
            model and are responsible for producing the animation effect
            corresponding to the specified time.
          </p>
          <p>
            Using an animation function defined in script it is possible to
            animate not only previously un-animatable attributes and properties,
            but potentially anything that is accessible via script, including
            even producing audio or creating vibrations.
          </p>
          <p>
            For example, using an animation function that draws to a <a
            href="http://www.w3.org/TR/html5/the-canvas-element.html#the-canvas-element"><code>canvas</code></a>
            element it is possible to produce a complex animated effect
            featuring patterns that may be difficult to create using CSS or
            SVG.
            Compared to using the <a
            href="http://www.w3.org/TR/animation-timing/">WindowAnimationTiming</a>
            interface, this approach ensures the animation is frame-rate
            independent and can be paused, reversed, eased with timing effects,
            accelerated, synchronized with other animations, and be controlled
            in the same manner as any other Web Animations animation without any
            additional programming.
          </p>
        </div> <!-- informative -->
        <div class="annotation">
          <p>
            I think we want two types of custom animation functions.
            Following is the general-purpose animate-anything kind of function.
            The other type, which is not defined here, is the one that can
            participate in the animation sandwich just like any other.
          </p>
          <p>
            This, second, native-like animation function, would have the
            following features:
          </p>
          <ul>
            <li>Shares the same function signature as
                <code><a>AnimationFunction</a>.sample</code></li>
            <li>Gets passed the underlying value and passes out the animated
                value.</li>
            <li>Has a target property and is sorted against other
                <a>AnimationFunction</a> objects (including platform
                objects)</li>
            <li>Can be added as a child of
                a <a>GroupedAnimationFunction</a>.</li>
          </ul>
          <p>
            That's a bit more difficult since you have to be careful that the
            custom function doesn't do anything naughty while you're in the
            middle of compositing the animation sandwich.
            I think we should postpone this until Web Animations 2.
          </p>
        </div>
        <section>
          <h4>Execution order of custom animation functions</h4>
          <p>
            Custom animation functions allow authors to define animation effects
            using script.
            Such animation functions are not limited to a single CSS property or
            DOM attribute and therefore the steps for assessing their order of
            execution differs from regular animation functions.
          </p>
          <p>
            Custom animation functions are executed after all other
            <a>AnimationFunction</a> objects have completed and applied their
            effects to their targets.
          </p>
          <p class="issue">
            Need to define this more precisely.
            Are styles flushed?
            Presumably they are.
            Can we suspend reflow for the duration of executing the script-based
            animation functions and just do it once afterwards?
          </p>
          <p>
            Within the set of custom animation functions, the order of execution
            is mostly the same as that for other animation functions and is
            defined in <a href="#the-global-animation-stack"
            class="sectionRef"></a>.
            However, custom animation functions may also override this
            ordering through the <code>priority</code> attribute, which, if
            defined, specifies the priority of the functions with lower numbers
            are executed sooner.
          </p>
          <p>
            In deciding which of two <a>CustomAnimationFunction</a> functions,
            <var>A</var> and <var>B</var>, should be executed the following
            rules are applied.
          </p>
          <ol>
            <li>Sort <var>A</var> and <var>B</var> based on their
                <code>priority</code> such that lower priorities are sorted
                first.
                If either does not have a defined <code>priority</code>,
                then treat the priority as being positive infinity for the
                purposes of sorting.</li>
            <li>If <var>A</var> and <var>B</var> have the same priority,
                sort according to the <code>startTime</code>s of the
                <a>TimedItem</a>s with which <var>A</var> and <var>B</var> are
                associated such that earlier start times are sorted first.
            <li>If <var>A</var> and <var>B</var> have the same priority and
                start time, sort by the position of the corresponding
                <a>Animation</a> objects occur within the animation tree (see
                issue below).</li>
          </ol>
          <p>
            Items sorted earlier, are executed first.
          </p>
          <p class="issue">
            That last point is quite wrong. I don't think we've specified
            exactly what script order is in <a
            href="#the-global-animation-stack" class="sectionRef"></a>.
            But I wonder if it makes more sense to effectively enumerate all the
            script-based nodes in the animation tree using some well-defined
            order and use that index.
            Can that be done efficiently?
          </p>
        </section>
        <section>
          <h4>The <code>CustomAnimationFunction</code> callback interface</h4>
          <p>
            Custom animation functions can be defined in script using the
            <a>CustomAnimationFunction</a> interface.
          </p>
          <p class="issue">
            Should this be a dictionary?
            I'd like to make <code>clone</code> optional.
          </p>
          <div title="callback interface CustomAnimationFunction" class="idl">
            <dt>attribute unsigned integer priority</dt>
            <dd>
              The order in which this animation function will be executed in
              relation to other custom animation functions such that items with
              a lower priority are executed earlier as defined in <a
              href="#execution-order-of-custom-animation-functions"
              class="sectionRef"></a>.
            </dd>
            <dt>void sample ()</dt>
            <dd>
              The callback used to produce the animation effect corresponding to
              the sample time determined by the timing model.
              <dl class="parameters">
                <dt>double? timeFraction</dt>
                <dd>
                  The distance within a single iteration of the animation effect
                  of the current sample.
                  When this is <code>null</code>, the callback object SHOULD
                  remove the animation effect.
                </dd>
                <dt>double currentIteration</dt>
                <dd>
                  The current iteration index beginning with zero for the first
                  iteration.
                </dd>
                <dt>Element? target</dt>
                <dd>
                  The element to which the effect should be applied if any.
                  When this method is called as a result of this object being
                  associated with an <a>Animation</a> object, it will be
                  <code><a>Animation</a>.targetElement</code>
                </dd>
              </dl>
            </dd>
            <dt>CustomAnimationFunction clone ()</dt>
            <dd>
              Creates an independent copy of this object.
            </dd>
          </div>
          <p class="issue">
            Do we need to pass in the <a>TimedItem</a> as well?
            If possible I'd prefer not to but it may necessary for some types of
            effect.
            Might be an additional parameter to add later if it proves
            necessary?
          </p>
          <p class="issue">
            I think we will also need to pass the previous time fraction.
            Animations will often use this to check if they are paused, playing
            in reverse etc.
            They can track this themselves but then you need a separate object
            everywhere you use it.
          </p>
        </section>
      </section>
    </section>

    <section>
      <h2>Primitive animation operations</h2>
      <section>
        <h3>Linear interpolation</h3>
        <section>
          <h4>Linear interpolation of paths</h4>
          <p class="todo">Write me</p>
        </section>
        <section>
          <h4>Linear interpolation of transforms</h4>
          <p class="todo">Write me</p>        
        </section>
        <section>
          <h4>Linear interpolation of primitive values</h4>
          <p class="todo">Write me</p>
        </section>
      </section>
      <section>
        <h3>Calculating the normal to a path</h3>
        <p class="todo">Write me</p>
      </section>
    </section>
    <section>
      <h2>Combining animations</h2>
      <section>
        <h3>The Global Animation Stack</h3>
        <p>
          When multiple <a>in effect</a> animations target the same element, the
          animations are ordered into a stack which resolves how those 
          animations combine.
          This stack is sorted by animation <var>start time</var>.
          Where multiple animations have the same start time, those animations
          are sorted in document order (for animations from the DOM) and script
          order (for animations from the API). Script animations are always
          sorted after DOM animations.
        </p>
        <p>
          Other operations also generate animation stacks - for example, 
          grouping multiple animations using a 
          <code>GroupedAnimationFunction</code>.
        </p>
        <p>
          An animation stack may be thought of as a single stack with all
          animations sorted into it, or a stack per animating element, as
          animations on one element cannot effect the course of animations on 
          another element.
        </p>
        <p class="note">
          The start time of an animation refers to the time when the animation
          is specified to begin as recorded in the
          <code>TimedItem.startTime</code> property, that is, before applying
          any <var>start delay</var>.
        </p>
        <p class="note">
          The stacking order of animations is independent of the
          current play direction of individual animations and animation
          groups.
        </p>
      </section>
      <section>
        <h3>Resolving Animation Stacks</h3>
        <p>
          In order to resolve an animation stack, an initial animation
          value is required for each element and property animated by the
          stack.
          To calculate a current animation value for elements and properties
          from an animation stack, an animation value is generated for each
          animation in the stack 
          (see <a href="#calculating-animation-values" class="sectionRef"></a>).
          The cumulative animation result for each element and property is first
          initialised to the relevant initial animation value.
          Starting at the bottom of the stack (i.e. earliest start time) and
          working up, as animation results are encountered for an element
          and property, these are merged into the cumulative animation result
          using the animation combinator stored in the 
          <code>AnimationFunction</code> that generated the result.
          Once all animation results in the stack are processed, the resulting
          cumulative animation values are the current animation values for
          each property of each element that is animated.
        </p>
      </section>
      <section>
        <h3>Animation combinators</h3>
        <p>
          When an animation applies to a target and property that animations
          earlier in the animation stack have already applied to, the
          cumulative animation result from the stack is composited with the new
          animation to produce a new cumulative animation result.
          The possible combinators are defined by the <a>CompositeOperation</a>
          enumeration.
        </p>
        <section>
          <h4>The REPLACE combinator</h4>
          <p>
            When an animation <code>a</code> is composited over a cumulative
            animation result <code>c</code> using the REPLACE combinator, the
            new cumulative animation result is always <code>a</code>.
          </p>
        </section>
        <section>
          <h4>The ACCUMULATE combinator</h4>
          <p>
            When a path animation <code>a</code> is composited over a
            cumulative animation result <code>c</code> using the ACCUMULATE
            combinator, the effective transform of <code>a</code> is calculated.
            This transform is then post-multiplied to the cumulative animation
            result to generate a new cumulative animation result.
          </p>
          <p>
            When a transform animation <code>a</code> is composited over a
            cumulative animation result <code>c</code> using the ACCUMULATE
            combinator, <code>a</code> is post-multiplied to the cumulative
            animation result to generate a new cumulative animation result.
          </p>
          <p>
            When a simple animation (i.e. an animation which is not a path
            animation nor a transform animation) <code>a</code> is composited
            over a cumulative animation result <code>c</code> using the
            ACCUMULATE combinator, the new cumulative animation result is the
            sum of <code>a</code> and <code>c</code>, clipped if necessary to
            the appropriate domain.
          </p>
        </section>
        <section>
          <h4>The MERGE combinator</h4>
          <p>
            All MERGE operators are governed by an interpolation parameter
            <code>p</code> that is calculated as the ratio of
            <code>(currentTime - parent.startTime)
            / parent.animationDuration</code>, where <code>parent</code> is the
            <code>AnimationTemplate</code> which references the
            <code>AnimationFunction</code> that is being composited.
          </p>
          <p>
            When a path animation <code>a</code> is composited over a
            cumulative animation result <code>c</code> using the MERGE
            combinator, the effective transform of <code>a</code> is
            calculated.
            This transform is then interpolated with <code>c</code> using the
            rules provided in [[!CSS3-2D-TRANSFORMS]] to provide the new
            cumulative animation result.
          </p>
          <p>
            When a transform animation <code>a</code> is composited over a
            cumulative animation result <code>c</code> using the MERGE
            combinator, <code>a</code> is interpolated with <code>c</code>
            using the rules provide in [[!CSS3-2D-TRANSFORMS]] to provide the 
            new cumulative animation result.
          </p>
          <p>
            When a simple animation <code>a</code> is composited over a
            cumulative animation result <code>c</code> using the MERGE
            combinator, the new cumulative animation result is calculated as
            the weighted sum of <code>a</code> and <code>c</code>, with weights
            of <code>(1-p)</code> and <code>p</code> respectively.
          </p>
        </section>
      </section>
      <section>
        <h3>Current values, animation values, and the override stylesheet</h3>
        <section>
          <h4>Current values</h4>
          <p>
            The <var>current value</var> of a given property and object is the
            value generated for that property by computing a current style for
            that object without taking the override stylesheet into account.
          </p>
        </section>
        <section>
          <h4>The override stylesheet</h4>
          <p>
            The override stylesheet contains output animation values and
            acts with a higher priority than all other stylesheets. However,
            !important rules from all other stylesheets act with a higher priority
            than the override stylesheet.

            The override stylesheet is regenerated for each timepoint in a
            document using the process described below.
          </p>
        </section>
        <section>
          <h4>Animation values</h4>
          <p class="todo">
            We already have a section with the heading "animation values".
            Ideally they should be unique so they're easy to target by named
            anchor.
          </p>
          <p>
            Animation values for all animated properties are generated at
            each time point according to the following process, then inserted
            into the override stylesheet.
          </p>
          <ol>
            <li>
              A global animation stack is generated as described in 
              <a href="#the-global-animation-stack" class="sectionRef"></a>.
            </li>
            <li>
              An initial animation value is generated by taking the current
              style for each object (ignoring the override stylesheet) and
              extracting a value for each animated property.
            </li>
            <li>
              The global animation stack is resolved using the initial animation
              value and the process in 
              <a class="sectionRef" href="#resolving-animation-stacks"></a>.
            </li>
            <li>
              The current animation values generated by this process are inserted
              into the override stylesheet.
            </li>
            <p class="todo">
              Do we need to work out how to use the override stylesheet for
              elements that don't have an id but are targetted for animations?
            </p>
          </ol>
        </section>
      </section>
    </section>

    <section>
      <h2>Animation templates</h2>
      <div class="informative">
      <p>
        It is sometimes necessary to apply the same animation effect to a series
        of targets.
        Animation templates provide a means for the same set of animation
        properties to be applied repeatedly to a number of targets
        whilst maintaining a link such that changes to the template are
        reflected at each place where the template is applied.
      </p>
      <p>
        In concrete terms, an <a>AnimationTemplate</a> object is used to create
        multiple <a>Animation</a> objects each of which maintains a link back to
        the template via its <code>template</code> property.
        Such <a>Animation</a> objects are said to be <dfn>linked</dfn> to
        a template.
      </p>
      <p>
        The timing and animation parameters of <a>linked</a> animations cannot
        be modified directly.
        Rather, changes are made to the template which is then echoed to all
        animations linked to the same template.
        In order to modify the timing and animation parameters of
        a <a>linked</a> animation directly, it must first be unlinked using the
        <code>unlink</code> method.
      </p>
      <p>
        Note that run-time properties of a <a>linked</a> animation such as its
        <var>start time</var> and <var>time drift</var> can still be modified.
        Only those properties attached to the <code>timing</code> and
        <code>animationFunction</code> properties of a <a>linked</a>
        <a>Animation</a> object are read-only.
      </p>
      <p>
        Unlinked animations can be linked to a template by:
      </p>
      <ul>
        <li>assigning the <var>template</var> property to an
        <a>AnimationTemplate</a> <span class="todo">(Is this right? Are we going
        to do this?)</span>, or</li>
        <li>calling <code>templatize</code> to create a new
        <a>AnimationTemplate</a> with properties set to reflect the current
        state of the <a>Animation</a> object on which it is called.</li>
      </ul>
      <p class="todo">
        Provide some javascript sample here demonstrating?
      </p>
      </div> <!-- informative -->
      <section>
        <h3>The <code>AnimationTemplate</code> interface</h3>
        <p>
          <dl title="[Constructor] interface AnimationTemplate : TimedTemplate"
            class="idl">
            <dt>attribute (AnimationFunction or CustomAnimationFunction)
            animationFunction</dt> <dd>
              The animation function to apply.
            </dd>
          </dl>
        </p>
      </section>
      <section>
        <h3>The <code>TimedTemplate</code> interface</h3>
        <p>
          Both the timing of an <code>AnimationTemplate</code> and the methods
          for creating an <code>Animation</code> from an
          <code>AnimationTemplate</code> are specified on the
          <code>TimedTemplate</code> since this behavior is shared with
          animation groups (see <a href="#group-templates"
          class="sectionRef"></a>).
        </p>
        <p class="todo">
          Should we allow live lists to be passed in? i.e. selectors etc.?
        </p>
        <dl title="interface TimedTemplate" class="idl">
          <dt>attribute Timing timing</dt>
          <dd>
            The timing parameters to use for generated timed items.
          </dd>
          <dt>TimedItem animate ()</dt>
          <dd>
            <p>
              Creates an independent <code>TimedItem</code> and appends it
              to <code>element.ownerDocument.animationTimeline</code>.
            </p>
            <p>
              This allows the following sort of usage:
            </p>
            <pre class="example sh_javascript">
              anim.animate(document.getElementById("a"));
            </pre>
            <p>
              The specific steps for instantiating a
              <code>TimedTemplate</code> depends on its concrete type and is
              described in <a href="#instantiating-an-animationtemplate"
              class="sectionRef"></a> and <a
              href="#instantiating-an-animationgrouptemplate"
              class="sectionRef"></a>.
            </p>
            <dl class="parameters">
              <dt>Element target</dt>
              <dd>
                The <code>Element</code> to be targetted.
              </dd>
              <dt>optional double startTime</dt>
              <dd>
                <p>
                  The start time for the generated animations
                  expressed in seconds in the iteration time space of the
                  <code>AnimationGroup</code> to which it is
                  appended (see <a href="#time-spaces" class="sectionRef"></a>).
                </p>
                <p>
                  If this parameter is not specified it will default to the
                  current iteration time of the
                  <code>AnimationGroup</code> to which it is
                  appended if it is not <code>null</code>, otherwise it will
                  default to zero.
                </p>
              </dd>
            </dl>
          </dd>
          <dt>sequence&lt;TimedItem&gt; animate ()</dt>
          <dd>
            <p>
              Creates a series of independent <code>TimedItem</code>
              objects, one for each element in <code>target</code>.
              As with <code>animate(Element target, double startTime)</code>
              each such <code>TimedItem</code> object is appended
              to <code>element.ownerDocument.animationTimeline</code>.
            </p>
            <p>
              This allows the following sort of usage:
            </p>
            <pre class="example sh_javascript">
  anim.animate([document.getElementById("a"), document.getElementById("b")]);
  anim.animate(document.querySelectorAll("div.warning"));
  anim.animate(document.getElementsByTagName("button"));
  anim.animate(document.getElementById("group").childNodes);
            </pre>
            <p>
              The specific steps for instantiating a
              <code>TimedTemplate</code> depends on its concrete type and is
              described in <a href="#instantiating-an-animationtemplate"
              class="sectionRef"></a> and <a
              href="#instantiating-an-animationgrouptemplate"
              class="sectionRef"></a>.
            </p>
            <dl class="parameters">
              <dt>sequence&lt;Node&gt; targets</dt>
              <dd>
                An sequence of <code>Node</code>s to be animated.
                Any nodes in the sequence that are not of type
                <code>ELEMENT_NODE</code> will be ignored.
              </dd>
              <dt>optional double startTime</dt>
              <dd>
                As with <code>animate(Element target, optional double
                  startTime)</code>.
              </dd>
            </dl>
          </dd>
          <dt>TimedItem animateWithParent ()</dt>
          <dd>
            <p>
              Similar to <code>animate</code>, this method creates
              independent <code>TimedItem</code> object(s) for the
              elements in <code>target</code>.
              However, the resulting items are appended to the given
              <code>parentGroup</code>, if provided.
              If <code>parentGroup</code> is <code>null</code>, the
              <code>TimedItem</code> objects will not be added to any
              group.
            </p>
            <dl class="parameters">
              <dt>Element target</dt>
              <dd>
                As with <code>animate</code>.
              </dd>
              <dt>AnimationGroup? parentGroup</dt>
              <dd>
                The animation group to which animations should be appended.
              </dd>
              <dt>optional double startTime</dt>
              <dd>
                <p>
                  The start time for the generated animations
                  expressed in seconds in the iteration time space of the
                  <code>AnimationGroup</code> to which it is
                  appended (see <a href="#time-spaces" class="sectionRef"></a>).
                </p>
                <p>
                  If this parameter is not specified it will default to the
                  current iteration time of <code>parentGroup</code>.
                  If <code>parentGroup</code> is <code>null</code>,
                  this parameter will default to zero.
                </p>
              </dd>
            </dl>
          </dd>
          <dt>sequence&lt;TimedItem&gt; animateWithParent (
            sequence&lt;Node&gt; targets,
            AnimationGroup? parentGroup,
            optional double startTime)</dt>
          <dd>
            As with <code>animateWithParent(Element target,
              AnimationGroup? parentGroup,
              optional double startTime)</code> except
            one <code>TimedItem</code> is created for each
            <code>Node</code> in <code>target</code> that is of type
            <code>ELEMENT_NODE</code>.
          </dd>
          <dt>TimedItem animateLive (Element target,
            optional double startTime)</dt>
          <dd>
            As with <code>animate</code> with the exception that the
            <code>TimedItem</code> objects generated by this method are
            live.
          </dd>
          <dt>sequence&lt;TimedItem&gt; animateLive (
            sequence&lt;Node&gt; targets, optional double startTime)</dt>
          <dd>
            As with <code>animate</code> with the exception that the
            <code>TimedItem</code> objects generated by this method are
            live.
          </dd>
          <dt>TimedItem animateLiveWithParent
            (Element target, AnimationGroup? parentGroup,
             optional double startTime)</dt>
          <dd>
            As with <code>animateWithParent</code> with the exception that the
            animations generated by this method are live.
          </dd>
          <dt>sequence&lt;TimedItem&gt; animateLiveWithParent
            (sequence&lt;Node&gt; targets, AnimationGroup? parentGroup,
             optional double startTime)</dt>
          <dd>
            As with <code>animateWithParent</code> with the exception that the
            animations generated by this method are live.
          </dd>
        </dl>
      </section>
      <section>
        <h3>Instantiating an <code>AnimationTemplate</code></h3>
        <p>
          The procedure for instantiating an <code>AnimationTemplate</code>,
          <var>template</var>, given a list of target elements and an optional
          <var>parent group</var>, is as follows:
        </p>
        <ol>
          <li>
            Create an empty sequence of <code>Animation</code> objects.
          </li>
          <li>
            For each <var>element</var> in the list of target elements:
            <ol>
              <li>
                Create a new <code>Animation</code> object, <var>anim</var>.
              </li>
              <li>
                Set the <code>timing</code> and <code>animationFunction</code>
                properties of <var>anim</var> to copies
                <code>template.timing</code> and
                <code>template.animationFunction</code>.
              </li>
              <li>
                If <var>parentGroup</var> is not specified, let
                <var>parentGroup</var> be
                <code><var>element</var>.ownerDocument.animationTimeline</code>.
              </li>
              <li>
                Append <var>element</var> to <var>parentGroup</var>.
              </li>
              <li>
                Append <var>element</var> to the sequence of
                <code>Animation</code> objects.
              </li>
            </ol>
          </li>
          <li>
            Return the sequence of <code>Animation</code> objects.
          </li>
        </ol>
      </section>
      <section>
        <h3>Group templates</h3>
        <p>
          As with animations, templates can also be created for animation
          groups.
        </p>
        <p class="todo">
          Lots of questions here about how this should work.
        </p>
      </section>
      <section>
        <h3>The <code>AnimationGroupTemplate</code> interface</h3>
        <p class="todo">
          TBD
        </p>
        <dl title="interface AnimationGroupTemplate : TimedTemplate"
          class="idl">
          <dt>void clear ()</dt>
          <dd>
            Removes all child items from the group.
          </dd>
          <dt>getter TimedTemplate? (unsigned long index)</dt>
          <dd>
            Returns the template item at <code>index</code>.
            If <code>index</code> is greater than or equal to
            <code>length</code> returns <code>null</code>.
          </dd>
          <dt>setter TimedTemplate (unsigned long index,
                                    TimedTemplate newItem)</dt>
          <dd>
            <p>
              Replaces the item at <code>index</code> with
              <code>newItem</code> by calling
              <code>splice(index, 1, newItem)</code>.
            </p>
            <p>
              Returns <code>newItem</code>.
            </p>
            <p>
              The behavior of this method is identical to
              the equivalent setter in <code>AnimationGroup</code>
              except that DOMExceptions of type HierarchyRequestError are not
              thrown.
            </p>
          </dd>
          <dt>sequence&lt;TimedTemplate&gt; add (
                TimedTemplate newItem, TimedTemplate... otherItems)</dt>
          <dd>
            <p>
              Add <code>newItem</code> and each <code>otherItems</code> as the
              last item(s) in the group by calling <code>splice(group.length, 0,
              newItem, otherItem1, ... otherItemN)</code>.
            </p>
            <p>
              Returns a sequence containing the added items:
              <code>[newItem, otherItem1, ... otherItemN]</code>.
            </p>
          </dd>
          <dt>sequence&lt;TimedTemplate&gt; remove (
                long index, optional unsigned long count = 1)</dt>
          <dd>
            <p>
              Removes the item(s) at <code>index</code> by calling
              <code>splice(index, count)</code>.
            </p>
            <p>
              Returns the removed items.
            </p>
          </dd>
          <dt>
            sequence&lt;TimedTemplate&gt; splice ()
          </dt>
          <dd>
            <p>
              Modifies the list of children of this group by first removing
              <code>deleteCount</code> items from <code>start</code> followed by
              adding <code>newItems</code> at the same point.
            </p>
            <p>
              Returns a sequence of the items removed from group during the
              removal step (regardless of whether these items were re-added
              during the addition step).
            </p>
            <p>
              As with <code>AnimationGroup.slice</code> the operation of
              slice is based on <a
              href="http://www.ecma-international.org/publications/files/ECMA-ST-ARCH/ECMA-262%205th%20edition%20December%202009.pdf#page=140">ECMAScript
              5's Array.prototype.splice</a>.
            </p>
            <p>
              The operation of this method is identical to that of
              <code>AnimationGroup.slice</code> with the notable difference
              that DOMExceptions of type HierarchyRequestError are not thrown
              since there is no <code>AnimationGroupTemplate</code>
              corresponding to a document timeline.
            </p>
            <dl class="parameters">
              <dt>long start</dt>
              <dd>
                The index at which items should be removed and inserted.
                Negative indices represent an offset from the end of the list of
                items.
                This value is clamped to the range [-<code>length</code>,
                <code>length</code>].
              </dd>
              <dt>unsigned long deleteCount</dt>
              <dd>
                The number of items to remove from the group beginning at
                <code>start</code>.
                Negative values are clamped to zero, and all other values are
                clamped such that
                0 &lt; <code>start</code> + <code>deleteCount</code> &le;
                length.
              </dd>
              <dt>sequence&lt;TimedTemplate&gt; newItems</dt>
              <dd>
                The items to be added at <code>start</code>.
                Each item, if it already has a parent group (including this
                group), is first removed from its parent group before being
                added to this group.
              </dd>
            </dl>
          </dd>
          <dt>
            sequence&lt;TimedTemplate&gt; splice (long start,
              unsigned long deleteCount, TimedTemplate... newItem)
          </dt>
          <dd>
            An overload of <code>splice</code> to take a variadic list of items
            rather than requiring a sequence.
            The operation is identical to <code>splice(unsigned long start,
            unsigned long deleteCount, sequence&lt;TimedTemplate&gt;
            newItems)</code>.
          </dd>
          <dt>long indexOf (TimedTemplate item)</dt>
          <dd>
            Returns the index of <code>item</code> within the group.
            If <code>item</code> is not in the group, returns <code>-1</code>.
          </dd>
        </dl>
      </section>
      <section>
        <h3>The <code>ParGroupTemplate</code> interface</h3>
        <p>
          <a>ParGroup</a> objects can be created from <a>ParGroupTemplate</a>
          objects.
        </p>
        <dl title="[Constructor] interface ParGroupTemplate
          : AnimationGroupTemplate"
          class="idl">
        </dl>
      </section>
      <section>
        <h3>The <code>SeqGroupTemplate</code> interface</h3>
        <p>
          <a>SeqGroup</a> objects can be created from <a>SeqGroupTemplate</a>
          objects.
        </p>
        <dl title="[Constructor] interface SeqGroupTemplate
          : AnimationGroupTemplate" class="idl">
        </dl>
      </section>
      <section>
        <h3>Instantiating an <code>AnimationGroupTemplate</code></h3>
        <p class="todo">
          TBD. This is probably all wrong.
        </p>
        <p>
          The procedure for creating an <code>AnimationGroup</code> from
          an <code>AnimationGroupTemplate</code>, <var>template</var>,
          given a list of target elements, and optionally given a <var>parent
          group</var> follows.
        </p>
        <p>
          Note that <code>ParGroupTemplate</code> objects produce
          <code>ParGroup</code> objects and likewise
          <code>SeqGroupTemplate</code> objects produce <code>SeqGroup</code>
          objects.
          In the following description the <code>AnimationGroupTemplate</code>
          and <code>AnimationGroup</code> types should be substituted with the
          concrete types in use.
        </p>
        <ol>
          <li>
            Create an empty sequence to hold the generated
            <code>AnimationGroup</code> objects.
          </li>
          <li>
            For each <var>element</var> in the list of target elements:
            <ol>
              <li>
                Create a new <code>AnimationGroup</code> object,
                <var>group</var>.
              </li>
              <li>
                Set the <code>timing</code> property of <var>group</var> to
                a copy of <code>template.timing</code>.
              </li>
              <li>
                For each <var>child</var> in <var>template</var>, call
                <code><var>child</var>.animateWithParent(<var>element</var>,
                <var>group</var>, <code>startTime</code>)</code> or
                <code><var>child</var>.animateLiveWithParent(<var>element</var>,
                <var>group</var>, <code>startTime</code>)</code> depending on
                whether this procedure was invoked with <code>animate</code> or
                <code>animateLive</code>.
              </li>
              <li>
                If <var>parentGroup</var> is not specified, let
                <var>parentGroup</var> be
                <code><var>element</var>.ownerDocument.animationTimeline</code>.
              </li>
              <li>
                Append <var>group</var> to <var>parentGroup</var>.
              </li>
              <li>
                Append <var>group</var> to the sequence of
                <code>AnimationGroup</code> objects.
              </li>
            </ol>
          </li>
          <li>
            Return the sequence of <code>AnimationGroup</code> objects.
          </li>
        </ol>
      </section>
    </section>

    <section>
      <h2>Synchronizing with media</h2>
      <div class="todo">
        Currently investigating integration with HTML5's MediaController object.
      </div>
      <section>
        <h3>The <code>MediaItem</code> interface</h3>
        <dl title="interface MediaItem : TimedItem" class="idl">
          <dt>attribute HTMLMediaElement element</dt>
          <dd>
            A pointer to the element?
          </dd>
        </dl>
      </section>
    </section>

    <section>
      <h2>Animation events</h2>
      <div class="todo">
        <p>
          Need to consider how to align with existing
          <code>TransitionEvent</code>s, <code>AnimationEvent</code>s and
          <code>TimeEvent</code>s. It might make sense to have our events
          inherit from one or more of these interfaces or have implementations
          dispatch both (especially if their synchronization properties differ).
        </p>
        <p>
          I think we might also want a seek event? It seems like a lot of
          applications will want to do bookkeeping when there's
          a seek&mdash;especially a backwards seek. It might also be necessary
          for the SVG bindings so you can clear certain events on a backwards
          seek as required by SMIL.
        </p>
        <p>
          Talk about what events are dispatched on a seek.
          It's probably important that we don't dispatch intermediate events
          during a seek as then implementations will be required to step through
          each interval and it breaks the fact that skipping around the model is
          constant time.
          It's also not what SVG does, i.e. SVG skips events during a seek.
          I think you just want to record the animating vs non-animating state
          of each item before the seek, then compare to after the seek and fire
          the appropriate event.
          (Do groups fire events?)
        </p>
      </div>
      <section>
        <h3>Synchronizing event handlers</h3>
        <div class="todo">
          <p>
            The proposal to-date is as follows.
            Requirements for dispatch of animation events:
          </p>
          <ol>
            <li>
              Animations triggered by an event handler appear to have started at
              the time the event was scheduled to be triggered.
            </li>
            <li>
              No effect of an animation for any time 't' can be reflected in
              style, DOM or animation object until any animation event handlers
              associated with dispatch times at or before 't' have returned from
              execution.
            </li>
          </ol>
          <p>In effect this is roughly the same as saying:</p>
          <blockquote>
            When event handlers due to  animation events run, the state of the
            world (DOM properties etc.) so  far as it is influenced by
            animation, is as if the current time was the time when the event was
            scheduled to be triggered.
          </blockquote>
          <p>
            There may be many ways to realise this, including:
          </p>
          <ul>
            <li>
              dispatching animation events synchronously
            </li>
            <li>
              careful updating of the animation time (after waiting for
              corresponding animation events to return)
            </li>
            <li>
              pausing the world
            </li>
          </ul>
          <p>
            Shane and Tab feel that this approach is not very webby, and might
            be going to too much effort in order to support a programming
            model that should be discouraged.
          </p>
          <p>
            In the current model, the animation timeline is essentially
            static unless modified by script, which means that interrogating
            this timeline for information should be safe even in the absence
            of enforced synchronization.
            So if correct handling of an event requires precise knowledge
            about which animations have started or finished, then the timeline
            can be inspected at the time given in the event. 
          </p>
          <p>
            Furthermore, triggering animations off complex functions involving
            current animation state is probably not the right way to go - 
            instead some kind of model of the state should be used and the
            animations derived from that.
          </p>
          <p>
            In short, in the absence of strong use cases for synchronous events
            we feel we should go with a simpler model.
          </p>
          <p>
            Some alternative approaches are:
          </p>
          <ul>
            <li>
              Standard asynchronous events with no guarantees about the
              state of the world when event handlers are called.
            </li>
            <li>
              Event logs like those proposed to replace DOM events.
            </li>
        </div>
      </section>
    </section>

    <section>
      <h2>Animation of common data types</h2>
      <p>
        Need to describe how to interpolate/add both:
        <ol>
          <li>Integers, floats, strings etc.</li>
          <li>CSS and SVG types (colors etc.)</li>
          <ul><li>Support for HSL (if the colors are specified in HSL we should
            interpolate in that notation; but it should also be possible to
            do so regardless of how the colors are specified)</li></ul>
        </ol>
      </p>
      <p>
        For transforms I think it's defined elsewhere so we can either just
        point to that spec, or just refer to the fact that other specs should
        define how their types should be supported (or not) for animation.
      </p>
      <p>
        Need to provide facility for smooth interpolation of arbitrary paths.
      </p>
    </section>

    <section>
      <h2>Integration with Media Fragments</h2>
      <p>
        The Media Fragments specification [[MEDIA-FRAGMENTS]] defines a means
        for addressing a temporal range of a media resource.  For resources
        containing content animated with Web Animations the application of the
        temporal parameters is as follows:
      </p>
      <ol>
        <li>
          <p>
            If a begin time is specified, perform a seek on the document
            timeline passing in the specified begin time as the seek time (see
            <a href="#seeking-a-timed-item" class="sectionRef"></a>).
          </p>
          <p class="note">
            Note that seeking behavior is well-defined even when the document
            has yet to start and hence the seek can be performed regardless of
            the setting of the <code>timelineStart</code> property (see <a
            href="#start-of-the-timeline" class="sectionRef"></a>).
          </p>
        </li>
        <li class="todo">
          If an end time is specified... we need a way to say, "play this
          range", or "stop at this point" but in such a way that you can still
          seek beyond that range.
          (In order to be consistent with how hyperlinks work elsewhere such as
          document anchors, svg views, etc.)
          Perhaps we just make it an interal thing for now and in a future
          version add some means of playing a range, or better still, a series
          of ranges; something compatible with what we have for video.
        </li>
      </ol>
    </section>

    <section>
      <h2>Interaction with page display</h2>
      <p class="todo">
        What should be the behavior here? Should we pause on unload/pagehide?
        What does video do?
      </p>
    </section>

    <section>
      <h2>Making animation accessible</h2>
      <p class="todo">
        TBD. If we have triggers represented in the API, need a way to make
        these available to accessibility agents.
      </p>
      <p class="todo">
        TBD. Need a way to expose speed control etc.?
      </p>
      <p class="todo">
        TBD. Describe how to integrate with the <a
          href="http://www.whatwg.org/specs/web-apps/current-work/#timed-text-tracks">Timed
          Text API</a> and give examples of how to author content so it is
        accessible.
      </p>
    </section>

    <section>
      <h2>Implementation requirements</h2>
      <section>
        <h3>Discarding past animations</h3>
        <p>
          If implementations are required to preserve all state associated with
          animations then the resources required by an animation could continue
          to increase without limit over time. For long-running animations, and
          particularly those where animations are added dynamically, this could
          lead to degraded performance and eventual failure.
        </p>
        <div class="issue">
          <p>
            I'm not sure how to define this. We could say all animations with
            <code><var>end time converted to document time</var> &lt;
            <var>current document time</var> - 5min</code> can be discarded.
          </p>
          <p>
            That's fine, but what about crazy documents that put 1 million
            animations in a 5min span? Just leave that up to the browser.
            Also, what about mobile clients, is 5 min too long? Is this too
            prescriptive?
          </p>
          <p>
            Maybe, just make some suggestions (e.g. 1 min for mobile clients,
            5 min for desktop?) and then define an exception to throw if there
            is a seek to some time outside that window.
          </p>
          <p>
            Also, note that defining this in terms of past intervals is
            direction-specific but that's probably ok since most long-running
            animations will run forwards.
          </p>
        </div>
      </section>
    </section>

    <section class='appendix'>
      <h2>Acknowledgements</h2>
    </section>
  </body>
</html>
