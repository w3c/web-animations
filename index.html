<!DOCTYPE html>
<!-- vim: set expandtab ts=2 sw=2 tw=80: -->
<html>
  <head>
    <title>Web Animations 1.0</title>
    <meta charset="utf-8">
    <script src="respec/respec.js" class="remove"></script>
    <script
      src="http://dev.w3.org/2009/dap/ReSpec.js/js/lang/sh_javascript.min.js"
      class="remove"></script>
    <script class="remove">
      var respecConfig = {
        // specification status (e.g. WD, LCWD, NOTE, etc.). If in doubt use
        // ED.
        specStatus: "ED",

        // the specification's short name, as in
        // http://www.w3.org/TR/short-name/
        // shortName:            "web-anim",

        // if your specification has a subtitle that goes below the main
        // formal title, define it here
        // subtitle   :  "an excellent document",

        // if you wish the publication date to be other than today, set this
        // publishDate:  "2009-08-06",

        // if the specification's copyright date is a range of years, specify
        // the start date here:
        // copyrightStart: "2012"

        // if there is a previously published draft, uncomment this and set
        // its YYYY-MM-DD date and its maturity status
        // previousPublishDate: "1977-03-15",
        // previousMaturity: "WD",

        // if there a publicly available Editor's Draft, this is the link
        edDraftURI:
        "https://dvcs.w3.org/hg/FXTF/raw-file/tip/web-anim/index.html",

        // if this is a LCWD, uncomment and set the end of its review period
        // lcEnd: "2009-08-05",

        // if you want to have extra CSS, append them to this list
        // it is recommended that the respec.css stylesheet be kept
        extraCSS: ["respec/respec.css",
                   "web-animations.css"],

        // Turning off inlineCSS for now since if extraCSS points to
        // a relative URL your testing from a file URL the XHR will fail.
        // Probably should turn this back on once this is hosted on a server
        // somewhere.
        inlineCSS: false,

        // editors, add as many as you like
        // only "name" is required
        editors:  [
            { name: "Brian Birtles", mailto: "bbirtles@mozilla.com",
              company: "Mozilla Japan", companyURL: "http://mozilla.jp/" },
            { name: "Shane Stephens", mailto: "shans@google.com",
              company: "Google, Inc", companyURL: "http://www.google.com/" },
            { name: "Alex Danilo", mailto: "adanilo@google.com",
              company: "Google, Inc", companyURL: "http://www.google.com/" },
            { name: "Dmitry Baranovskiy", mailto: "baranovs@adobe.com",
              company: "Adobe Systems", companyURL: "http://www.adobe.com/" },
            { name: "Tab Atkins", mailto: "jackalmage@gmail.com",
              company: "Google, Inc", companyURL: "http://www.google.com/" },
        ],

        // authors, add as many as you like.
        // This is optional, uncomment if you have authors as well as editors.
        // only "name" is required. Same format as editors.

        //authors:  [
        //    { name: "Your Name", url: "http://example.org/",
        //      company: "Your Company", companyURL: "http://example.com/" },
        //],

        // name of the WG(s)
        wg: [ "CSS Working Group",
              "SVG Working Group" ],

        // URI of the public WG page
        wgURI: [ "http://dev.w3.org/Style/CSS/members",
                 "http://www.w3.org/Graphics/SVG/WG" ],

        // Activity this WG is part of
        wgActivity: [ 
          [ "Style", "http://www.w3.org/Style/Activity" ],
          [ "Graphics", "http://www.w3.org/Graphics/Activity" ]
        ],

        // name (without the @w3c.org) of the public mailing to which comments
        // are due
        wgPublicList: "public-fx",

        // URI of the patent status for this WG, for Rec-track documents
        // !!!! IMPORTANT !!!!
        // This is important for Rec-track documents, do not copy a patent URI
        // from a random document unless you know what you're doing. If in
        // doubt ask your friendly neighbourhood Team Contact.
        wgPatentURI:  "",

        noIDLSorting: true,
        noIDLIn: true
      };
    </script>
    <!--
      ReSpec.js wishlist:

      Add here any issues you find with ReSpec including missing features. It
      will help us decide if we should continue using it and work out what we
      need to fix.

      * Allow making cross-references to specific methods and members.
      * Support getter/setter/deleter/creator
    -->
  </head>
  <body>
    <section id='abstract'>
      This is the abstract for your specification.
    </section>

    <section class="informative">
      <h2>Introduction</h2>
      <p>
        Web Animations defines features for supporting animation and
        synchronization on the Web platform by means of a programming interface.
        This interface is intended to be used both directly to easily produce
        animations using script, as well as a foundation for other
        specifications whose behavior can be defined in terms of these features.
      </p>
      <section>
        <h3>Relationship to other specifications</h3>
        <p>
          CSS Transitions [[CSS3-TRANSITIONS]], CSS Animations 
          [[CSS3-ANIMATIONS]], and SVG [[SVG112]] all provide mechanisms that
          generate animated content on a web page.
          Although the three specifications provide similar functionality,
          the syntaxes are incompatible and the animations cannot be
          interchanged.
          Furthermore, the interfaces available for interacting with animations
          from script are largely general-purpose interfaces with few features
          tuned specifically to the creation and manipulation of animations.
        </p>
        <p>
          This specification proposes an abstract animations model that
          encompasses the abilities of both CSS and SVG, and additionally
          provides a programming interface to expose these features to script.
        </p>
        <p>
          This specification is accompanied by a CSS embedding specification,
          which describes how CSS features can be implemented in terms of Web 
          Animations primitives, and an SVG embedding specification, which
          describes how SVG features can be implemented in terms of Web
          Animations primitives.
        </p>
        <p>
          As a result, this specification does not directly alter the behavior
          of CSS Transitions, CSS Animations, or SVG.
          However, Web Animations is intended to replace the SMIL Animation
          [[SMIL-ANIMATION]] specification where it is currently used to define
          the behavior of SVG's animation features.
        </p>
        <p>
          This specification makes some additions to some interfaces defined in
          HTML5 [[HTML5]].
        </p>
      </section>
    </section>

    <section class="informative">
      <h2>Web Animations overview</h2>
      <p>
        At a glance, Web Animations consists of two largely independent
        pieces, a <em>timing model</em> and an <em>animation model</em>.
        The role of these pieces is as follows:
      </p>
      <dl>
        <dt>Timing model</dt>
        <dd>
          Takes a moment in time and converts it to a proportional distance
          within a single iteration of an animation called the <em>time
          fraction</em>.
        </dd>
        <dt>Animation model</dt>
        <dd>
          Takes the <em>time fractions</em> produced by the timing model and
          converts them into a series of values to apply to the target
          properties and attributes.
        </dd>
      </dl>
      <p>
        Graphically, this flow can be represented as follows:
      </p>
      <div class="figure">
        <img src="img/timing-and-animation-models.svg" width="600">
      </div>
      <p class="caption">
        Overview of the operation of Web Animations.<br>
        The current time is input to the timing model which produces a time
        fraction.<br>
        This distance is used as input to the animation model which produces the
        values to apply.
      </p>
      <p>
        For example, consider an animation that:
      </p>
      <ul>
        <li>starts after 3 seconds,</li>
        <li>runs twice,</li>
        <li>takes 2 seconds every time, and</li>
        <li>changes the width of a rectangle from 50 pixels to 100 pixels.</li>
      </ul>
      <p>
        The first three points apply to the timing model.
        At a time of 6 seconds, it will calculate that the animation should be
        half-way through its second iteration and produces the result 0.5.
        The animation model then uses that information to calculate a width for
        the rectangle of 75.
      </p>
      <p>
        This specification begins with the timing model and then proceeds to the
        animation model.
      </p>
    </section>

    <section class="informative">
      <h2>The timing model at a glance</h2>
      <p>
        Two features characterise the Web Animations timing model: it is
        <em>stateless</em> and it is <em>hierarchical</em>.
      </p>
      <section>
        <h3>Stateless</h3>
        <p>
          The Web Animations timing model operates by taking an input time and
          producing an output time fraction.
          Since the output is based solely on the input time and is entirely
          independent of previous inputs, the model may be described as
          stateless.
          This gives the model the following properties:
        </p>
        <dl>
          <dt>Frame-rate independent</dt>
          <dd>
            Since the output is independent of previous inputs, the rate at
            which the model is sampled will not affect its progress.
            Provided the input times are proportional to the progress of
            real-world time, animations will progress at an identical rate
            regardless of the capabilities of the device running them.
          </dd>
          <dt>Direction agnostic</dt>
          <dd>
            Since the sequence of inputs is insignificant, the model is
            directionless.
            This means that the model can be sampled in reverse or even in
            a backwards and forwards pattern without requiring any specialized
            handling.
          </dd>
          <dt>Constant-time seeking</dt>
          <dd>
            Since each input is independent of the previous input, the
            processing required to perform a seek operation, even far into the
            future, is at least potentially constant.
          </dd>
        </dl>
        <p>
          There are two apparent exceptions to the stateless behavior of the
          timing model.
        </p>
        <p>
          Firstly, events are fired when, for example, one sample falls
          on the opposite side of an animation's interval boundary to the
          previous sample.
          This is certainly stative behavior.
          However, events should be considered as a layer added on top of the
          core timing model.
          In the case where no event listeners are registered, the model is
          stateless.
        </p>
        <p>
          The other exception to this stateless behavior is that a number of
          methods such as <code>pause</code> and <code>reverse</code> are
          defined in terms of the time at which they are called and are
          therefore stative.
          These methods are provided primarily for convenience and are not part
          of the core timing model but, like events, are layered on top.
        </p>
        <p>
          Finally, each time the model is sampled, it can be considered to
          establish a temporary state.
          While this temporary state affects the values returned from the API,
          it has no influence on the subsequent samples and hence does not
          conflict with the stateless qualities described above.
        </p>
      </section>
      <section>
        <h3>Hierarchical</h3>
        <p>
          The other characteristic feature of the Web Animations timing model is
          that time is inherited.
          Time begins with a monotonically increasing time source and cascades
          down a number of steps to each animation.
          At each step, time may be shifted backwards and forwards, scaled,
          reversed, paused, and repeated.
        </p>
        <div class="figure">
          <img src="img/time-hierarchy.svg" width="600">
        </div>
        <p class="caption">
          A hierarchy of time sources.
          Each node in the tree refers to a time source from which it derives
          its time.
          This parent time source is referred to here as the node's timeline.
        </p>
        <p>
          A consequence of this hierarchical arrangement is that complex
          animation arrangements can be reversed, schedule, accelerated and so
          on, as a whole since the manipulations applied to the parent cascade
          down to its descendants.
          Furthermore, since time has a common source, it is easy to synchronize
          otherwise independent animations.
        </p>
      </section>
    </section>

    <section>
      <h2>Time sources</h2>
      <p>
        In Web Animations timing is based on a hierarchy of time relationships
        where the nodes are called time sources.
        Time sources provide a <dfn>time value</dfn> for the purpose of deriving
        further time sources and for eventual input into the animation model.
      </p>
      <p class="annotation">
        A future version or module may offer time sources based on UI gestures
        or other quantities that are less related to time.
      </p>
      <p>
        Time sources are represented in the Web Animations <acronym
        title="Application Programming Interface">API</acronym> by the
        <a>TimeSource</a> interface.
      </p>
      <section>
        <h3>The <code>TimeSource</code> interface</h3>
        <dl title="interface TimeSource" class="idl">
          <dt>readonly attribute double? currentTime</dt>
          <dd>
            <p>
              The current <a>time value</a> of this time source in seconds.
              This value is updated each time the model is sampled (see <a
              href="#interaction-with-script" class="sectionRef"></a>).
            </p>
            <p>
              Note that current time will be <code>null</code> if the time
              source cannot currently produce a time value.
              For example, a time source that derives its time from another time
              source will return <code>null</code> if the parent time source is
              not provided, is unavailable, or if the parent time source reports
              <code>null</code> as its <code>currentTime</code>.
            </p>
            <p class="note">
              Note that while <code>currentTime</code> is read-only in this
              interface, it is writeable in the derived interface
              <a>TimedItem</a>.
            </p>
          </dd>
        </dl>
      </section>
    </section>

    <section>
      <h2>The document timeline</h2>
      <p>
        Towards the root of the time hierarchy is the document time source.
        A document time source is associated with a <a
        href="http://www.w3.org/TR/html51/dom.html#the-document-object">Document</a>
        [[HTML5]]
        object and provides a monotonically increasing time value that begins at
        zero when the Document <a>begins to play</a>.
      </p>
      <p>
        A document time source <dfn>begins to play</dfn> at the earliest of the
        following possible moments:
      </p>
      <ol>
        <li>When a call is made to <code>play</code> on the
            <a>DocumentTimeSource</a>.</li>
        <li>The moment immediately prior to dispatching the "load" event of the
            document with which it is associated if the <code>autoplay</code>
            attribute on the <a>DocumentTimeSource</a> is <code>true</code> at
            that moment.
            <p>
              For HTML documents, this is the moment after the <a
              href="http://www.w3.org/TR/html51/dom.html#current-document-readiness
              ">current document readiness</a> has changed to "complete" but
              before dispatching the load event.
              In terms of the timings defined in [[NAVIGATION-TIMING]], this
              occurs between the <em>domComplete</em> and
              <em>loadEventStart</em> timings.
            </p>
        <li>When the <code>autoplay</code> attribute is made newly
            <code>true</code> at a moment after opportunity 2.</li>
      </ol>
      <p>
        Before a document time source <a>begins to play</a>, its <a>time
        value</a> is <code>null</code>.
        Once a document time source has begun to play its immediate time value
        is zero and from that point onwards, it reports the number of seconds
        since it <a title="begins to play">begun to play</a> subject to the
        constraints on updating the time value in <a
        href="#interaction-with-script" class="sectionRef"></a>.
      </p>
      <p>
        Once a document time source has begun to play it cannot be restarted or
        paused and continues to be non-<code>null</code> for the remainder of
        its lifetime.
      </p>
      <section>
        <h3>The <a>DocumentTimeSource</a> interface</h3>
        <dl title="interface DocumentTimeSource : TimeSource" class="idl">
          <dt>attribute boolean autoplay</dt>
          <dd>
            <p>
              Indicates if the document time source should <a title="begins to
              play">begin to play</a> automatically at the moment immediately
              before the "load" event is fired.
              Initially <code>true</code>.
            </p>
          </dd>
          <dt>void play ()</dt>
          <dd>
            If the document time source has not already <a title="begins to
            play">begun to play</a> causes it to begin immediately.
          </dd>
          <dt>double? toDocumentTime (double documentTime,
                                      DocumentTimeSource other)</dt>
          <dd>
            <p>
              Returns the time value from another <a>DocumentTimeSource</a>,
              <em>other</em>, converted to a time value relative to the when
              this document time source began.
            </p>
            <p>
              Returns <code>null</code> if <em>documentTime</em> time represents
              a time earlier than when this document time source <a
              title="begins to play">began to play</a> or if this document time
              source has not yet begun to play.
            </p>
            <p>
              Exceptions:
            </p>
            <dl class="exceptions">
              <dt>DOMException of type <code>IndexSizeError</code></dt>
              <dd>
                Raised if <em>documentTime</em> is less than zero.
              </dd>
            </dl>
          </dd>
          <dt>double? toDocumentTime (Event event)</dt>
          <dd>
            <p>
              Returns the number of seconds between when <em>event</em> was
              fired and when this document time source began.
            </p>
            <p>
              Since the <code>timeStamp</code> attribute of the
              <code>Event</code> interface specified in [[DOM-LEVEL-3-EVENTS]]
              is not guaranteed to be monotonically increasing implementations
              SHOULD record alongside each event a suitable monotonically
              increasing timestamp that can be used to convert to an appropriate
              time value here.
            </p>
            <p>
              Returns <code>null</code> if the time of the event precedes when
              this document time source <a title="begins to play">began to
              play</a> or if this document time source has not yet begun to
              play.
            </p>
            <p class="issue">
              This might be deferred to a later version.
            </p>
          </dd>
          <dt>double? fromDocumentTime (double documentTime,
                                        TimeSource other)</dt>
          <dd>
            <p>
              Returns the corresponding time value for a given time source,
              <em>other</em>, for a time value relative to this document time
              source using the following procedure.
            </p>
            <ol>
              <li>Define the <dfn>parent time source</dfn> of time source A as
                  being the value of a <code>timeline</code> property on A if
                  such a property exists and refers to a <a>TimeSource</a>
                  object.</li>
              <li>Define an <dfn>ancestor time source</dfn> of time source A as
                  any time source that appears in the chain of parent time
                  sources constructed starting with the <a>parent time
                  source</a> of A and continuing with each subsequent parent
                  up to and including a document time source or until there are
                  no further parent time sources.</li>
              <li>Define a time source A as being <dfn>derived from another time
                  source</dfn> B if B is an <a>ancestor time source</a> of
                  A.</li>
              <li>Determine <var>local document time</var> as follows:
                <dl class="switch">
                  <dt>If <em>other</em> is not <a title="derived from another
                  time source">derived from</a> this document time source,</dt>
                  <dd>
                    <ol>
                      <li>
                        Let <var>remote document</var> be the document time
                        source that is an <a>ancestor time source</a> of
                        <em>other</em> if such a document time source exists.
                      </li>
                      <li>
                        If there is no such <var>remote document</var> raise
                        a <code>DOMException</code> of type
                        <code>HierarchyRequestError</code>.
                      </li>
                      <li>
                        Let <var>local document time</var> be the result of
                        calling <code>toDocumentTime(<em>documentTime</em>,
                        <var>remote document</var>)</code> on this object.
                      </li>
                    </ol>
                  </dd>
                  <dt>Otherwise,</dt>
                  <dd>
                    Let <var>local document time</var> be <em>documentTime</em>.
                  </dd>
                </dl>
              </li>
              <li>
                Calculate the <code>currentTime</code> of <em>other</em> by
                following the steps described <span
                class="todo">somewhere...</span>
              </li>
            </ol>
            <p>
              Exceptions:
            </p>
            <dl class="exceptions">
              <dt>DOMException of type <code>HierarchyRequestError</code></dt>
              <dd>
                Raised if <em>other</em> does not have an <a>ancestor time
                source</a> that is a document time source object.
              </dd>
            </dl>
            <p class="issue">
              Is this needed? And is the automatic cross-document time source
              negotation required?
            </p>
          </dd>
        </dl>
        <p>
          As document time sources are associated with a Document object, the
          following extension is required to the Document interface defined in
          [[HTML5]].
        </p>
        <dl title="partial interface Document" class="idl">
          <dt>readonly attribute DocumentTimeSource timeline</dt>
          <dd>
            The <a>DocumentTimeSource</a> associated with the document.
          </dd>
        </dl>
      </section>
    </section>

    <section class="informative">
      <h2>The animation timeline</h2>
      <p>
        Each document contains a timeline to which animations may be added.
        These animations have an interval during which they are scheduled to
        animate.
      </p>
      <div class="figure">
        <img src="img/timeline.svg" width="600">
      </div>
      <p class="caption">
        At time <em>t</em> animations A and B are animating.
        Animation C has finished animating.
        Animation D has yet to begin and is not animating.
      </p>
      <p>
        The start time of the timeline is defined in <a
        href="#start-of-the-timeline" class="sectionRef"></a>.
      </p>
      </div>
    </section>

    <section>
      <h2>Animations in the timeline</h2>
      <p>
        Animations in the timeline are represented by <code>Animation</code>
        objects.
      </p>
      <section>
        <h3>The <code>Animation</code> interface</h3>
        <dl title="interface Animation : TimedItem" class="idl">
          <dt>Constructor ()</dt>
          <dd>
            <p>
              Creates a new <a>Animation</a> object.
            </p>
            <p>
              Examples of the usage of this constructor are given in <a
              href="#creating-a-new-animation-object" class="sectionRef"></a>.
            </p>
            <dl class="parameters">
              <dt>AnimationTarget? elem</dt>
              <dd>
                The target element or pseudo-element.
                This may be <code>null</code> for animations that do not target
                a specific element.
              </dd>
              <dt>object? effect</dt>
              <dd>
                The animation effect used to set the <code>effect</code>
                property of the newly created <a>Animation</a> object.
                <p>
                  If this parameter is an <a>AnimationEffect</a> object or
                  <a>CustomAnimationEffect</a> object, it will shared with any
                  other <a>Animation</a> objects referring to the same
                  <a>AnimationEffect</a> or <a>CustomAnimationEffect</a>
                  object.
                  It will <em>not</em> be copied.
                </p>
                <p>
                  If this parameter is <code>null</code>, the newly created
                  <a>Animation</a> will also have a <code>null</code> animation
                  effect.
                </p>
                <p>
                  Otherwise, if this parameter is any other type of object, it
                  will be passed to <a
                  href="#widl-AnimationEffect-createFromProperties-AnimationEffect-object-properties"
                  class="idlType"><code>AnimationEffect.createFromProperties</code></a>
                  and the resulting <a>AnimationEffect</a> object used as the
                  animation effect.
                </p>
              </dd>
              <dt>optional (double or TimingDictionary or Timing)? timing</dt>
              <dd>
                The timing properties of the new animation.
                <p>
                  If this parameter is a <code>double</code>, then it
                  specifies the duration of a single iteration of the animation,
                  that is, the <a>iteration duration</a>, in seconds.
                  In this case, the <code>timing</code> property of the new
                  <a>Animation</a> object is set to a new <a>Timing</a> object
                  constructed from a <a>TimingDictionary</a> object with the
                  <code>duration</code> property set to the <code>double</code>
                  value specified here, and all other properties set to their
                  default values.
                </p>
                <p>
                  Similarly, if this parameter is <code>null</code>, the
                  <code>timing</code> property is set to a new <a>Timing</a>
                  object constructed from a <a>TimingDictionary</a> object
                  with all properties set to their default values.
                </p>
                <p>
                  If this parameter is of type <a>TimingDictionary</a>, then the
                  passed-in dictionary is used to construct a new <a>Timing</a>
                  object which is then assigned to the <code>timing</code>
                  property of the new <a>Animation</a> object.
                </p>
                <p>
                  If this parameter is a <a>Timing</a> object, it is directly
                  assigned to the <code>timing</code> property of the new
                  <a>Animation</a> object.
                  It is <em>not</em> copied.
                  In this way <a>Timing</a> objects can be shared between
                  <a>Animation</a> objects.
                </p>
                <p>
                  Finally, if this parameter is not specified, it is as if
                  a value of <code>null</code> were specified.
                </p>
              </dd>
              <dt>optional AnimationGroup? parentGroup</dt>
              <dd>
                The group to which the newly created animation should be
                appended as a child.
                If not specified, the animation will be appended to the document
                timeline.
                If <code>null</code>, the animation will not be appended to any
                group.
              </dd>
              <dt>optional double startTime</dt>
              <dd>
                The <a>start time</a> of the newly generated animation
                expressed in seconds in the <a>iteration time space</a> of the
                <a>AnimationGroup</a> to which it is (or will be) appended.
                <p>
                  If not specified, the current <a>iteration time</a> of the
                  <a>AnimationGroup</a> to which the animation is appended (as
                  determined by the <code>parentGroup</code> parameter) will be
                  used. If <code>parentGroup</code> is <code>null</code>, and
                  the <code>startTime</code> is not specified, a time of zero
                  will be used.
                </p>
              </dd>
            </dl>
          </dd>
          <dt>NamedConstructor = LinkedAnimation(AnimationTarget? elem,
                                                 AnimationTemplate template,
                                                 optional double startTime)</dt>
          <dd>
            TBD
          </dd>
          <dt>NamedConstructor = ClonedAnimation(AnimationTarget? elem,
                                                 Animation cloneSource,
                                                 AnimationGroup? parentGroup,
                                                 optional double startTime)
          <dd>
            TBD
          </dd>
          <dt>attribute (AnimationEffect or CustomAnimationEffect)? effect</dt>
          <dd>
            <p>
              The animation effect to apply (see <a
              href="#animation-values" class="sectionRef"></a>).
              May be <code>null</code> in which case the animation will produce
              no noticeable effect other than dispatching events (see <a
              href="#timing-events" class="sectionRef"></a>).
            </p>
            <p>
              Exceptions:
            </p>
            <dl class="exceptions">
              <dt>DOMException of type
                  <code>NoModificationAllowedError</code></dt>
              <dd>
                Raised on setting if this object is linked to a template (i.e.
                <code>template</code> is not <code>null</code>).
              </dd>
            </dl>
          </dd>
          <dt>attribute AnimationTemplate? template</dt>
          <dd>
            <p>
              For linked animations (see <a href="#animation-templates"
              class="sectionRef"></a>), the <a>AnimationTemplate</a> object
              from which this object derives its values.
              For animations that are not linked to a template, this property is
              <code>null</code>.
            </p>
            <p>
              Setting this property has the following effect:
            </p>
            <ol>
              <li>Let <var>new template</var> be the value to assign to the
                  <code>template</code> property.</li>
              <li>If <var>new template</var> is <code>null</code>,
                <ol>
                  <li>Call <code>unlink()</code>.</li>
                </ol>
              </li>
              <li>Otherwise,
                <ol>
                  <li>Set <code>timing</code> to <code><var>new
                      template</var>.timing.clone()</code>.</li>
                  <li>Set <code>effect</code> to <code><var>new
                      template</var>.effect.clone()</code>.</li>
                  <li>Set <code>template</code> to <code><var>new
                      template</var></code>.</li>
                </ol>
              </li>
            </ol>
          </dd>
          <dt>readonly attribute AnimationTarget? targetElement</dt>
          <dd>
            <p>
              The element or pseudo-element being animated by this object.
              This may be <code>null</code> for animations that do not target
              a specific element such as an animation that produces a sound
              using an audio API.
            </p>
          </dd>
          <dt>AnimationTemplate templatize()</dt>
          <dd>
            <p>
              If this object is not already linked to a template,
              creates a new <a>AnimationTemplate</a> object based on this object
              and links this object to it (see <a href="#animation-templates"
              class="sectionRef"></a>).
            </p>
            <p class="feedbackWanted">
              What is the more useful behavior? To always create a template?
              Or to only create one if it doesn't already have one?
            </p>
            <p>
              The effect is equivalent to the following steps:
            </p>
            <ol>
              <li>Let <var>source</var> be the object on which
                  <code>templatize</code> is called.</li>
              <li>If <code><var>source</var>.template</code> is not
                  <code>null</code>, return.</li>
              <li>Create a new <a>AnimationTemplate</a> object,
                  <var>template</var>.</li>
              <li>Set <code><var>template</var>.timing</code> to
                  <code><var>source</var>.timing.clone()</code>.</li>
              <li>Set <code><var>template</var>.effect</code> to
                  <code><var>source</var>.effect.clone()</code>.</li>
              <li>Set <code><var>source</var>.template</code> to
                  <var>template</var>.</li>
              <li>Return <var>template</var>.</li>
            </ol>
          </dd>
          <dt>AnimationTemplate? unlink()</dt>
          <dd>
            <p>
              Makes this animation independent of the template with which it is
              associated if any
              (see <a href="#animation-templates" class="sectionRef"></a>)
            </p>
            <p>
              After setting <code>template</code> to <code>null</code> the
              previous value of <code>template</code> is returned.
            </p>
            <p>
              The effect is equivalent to the following steps:
            </p>
            <ol>
              <li>If <code>template</code> is <code>null</code>, return
                  <code>null</code>.</li>
              <li>Let <var>old template</var> be <code>template</code>.</li>
              <li>Set <code>timing</code> to
                  <code>template.timing.clone()</code>.</li>
              <li>Set <code>effect</code> to
                  <code>template.effect.clone()</code>.</li>
              <li>Set <code>template</code> to <code>null</code> (but do not
                  recursively call this function).</li>
              <li>Return <var>old template</var>.</li>
            </ol>
          </dd>
        </dl>
        <section class="informative">
          <h4>Creating a new <code>Animation</code> object</h4>
          <p>
            The <a>Animation</a> constructor offers a number of approaches to
            creating a new <a>Animation</a> object.
            At its simplest, an <a>Animation</a> object that changes the
            &lsquo;left&rsquo; property of <var>elem</var> to 100 over three
            seconds can be achieved as follows:
          </p>
          <pre class='example sh_javascript'>
var anim = new Animation(elem, { left: '100px' }, 3);
          </pre>
          <p>
            To specify further timing properties such as the playback rate,
            a <a>TimingDictionary</a> can be used as follows:
          </p>
          <pre class='example sh_javascript'>
var anim = new Animation(elem, { left: '100px' }, { duration: 3, playbackRate: 2 });
          </pre>
          <p>
            To share or re-used timing properties with another animation,
            a <a>Timing</a> object can be directly passed in as follows:
          </p>
          <pre class='example sh_javascript'>
// Share the timing properties of animB with animA
var animA = new Animation(elem, { left: '100px' }, animB.timing);

// Re-use the timing properties of animB in animC without sharing
var animC = new Animation(elem, { left: '100px' }, animB.timing.clone());
          </pre>
          <p>
            The animation effect parameter may specify multiple properties,
            an <a>AnimationEffect</a> object, or even a callback object.
          </p>
          <pre class='example sh_javascript'>
// Specify multiple properties at once
var animA = new Animation(elem, { left: '100px', top: '300px' }, 5);

// Share the animation effect of another animation
var animB = new Animation(elem, animA.effect, 3);

// Supply a specialized animation effect
var animC = new Animation(elem, new PathAnimationEffect( ... ), 3);

// Supply a custom script-based animation effect
var animC = new Animation(elem,
  { 
    sample: function(time) { 
      if (time !== null) {
        document.documentElement.currentScale = 1.0 + time * 2.0;
      } else {
        document.documentElement.currentScale = 1.0;
      }
    },
    clone: function { return this; }
  }, 3);
          </pre>
          <p class="todo">
            Fill in the parameters for <a>PathAnimationEffect</a> above once
            we have decided on them.
          </p>
          <p class="todo">
            Add examples of specifying the parent group and start time once we
            resolve the behavior of those.
          </p>
        </section>
      </section>
      <section>
        <h3>Animation targets and pseudo-elements</h3>
        <p>
          Animations may target not only regular elements but also
          pseudo-elements such as <code>::before</code> and
          <code>::first-line</code> [[!SELECT]].
        </p>
        <p>
          To represent pseudo-elements, we introduce the <a>PseudoElement</a>
          interface.
        </p>
        <dl title="interface PseudoElement" class="idl">
          <dt>Constructor (Element element, DOMString pseudoElement)</dt>
          <dd>
            Creates a new pseudo-element using <var>element</var> as the <a
            href="http://www.w3.org/TR/css3-selectors/#subject">subject</a>
            and <var>pseudoElement</var> as the pseudo-element to match (e.g.
            &lsquo;<code>::first-line</code>&rsquo;).
          </dd>
          <dt>attribute Element element</dt>
          <dd>
            The element used as the <a
            href="http://www.w3.org/TR/css3-selectors/#subject">subject</a> for
            matching a pseudo-element.
            <p>Exceptions:</p>
            <dl class="exceptions">
              <dt>DOMException of type
                  <code>NoModificationAllowedError</code></dt>
              <dd>
                Raised on setting if this object is a readonly object.
              </dd>
            </dl>
          </dd>
          <dt>attribute DOMString pseudoElement</dt>
          <dd>
            The pseudo-element including the initial colon(s). For example,
            &lsquo;<code>::after</code>&rsquo;.
            <p>Exceptions:</p>
            <dl class="exceptions">
              <dt>DOMException of type
                  <code>NoModificationAllowedError</code></dt>
              <dd>
                Raised on setting if this object is a readonly object.
              </dd>
            </dl>
          </dd>
        </dl>
        <div class="feedbackWanted">
          <p>
            This is an interface that may be useful in other specifications and
            so there are a few considerations to bear in mind:
          </p>
          <ul>
            <li>
              <p>
                Currently no validation is performed at all.
                You can set <code>pseudoElement</code> to
                &lsquo;<code>::batman</code>&rsquo; and we'll just ignore it
                when compositing (still need to define this).
              </p>
              <p>
                This is in order to provide better fallback.
                For example, if a UA doesn't support a particular pseudo-element
                it will still run the animation in terms of occupying time and
                firing events.
                There simply won't be any visual effect.
              </p>
              <p>
                Also, we have a general pattern in this specification that
                constructors don't throw.
              </p>
              <p>
                So while this works for this API, is this behavior useful in
                other specifications?
              </p>
            </li>
            <li>
              <p>
                The other issue is that we could just make <a>PseudoElement</a>
                have an optional <code>pseudoElement</code> attribute and use
                that everywhere instead of a union of <a>Element</a> or
                <a>PseudoElement</a> (see <a>AnimationTarget</a>).
              </p>
              <p>
                The reason we don't is that it complicates the 99% case where
                you're not using pseudo-elements. For example, you have to type
                <code>anim.effect.targetElement.element</code> which is
                what so many people don't like about SVG.
              </p>
              <p>
                So, again, this works for this specification, but is it ok for
                others?
              </p>
            </li>
            <li>
              While we're at it, should we enforce using double-colons somehow?
            </li>
          </ul>
        </div>
        <section>
          <h4>The <a>AnimationTarget</a> typedef</h4>
          <div class="idl"
            title="typedef (Element or PseudoElement) AnimationTarget">
            For simplicity, throughout this specification <a>AnimationTarget</a>
            is used wherever either an <a>Element</a> or a <a>PseudoElement</a>
            can be used.
          </div>
        </section>
      </section>
    </section>

    <section>
      <h2>Timing animations</h2>
      <section class="informative">
        <h3>The animation interval</h3>
        <p>
          The period that an animation is animating is called the
          <dfn>animation interval</dfn>.
          Each animation has only one such interval.
        </p>
        <p>
          The lower bound of the animation interval is determined by the
          <dfn>start time</dfn> of the animation but may be shifted by
          a <dfn>start delay</dfn> on the animation.
        </p>
        <p>
          The upper bound of the interval is determined by the <a>animation
          duration</a>.
        </p>
        <p>
          The relationship between the <a>start time</a>, <a>start delay</a>,
          and <a>animation duration</a> is illustrated below.
        </p>
        <div class="figure">
          <img src="img/animation-interval-examples.svg" width="600">
        </div>
        <p class="caption">
          Examples of the effect of the <a>start delay</a> on the endpoints of
          the <a>animation interval</a>.<br>
          (a) An animation with no delay; the start time and start of
          animation are coincident.<br>
          (b) An animation with a positive delay; the start of
          animation is deferred by the delay.<br>
          (c) An animation with a negative delay; the start of
          animation is brought forward by the delay.
        </p>
      </section>
      <section class="informative">
        <h3>Animation fill behavior</h3>
        <p>
          Outside of the <a>animation interval</a>, an animation may still
          affect its target depending on its <dfn>fill mode</dfn>.
          The different modes are as follows:
        </p>
        <dl>
          <dt>none</dt>
          <dd>
            The animation does not affect its target outside of the
            <a>animation interval</a>.
          </dd>
          <dt>forwards</dt>
          <dd>
            For times that occur later than the <a>animation interval</a>, the
            animation will continue to apply to its target the
            animation value that was used at the end of the <a>animation
            interval</a>.

            For times that occur before the <a>animation interval</a>, the
            animation will not affect its target.
          </dd>
          <dt>backwards</dt>
          <dd>
            For times that occur before the <a>animation interval</a>, the
            animation will apply the same animation value that will be used at
            the start of the <a>animation interval</a>.

            For times that occur later than the <a>animation interval</a>, the
            animation will not affect its target.
          </dd>
          <dt>both</dt>
          <dd>
            For times that occur before the <a>animation interval</a>, the
            backwards fill behavior is used.

            For times that occur after the <a>animation interval</a>, the
            forwards fill behavior is used.
          </dd>
        </dl>
        <p>
          Some examples of the these fill modes are illustrated below.
        </p>
        <div class="figure">
          <img src="img/animation-state-and-fill-behavior.svg" width="600">
        </div>
        <p class="caption">
          Examples of various fill modes and the animation states produced.<br>
          (a) fill mode &lsquo;none&rsquo;. The animation has no effect outside
              its animation interval.<br>
          (b) fill mode &lsquo;forwards&rsquo;. After the animation interval has
              finished, the animation continues to apply a fill value to the
              target.<br>
          (c) fill mode &lsquo;backwards&rsquo;. The animation applies a fill
              value to its target until the start of the animation
              interval.<br>
          (d) fill mode &lsquo;both&rsquo;. Both before and after the animation
              interval the animation applies a fill value to its target.
        </p> 
        <p>
          At a given time, it is possible to describe an animation as <dfn>in
          effect</dfn> if either (a) the time falls within the animation's
          <a>animation interval</a>, or (b) the fill mode of the animation
          causes it to apply a fill mode to its target at the given time.
        </p>
        <p>
          The normative definition of fill behavior is incorporated in the
          calculation of the <a>animation time</a> in <a
          href="#calculating-the-animation-time" class="sectionRef"></a>.
        </p>
        <p class="note">
          Note that setting a fill mode has no bearing on the endpoints of the
          <a>animation interval</a>.
          However, the fill mode <em>does</em> have an effect on the
          calculation of the <a>animation time</a> and consequently the
          <a>iteration time</a> since these are defined only when the animation
          is <a>in effect</a>.
        </p>
      </section>
      <section class="informative">
        <h3>Animation repeat behavior</h3>
        <p>
          It is possible to specify that an animation's effect should repeat
          a fixed number of times or even indefinitely.
          This repetition occurs <em>within</em> the <a>animation
          interval</a>.
          The span of time during which a single repetition takes place is
          called an <dfn>iteration interval</dfn>.
        </p>
        <p>
          Unlike the <a>animation interval</a>, an animation can have multiple
          <a>iteration interval</a>s although typically only the interval
          corresponding to the <a>current iteration</a> is of interest.
        </p>
        <p>
          The length of a single iteration is called the <a>iteration
          duration</a>. Comparing the <a>iteration duration</a> and the
          <a>animation duration</a> we have:
        </p>
        <dl>
          <dt>Iteration duration</dt>
          <dd>
            The time taken for a single iteration of the animation to complete.
          </dd>
          <dt>Animation duration</dt>
          <dd>
            The time taken for the entire animation effect to complete,
            including repetitions.
            This may be longer or shorter than the iteration duration.
          </dd>
        </dl>
        <p>
          The relationship between the <a>iteration duration</a> and
          <a>animation duration</a> is illustrated below.
        </p>
        <div class="figure">
          <img src="img/iteration-intervals.svg" width="600">
        </div>
        <p class="caption">
          A comparison of the iteration and animation durations for an animation
          with an iteration count of 2.5.
          Note that the iteration duration for the final iteration does not
          change, it is simply cut-off by the animation duration.
        </p>
      </section>
      <section class="informative">
        <h3>Time spaces</h3>
        <p>
          Times in Web Animations are relative to some point of reference. These
          different points of reference produce different time spaces.
        </p>
        <p>
          This can be compared to coordinate spaces as used in computer
          graphics.
          The zero time of a time space is analogous to the origin of
          a coordinate space.
        </p>
        <p>
          Within Web Animations, some of the common time spaces are:
        </p>
        <dl>
          <dt><dfn>Document time space</dfn></dt>
          <dd>
            A time space whose zero time is the start time of the document
            timeline as defined in <a href="#start-of-the-timeline"
            class="sectionRef"></a>.
          </dd>
          <dt><dfn>Item time space</dfn></dt>
          <dd>
            A time space whose zero time is the start of the animation's
            <a>start time</a>.<br>
          </dd>
          <dt><dfn>Animation time space</dfn></dt>
          <dd>
            A time space whose zero time is the beginning of the animation's
            <a>animation interval</a>.<br>
          </dd>
          <dt><dfn>Iteration time space</dfn></dt>
          <dd>
            A time space whose zero time is the beginning of the <a>current
            iteration</a>.
          </dd>
        </dl>
        <p>
          In addition to these time spaces, when animation groups are used (see
          <a href="#grouping-and-synchronization" class="sectionRef"></a>) we
          can talk about the <dfn>parent iteration time space</dfn>.
          The zero time of <a>parent iteration time space</a> is the beginning
          of the parent animation group's <a>current iteration</a>.
          When animation groups are not used, this is equivalent to <a>document
          time space</a>.
        </p>
        <p>
          Typically, <a>item time space</a> is used for operations confined to
          a single animation such as <a href="#seeking-a-timed-item">seeking</a>
          and <a href="pausing-a-timed-item">pausing</a> whilst <a>parent
          iteration time space</a> is used to synchronize animations in a group
          and hence is the time space used to represent an animation's start and
          end time.
          <a>Animation time space</a> is not used directly in the Web Animations
          interfaces.
        </p>
        <p>
          Some of these time spaces are illustrated below.
        </p>
        <div class="figure">
          <img src="img/time-spaces.svg" width="600">
        </div>
        <p class="caption">
          A comparison of item time, animation time, and iteration time for an
          animation with a iteration duration of 1s and an iteration count of
          2.5.
        </p>
        <p class="note">
          Note that while the time spaces themselves are not bounded, Web
          Animations defines <a>animation time</a> and <a>iteration
          time</a> such that they are clamped to a set range as shown in the
          diagram.
          For example, whilst a time of -1 second is a valid time in
          <a>animation time space</a>, the procedure for calculating the
          <a>animation time</a> defined in <a
          href="#calculating-the-animation-time" class="sectionRef"></a> will
          never return a negative value.
        </p>
      </section>
      <section class="informative">
        <h3>Interval timing</h3>
        <p>
          For intervals of time, Web Animations uses an endpoint-exclusive
          timing model. This means that whilst the begin time of an interval
          is included in the interval, the end time time is not. In interval
          notation this can written <code>[begin,end)</code>. This model
          provides sensible behavior when intervals are repeated and sequenced
          since there is no overlap between the intervals.
        </p>
        <p>
          In the examples below, for the repeated animation, at animation time
          1s, the iteration time is 0.
          For the sequenced animation, in the absence of any fill mode,
          at parent iteration time 1s, only animation B can affect its target;
          there is no overlap.
        </p>
        <div class="figure">
          <img src="img/endpoint-exclusive-timing.svg" width="600">
        </div>
        <p class="caption">
          Illustration of end-point exclusive timing. For both repeated and
          sequenced animations there is no overlap at the boundaries between
          intervals.
        </p>
        <p>
          An exception to this behavior is that when performing a <a
          href="#animation-fill-behavior">fill</a>, if the fill begins at an
          interval endpoint, the endpoint is used.
          This behavior falls out of the algorithm given in <a
          href="#calculating-the-unscaled-iteration-time"
          class="sectionRef"></a> and is illustrated below.
        </p>
        <div class="figure">
          <img src="img/endpoint-exclusive-timing-and-fill.svg" width="600">
        </div>
        <p class="caption">
          After one iteration, the first frame of the animation is shown, but
          after two iterations (and thereonwards), the last frame is shown due
          to the special behavior defined when an animation fills.
        </p>
      </section>
      <section>
        <h3>Specifying timing properties</h3>
        <p>
          Timing properties are collected under the <code>Timing</code>
          interface.
        </p>
        <p>
          If this object is attached to a linked <a>Animation</a> or
          <a>AnimationGroup</a> (see <a href="#animation-templates"
          class="sectionRef"></a>) then it is readonly and attempting to set any
          of its properties will result in a DOMException of type
          <code>NoModificationAllowedError</code> being thrown.
          In order to modify the properties of a readonly object, it is
          necessary to first call the <code>unlink</code> method on the
          corresponding <a>Animation</a> or <a>AnimationGroup</a> object.
        </p>
        <p>
          When throwing a DOMException as a result of attempting to set
          a readonly property, <a>user agent</a>s that provide debugging
          feedback SHOULD also provide feedback indicating the reason that this
          object is readonly and the remedy described above.
        </p>
        <section>
          <h4>The <code>Timing</code> interface</h4>
          <dl title="interface Timing" class="idl">
            <dt>Constructor ()</dt>
            <dd>
              <p>
                Creates a new <a>Timing</a> object using the supplied
                parameters.
              </p>
              <p>
                In most cases the members of the <code>params</code>
                <a>TimingDictionary</a> can be assigned directly to the property
                in the <a>Timing</a> interface of the same name.
              </p>
              <p>
                The one exception is the <code>timingFunction</code> member
                which in a <a>TimingDictionary</a> value can also be set to
                a <code>DOMString</code>.
                In this case, the <code>DOMString</code> is first passed to
                <a
                href="#widl-TimingFunction-createFromString-TimingFunction-DOMString-spec"
                class="idlType"><code>TimingFunction.createFromString</code></a> and
                the returned <a>TimingFunction</a> is assigned to the
                <code>timingFunction</code> property of the new <a>Timing</a>
                object.
              </p>
              <p>
              </p>
              <div class="issue">
                <p>
                  Should we make this fail silently here?
                  Which is better from a forwards compatibility standpoint?
                </p>
                <p>
                  For example:
                </p>
                <blockquote>
                  If any of the values specified on <code>params</code> is
                  invalid such that setting the corresponding <a>Timing</a>
                  property would trigger an exception, the property is set to
                  the default value as specified on the
                  <code>TimingDictionary</code> definition.
                  User agents that provide a debugging feedback SHOULD indicate
                  that an unrecognized or invalid value was encountered.
                </blockquote>
              </div>
              <p>
                Exceptions:
              </p>
              <dl class="exceptions">
                <dt>DOMException of type <code>IndexSizeError</code></dt>
                <dd>
                  Raised if any of the values specified on <code>params</code>
                  is out of range.
                </dd>
                <dt>DOMException of type <code>SyntaxError</code></dt>
                <dd>
                  Raised if <code>params.timingFunction</code> is set to
                  a string that it not recognized by
                  <a
                  href="#widl-TimingFunction-createFromString-TimingFunction-DOMString-spec"
                  class="idlType"><code>Timing.createFromString</code></a> as
                  indicated by a <code>null</code> return value.
                </dd>
              </dl>
              <dl class="parameters">
                <dt>TimingDictionary params</dt>
                <dd>
                  The properties to set on the new <a>Timing</a> object.
                  Unspecified members take on the default values specified in
                  the <a>TimingDictionary</a> dictionary definition.
                </dd>
              </dl>
            <dd>
            <dt>attribute double startDelay</dt>
            <dd>
              <p>
                The number of seconds which, when added to the timed item's
                <code>startTime</code>, defines the lower bound of the timed
                item's <a>animation interval</a>.
              </p>
              <p>
                A non-normative description of the effect of this property on
                timing is given in <a href="#the-animation-interval"
                class="sectionRef"></a>.
              </p>
              <p>
                Exceptions:
              </p>
              <dl class="exceptions">
                <dt>DOMException of type
                    <code>NoModificationAllowedError</code></dt>
                <dd>
                  Raised on setting if this object is readonly.
                </dd>
              </dl>
            </dd>
            <dt>attribute unrestricted double? duration</dt>
            <dd>
              <p>
                The duration in seconds of a single iteration.
                This may be <code>null</code> in which case the <a>intrinsic
                duration</a> will be used.
                If set, it must be greater than or equal to zero (including
                positive infinity).
              </p>
              <p>
                This property corresponds to the <a>iteration duration</a>
                defined in <a href="#calculating-the-iteration-duration"
                class="sectionRef"></a> and described non-normatively in <a
                href="#animation-repeat-behavior" class="sectionRef"></a>.
              </p>
              <p>
                Exceptions:
              </p>
              <dl class="exceptions">
                <dt>DOMException of type
                    <code>NoModificationAllowedError</code></dt>
                <dd>
                  Raised on setting if this object is readonly.
                </dd>
                <dt>DOMException of type <code>IndexSizeError</code></dt>
                <dd>
                  Raised on setting if the value to set is a real number less
                  than zero.
                </dd>
              </dl>
            </dd>
            <dt>attribute unrestricted double iterationCount</dt>
            <dd>
              <p>
                A real number greater than or equal to zero (including positive
                infinity) representing the number of times to repeat the
                animation.
              </p>
              <p>
                Exceptions:
              </p>
              <dl class="exceptions">
                <dt>DOMException of type
                    <code>NoModificationAllowedError</code></dt>
                <dd>
                  Raised on setting if this object is readonly.
                </dd>
                <dt>DOMException of type <code>IndexSizeError</code></dt>
                <dd>
                  Raised on setting if the value to set is a real number less
                  than zero.
                </dd>
              </dl>
            </dd>
            <dt>attribute double iterationStart</dt>
            <dd>
              <p>
                A finite real number greater than or equal to zero representing
                the number of iterations into the animation at which to begin.
                For example, a value of 0.5 would cause the animation to begin
                half-way through the first iteration.
              </p>
              <p>
                The <code>iterationCount</code> is effectively <em>added</em> to
                the <code>iterationStart</code> such that an animation with an
                <code>iterationStart</code> of &lsquo;0.5&rsquo; and
                <code>iterationCode</code> of &lsquo;2&rsquo; would still
                repeat twice however it would begin and end half-way through
                the animation's <a>iteration interval</a>.
              </p>
              <p>
                Setting the <code>iterationStart</code> to a value greater than
                or equal to one is typically only useful in combination with an
                animation effect that has an <code>accumulateOperation</code>
                other than &lsquo;replace&rsquo;.
              </p>
              <p>
                Exceptions:
              </p>
              <dl class="exceptions">
                <dt>DOMException of type
                    <code>NoModificationAllowedError</code></dt>
                <dd>
                  Raised on setting if this object is readonly.
                </dd>
                <dt>DOMException of type <code>IndexSizeError</code></dt>
                <dd>
                  Raised on setting if the value to set is a real number less
                  than zero.
                </dd>
              </dl>
            </dd>
            <dt>attribute double playbackRate</dt>
            <dd>
              <p>
                A real number that acts as a multiplier on the item's rate of
                play.
                For example, a value of 2.0 will cause the item to run at twice
                its usual speed.
                A value of -1.0 will cause the item to play backwards.
                The <code>playbackRate</code> is applied to the item's
                <a>animation time</a> and hence has no effect on the <a>start
                time</a> (see <a href="#time-spaces" class="sectionRef"></a>).
              </p>
              <p>
                Setting this attribute will affect the item's <a>intrinsic
                animation duration</a>.
              </p>
              <p>
                Exceptions:
              </p>
              <dl class="exceptions">
                <dt>DOMException of type
                    <code>NoModificationAllowedError</code></dt>
                <dd>
                  Raised on setting if this object is readonly.
                </dd>
              </dl>
            </dd>
            <dt>attribute PlaybackDirection direction</dt>
            <dd>
              <p>
                Direction behavior as specified by one of the
                <a>PlaybackDirection</a> enumeration values.
              </p>
              <p>
                Exceptions:
              </p>
              <dl class="exceptions">
                <dt>DOMException of type
                    <code>NoModificationAllowedError</code></dt>
                <dd>
                  Raised on setting if this object is readonly.
                </dd>
              </dl>
            </dd>
            <dt>attribute TimingFunction? timingFunction</dt>
            <dd>
              An optional timing function used to scale input time to produce
              timing effects such as easing behavior.
              See <a href="#scaling-the-time" class="sectionRef"></a>.
            </dd>
            <dt>attribute FillMode fillMode</dt>
            <dd>
              <p>
                The <a>fill mode</a> as specified by one of the <a>FillMode</a>
                enumeration values.
              </p>
              <p>
                Exceptions:
              </p>
              <dl class="exceptions">
                <dt>DOMException of type
                    <code>NoModificationAllowedError</code></dt>
                <dd>
                  Raised on setting if this object is readonly.
                </dd>
              </dl>
            </dd>
            <dt>Timing clone ()</dt>
            <dd>
              <p>
                Creates a new <a>Timing</a> object with each of its properties
                set to the same value as this object with the exception of the
                <code>timingFunction</code> property which is set to
                <code>timingFunction.clone()</code>.
              </p>
            </dd>
          </dl>
        </section>
        <section>
          <h4>The <code>FillMode</code> enumeration</h4>
          <p>A non-normative description of these modes is given in
             <a href="#animation-fill-behavior" class="sectionRef"></a>.</p>
          <dl title="enum FillMode" class="idl">
            <dt>none</dt>
            <dd>
              No fill.
            </dd>
            <dt>forwards</dt>
            <dd>
              Fill forwards.
            </dd>
            <dt>backwards</dt>
            <dd>
              Fill backwards.
            </dd>
            <dt>both</dt>
            <dd>
              Fill backwards and forwards.
            </dd>
          </dl>
        </section>
        <section>
          <h4>The <code>PlaybackDirection</code> enumeration</h4>
          <dl title="enum PlaybackDirection" class="idl">
            <dt>normal</dt>
            <dd>
              All iterations are played as specified.
            </dd>
            <dt>reverse</dt>
            <dd>
              All iterations are played in the reverse direction from the way
              they are specified.
            </dd>
            <dt>alternate</dt>
            <dd>
              Even iterations are played as specified, odd iterations are played
              in the reverse direction from the way they are specified.
            </dd>
            <dt>alternate-reverse</dt>
            <dd>
              Even iterations are played in the reverse direction from the way
              they are specified, odd iterations are played as specified.
            </dd>
          </dl>
        </section>
        <section>
          <h4>The <code>TimingDictionary</code> dictionary</h4>
          <p>
            To simplify creation of <a>Timing</a> objects
            a <code>TimingDictionary</code> can be used.
          </p>
          <p>
            Except where otherwise noted, the acceptable values for each
            property and their meanings are defined in the <a>Timing</a>
            interface.
          </p>
          <dl title="dictionary TimingDictionary" class="idl">
            <dt>double startDelay = 0</dt>
            <dd>
              <p>
                The number of seconds from a timed item's <code>startTime</code>
                to the start of the <a>animation interval</a>.
                See <a href="#widl-Timing-startDelay"
                class="idlType"><code>startDelay</code></a> on the <a>Timing</a>
                interface.
              </p>
            </dd>
            <dt>unrestricted double? duration = null</dt>
            <dd>
              <p>
                The duration in seconds of a single iteration, that is, the
                <a>iteration duration</a>.
                See <a href="#widl-Timing-duration"
                class="idlType"><code>duration</code></a> on the <a>Timing</a>
                interface.
              </p>
            </dd>
            <dt>unrestricted double iterationCount = 1.0</dt>
            <dd>
              <p>
                The number of times to repeat the item.
                See <a href="#widl-Timing-iterationCount"
                class="idlType"><code>iterationCount</code></a> on the
                <a>Timing</a> interface.
              </p>
            </dd>
            <dt>double iterationStart = 0.0</dt>
            <dd>
              <p>
                The number of iterations into the item at which to begin.
                See <a href="#widl-Timing-iterationStart"
                class="idlType"><code>iterationStart</code></a> on the
                <a>Timing</a> interface.
              </p>
            </dd>
            <dt>double playbackRate = 1.0</dt>
            <dd>
              <p>
                A multiplier applied to the inherited time potentially causing
                the item to run at a different rate to its natural speed.
                See <a href="#widl-Timing-playbackRate"
                class="idlType"><code>playbackRate</code></a> on the
                <a>Timing</a> interface.
              </p>
            </dd>
            <dt>PlaybackDirection direction = "normal"</dt>
            <dd>
              <p>
                The direction in which animation proceeds, e.g. "reverse".
                See <a href="#widl-Timing-direction"
                class="idlType"><code>direction</code></a> on the <a>Timing</a>
                interface.
              </p>
            </dd>
            <dt>(DOMString or TimingFunction)? timingFunction = null</dt>
            <dd>
              <p>
                An optional timing function used to scale the time to produce
                easing effects and the like.
              </p>
              <p>
                Unlike the <a>Timing</a> interface, the member here may be set
                to either a <a>TimingFunction</a> object or
                a <code>DOMString</code> corresponding to one of the values
                recognized by <a
                href="#widl-TimingFunction-createFromString-TimingFunction-DOMString-spec"
                class="idlType"><code>Timing.createFromString</code></a>.
              </p>
            </dd>
            <dt>FillMode fillMode = "forwards"</dt>
            <dd>
              <p>
                The <a>fill mode</a> of the animation.
                See <a href="#widl-Timing-fillMode"
                class="idlType"><code>fillMode</code></a> on the <a>Timing</a>
                interface.
              </p>
              <p class="note">
                Note that in both CSS Animations [[CSS3-ANIMATIONS]] and SVG
                [[SVG112]] the default fill mode is "none".
                Web Animations differs in this regard since it was determined
                that when generating animations from script forwards filling is
                the more commonly-desired behavior.
              </p>
              <p class="issue">
                Some feedback suggests the default here should be "both".
              </p>
            </dd>
          </dl>
        </section>
      </section>
      <section>
        <h3>The <code>TimedItem</code> interface</h3>
        <p>
          The application of the timing properties specified in
          a <code>Timing</code> object to an actor in the animation timeline
          is represented by the <code>TimedItem</code> interface.
        </p>
        <dl title="interface TimedItem : EventTarget" class="idl">
          <dt>attribute Timing timing</dt>
          <dd>
            <p>
              The timing parameters for this item.
            </p>
            <p>
              Exceptions:
            </p>
            <dl class="exceptions">
              <dt>DOMException of type
                  <code>NoModificationAllowedError</code></dt>
              <dd>
                Raised on setting if this object is linked to a template (see <a
                href="#animation-templates" class="sectionRef"></a>).
              </dd>
            </dl>
          </dd>
          <dt>attribute double? currentTime</dt>
          <dd>
            <p>
              Returns the effective item time of the timed item.
            </p>
            <p>
              This differs from the definition of <a>item time</a> used
              elsewhere in the model in that when the parent iteration time is
              <code>null</code> (e.g. because <code>parentGroup</code> is
              <code>null</code>, or because the parent is not <a>in effect</a>)
              a parent time of zero is used.
              This allows the item to be seeked prior to being attached to
              a group.
            </p>
            <p>
              The value returned is calculated as follows:
            </p>
            <blockquote>
              <code>currentTime =
                    <a>effective parent time</a> - startTime - timeDrift</code>
            </blockquote>
            <p>
              Setting this value performs a seek operation according to the
              steps described in described in <a href="#seeking-a-timed-item"
              class="sectionRef"></a>.
            </p>
          </dd>
          <dt>attribute unrestricted double animationDuration</dt>
          <dd>
            <p>
              The length in seconds of the <a>animation interval</a>.
            </p>
            <p>
              Initially, this attribute will reflect the <a>intrinsic animation
              duration</a>.
              Changes to the model that cause the <a>intrinsic animation
              duration</a> to change are reflected in the value returned here.
            </p>
            <p>
              The <a>instrinsic animation duration</a> may be overridden by
              setting this attribute to any real number.
              Setting this attribute to <code>undefined</code> has the effect of
              clearing the override value so that the attribute returns to
              reflecting the <a>intrinsic animation duration</a>. 
            </p>
            <p>
              Exceptions:
            </p>
            <dl class="exceptions">
              <dt>DOMException of type <code>IndexSizeError</code></dt>
              <dd>
                Raised on setting if the value to set is a real number that is
                less than zero.
              </dd>
            </dl>
          </dd>
          <dt>readonly attribute double? iterationTime</dt>
          <dd>
            <p>
              The time in seconds representing the offset into the iteration
              duration using the steps described in <a
              href="#calculating-the-iteration-time" class="sectionRef"></a>.
              As a result of that definition, this property will be
              non-<code>null</code> if and only if the animation is in
              <a>in effect</a>.
            </p>
            <p>
              This property corresponds to the <a>iteration time</a> described
              in <a href="#time-spaces" class="sectionRef"></a>.
            </p>
            <p class="annotation">
              This is not writeable since doing so would basically require doing
              a reverse conversion from the value to set into to item time space
              and then updating the <code>currentTime</code> accordingly.
              However, that's not possible since timing functions may be applied
              and some of them are not invertible.
            </p>
          </dd>
          <dt>readonly attribute unsigned long? currentIteration</dt>
          <dd>
            The current iteration index beginning with zero for the first
            iteration as described in <a
              href="#calculating-the-current-iteration" class="sectionRef"></a>.
          </dd>
          <dt>readonly attribute unrestricted double duration</dt>
          <dd>
            <p>
              The <a>iteration duration</a> calculated for this item.
              If <code>timing.duration</code> is set and greater than or
              equal to zero, this will match <code>timing.duration</code>.
              Otherwise, this will reflect the calculated <a>intrinsic
              duration</a>.
            </p>
            <p>
              This property corresponds to the <a>iteration duration</a>
              defined in <a href="#calculating-the-iteration-duration"
              class="sectionRef"></a> and described non-normatively in <a
              href="#animation-repeat-behavior" class="sectionRef"></a>.
            </p>
          </dd>
          <dt>attribute double startTime</dt>
          <dd>
            <p>
              The time which, when combined with the
              <code>timing.startDelay</code>, defines the lower bound of the
              <a>animation interval</a>.
              It is expressed in seconds in the <a>iteration time space</a> of
              <code>parentGroup</code>.
            </p>
            <p>
              When the parent animation group is a sequence group, any
              previously set value set for <code>startTime</code> is ignored and
              instead the value of this property is determined by the procedure
              defined in <a
              href="#the-start-time-of-children-of-a-sequence-animation-group"
              class="sectionRef"></a>.
              Furthermore, attempts to set this property will raise an
              DOMException of type <code>InvalidStateError</code>.
              If this item is later made the child of a parallel animation
              group, any previously set value will be restored.
            </p>
            <p>
              This property corresponds to the <a>start time</a> described in <a
              href="#the-animation-interval" class="sectionRef"></a>.
            </p>
            <p>
              Exceptions:
            </p>
            <dl class="exceptions">
              <dt>DOMException of type <code>InvalidStateError</code></dt>
              <dd>
                Raised on setting if <code>parentGroup</code> is a sequence
                animation group (see <a
                href="#the-start-time-of-children-of-a-sequence-animation-group"
                class="sectionRef"></a>).
              </dd>
            </dl>
          </dd>
          <dt>readonly attribute unrestricted double endTime</dt>
          <dd>
            <p>
              The upper bound of the <a>animation interval</a> expressed in
              seconds relative to the <a>iteration time space</a> of
              <code>parentGroup</code>.
            </p>
            <p>
              The <code>endTime</code> is calculated as follows:
            </p>
            <dl class="switch">
              <dt>If <code>locallyPaused</code> is <code>true</code>,</dt>
              <dd>
                The <code>endTime</code> is positive infinity.
              </dd>
              <dt>Otherwise,</dt>
              <dd>
                The <code>endTime</code> is the result of evaluating
                <code>startTime + timing.startDelay +
                      animationDuration + timeDrift</code>.
              </dd>
            </dl>
            <p class="note">
              Note that while the <code>endTime</code> is read-only, it can be
              set indirectly by overriding the <code>animationDuration</code>
              property.
              For example, to set <code>endTime</code> to time <var>t</var> in
              <a>item time space</a>, set <code>animationDuration</code> to
              <code><var>t</var> - startTime - timing.startDelay</code>.
            </p>
          </dd>
          <dt>readonly attribute AnimationGroup parentGroup</dt>
          <dd>
            The parent animation group.
          </dd>
          <dt>readonly attribute double timeDrift</dt>
          <dd>
            <p>
              The number of seconds that the actual <a>item time</a> of this
              item lags behind its scheduled time as a result of pausing and
              seeking this item.
            </p>
            <p>
              The <code>timeDrift</code> property is both a stored and a
              calculated value.
              When this timed item is paused, the value is calculated from the
              <a>pause start time</a>.
              When the timed item is not paused, the value stored for the
              property is used.
              The stored value is initially zero, and is updated when the item
              is unpaused or seeked.
            </p>
            <p>
              The value returned is as follows:
            </p>
            <dl class="switch">
              <dt>If <code>locallyPaused</code> is <code>false</code>,</dt>
              <dd>
                Return the stored value for this property.
              </dd>
              <dt>If <code>locallyPaused</code> is <code>true</code>,</dt>
              <dd>
                Return the result of 
                <code><a>effective parent time</a> - startTime - <a>pause start
                time</a></code>.
              </dd>
            </dl>
          </dd>
          <dt>attribute boolean locallyPaused</dt>
          <dd>
            <p>
              The pause state of this timed item.
              Initially <code>false</code> except for the document timeline
              where it is initially true (see <a href="#start-of-the-timeline"
              class="sectionRef"></a>).
            </p>
            <p>
              When setting the following procedure is used:
            </p>
            <ol>
              <li>
                Let <var>new value</var> be the value to set.
              </li>
              <li>
                If <var>new value</var> equals <code>locallyPaused</code>,
                return.
              </li>
              <li>
                The next step depends on the current value of
                <code>locallyPaused</code> as follows,
                <dl class="switch">
                  <dt>If <code>locallyPaused</code> is true,</dt>
                  <dd>
                    Record the current value of <code>currentTime</code> as
                    <a>pause start time</a>.
                  </dd>
                  <dt>If <code>locallyPaused</code> is false,</dt>
                  <dd>
                    Set the stored value of <code>timeDrift</code> to the result
                    of evaluating <code><a>effective parent time</a> - startTime
                    - <a>pause start time</a></code>.
                  </dd>
                </dl>
              </li>
              <li>
                Set <code>locallyPaused</code> to <var>new value</var>.
              </li>
            </ol>
            <p class="issue">
              Should this be writeable?
              Once we integrate with media controllers we might want to make
              this writeable only when not associated with a media controller
              much like things currently work in HTML5.
            </p>
            <p class="issue">
              This attribute is at-risk.
              It remains to be seen if it is really needed, or if
              <code>pause()</code>, <code>play()</code>, and
              <code>unpause()</code> are sufficient for most use cases.
            </p>
          </dd>
          <dt>readonly attribute boolean paused</dt>
          <dd>
            Indicates if this element or one of its ancestors is paused.
            This will be <code>true</code> if an only if the
            <code>locallyPaused</code> property of this object <em>or one of its
            ancestor animation groups</em> is <code>true</code>.
          </dd>
          <dt>[TreatNonCallableAsNull] attribute Function? onstart</dt>
          <dd>
            The event handler for the <em>timingstart</em> event
            (see <a href="#timing-events" class="sectionRef"></a>).
          </dd>
          <dt>[TreatNonCallableAsNull] attribute Function? oniteration</dt>
          <dd>
            The event handler for the <em>timingiteration</em> event
            (see <a href="#timing-events" class="sectionRef"></a>).
          </dd>
          <dt>[TreatNonCallableAsNull] attribute Function? onend</dt>
          <dd>
            The event handler for the <em>timingend</em> event
            (see <a href="#timing-events" class="sectionRef"></a>).
          </dd>
          <dt>[TreatNonCallableAsNull] attribute Function? oncancel</dt>
          <dd>
            The event handler for the <em>timingcancel</em> event
            (see <a href="#timing-events" class="sectionRef"></a>).
          </dd>
          <dt>void pause ()</dt>
          <dd>
            Sets the <code>locallyPaused</code> property to <code>true</code> by
            following the procedure described for setting that property.
            <p class="annotation">
              This method is intended to behave in a comparable manner to
              <a
              href="http://dev.w3.org/html5/spec/media-elements.html#media-elements">HTMLMediaElement</a>'s <a
              href="http://dev.w3.org/html5/spec/media-elements.html#dom-media-pause">pause
              method</a>.
            </p>
          </dd>
          <dt>void play ()</dt>
          <dd>
            <p>
              Unpauses this item and, if the item is not currently animating,
              seeks to the beginning of the <a>animation interval</a> by taking
              the following steps.
            </p>
            <ol>
              <li>If <code>currentTime &gt; timing.startDelay
                  + animationDuration</code> and
                  <code>timing.playbackRate &ge; 0</code>, set
                  <code>currentTime</code> to <code>timing.startDelay</code>.</li>
              <li>Set <code>locallyPaused</code> to <code>false</code>.</li>
            </ol>
            <p>
              To unpause the item without seeking, set
              <code>locallyPaused</code> to <code>false</code>.
            </p>
            <p class="annotation">
              This method is intended to behave in a comparable manner to
              <a
              href="http://dev.w3.org/html5/spec/media-elements.html#media-elements">HTMLMediaElement</a>'s <a
              href="http://dev.w3.org/html5/spec/media-elements.html#dom-media-play">play
              method</a>.
            </p>
          </dd>
          <dt>void changePlaybackRate (double playbackRate)</dt>
          <dd>
            <p>
              Updates the speed of the timed item such that it produces a smooth
              change.
            </p>
            <p>
              In particular:
            </p>
            <ul>
              <li>the <a>adjusted animation time</a> will not change,</li>
              <li>if the direction changes, <code>timing.fillMode</code> will be
                  inverted to prevent sudden jumps in output, and</li>
              <li>if the current <a>item time</a> is outside the animation
                  interval the distance from the interval is scaled according
                  to the change in speed.</li>
            </ul>
            <p>
              The smooth change is achieved using the following steps:
            </p>
            <ol>
              <li>Let <var>previous rate</var> be the value of
                  <code>timing.playbackRate</code> prior to updating it.</li>
              <li>Update <code>timing.playbackRate</code> to the passed-in
                  <code>playbackRate</code> parameter.</li>
              <li>Let <var>new rate</var> be the updated value of
                  <code>timing.playbackRate</code>.</li> 
              <li>If either <var>previous rate</var> or <var>new rate</var>
                  are zero, return.
                  <p class="issue">
                    This isn't great. If you set the playback rate to zero at
                    a given time, you expect it to act as if paused at that
                    time.
                    Currently, the only way to get that behavior out of the
                    model is to set the <code>iterationStart</code> and that
                    seems pretty intrusive.
                  </p>
              </li>
              <li>Invert the fill mode as follows:
                <dl class="switch">
                  <dt>If <code>timing.fillMode</code> is
                      <code>"forwards"</code>,</dt>
                  <dd>
                    Set <code>timing.fillMode</code> to
                    <code>"backwards"</code>.
                  </dd>
                  <dt>If <code>timing.fillMode</code> is
                      <code>"backwards"</code>,</dt>
                  <dd>
                    Set <code>timing.fillMode</code> to <code>"forwards"</code>.
                  </dd>
                  <dt>Otherwise,</dt>
                  <dd>Leave <code>timing.fillMode</code> as is.</dd>
                </dl>
              </li>
              <li>If <a>item time</a> is <code>null</code>, return.</li>
              <li>Update the value of <code>animationDuration</code> if
                  necessary (that is, if <code>animationDuration</code> reflects
                  the <a>intrinsic animation duration</a>), applying the
                  updated value for <code>timing.speed</code>.</li>
              <li>Calculate the <var>seek adjustment</var> according to the
                  following formula:
                  <code><var>seek adjustment</var> =
                  (<a>item time</a> - <code>timing.startDelay</code>) *
                  (1 - <var>previous rate</var> / <var>new rate</var>)</code>.
                  </li>
              <li>If the sign of <var>new rate</var> and <var>previous
                  rate</var> differs, subtract from the updated value for the
                  <code>animationDuration</code>.</li>
              <li>Let <var>seek time</var> be the result of the following
                  formula:
                  <code><a>item time</a>
                    - <var>seek adjustment</var></code>.</li>
              <li>Set <code>currentTime</code> to <var>seek time</var>.</li>
            </ol>
            <p>
              Exceptions:
            </p>
            <dl class="exceptions">
              <dt>DOMException of type
                  <code>NoModificationAllowedError</code></dt>
              <dd>
                Raised if this item is a linked item, that is, if
                <code>template</code> is not <code>null</code>
                (see <a href="#animation-templates" class="sectionRef"></a>).
              </dd>
            </dl>
          </dd>
          <dt>void reverse ()</dt>
          <dd>
            <p>
              Reverses this animation such that the reverse animation
              immediately begins reversing from its current point.
              Note that this means that an animation that has yet to begin,
              calling <code>reverse</code> will mean that it never starts.
            </p>
            <li>
              Calculate <var>seek time</var> as follows:
            </li>
              <dl class="switch">
                <dt>If <code>currentTime</code> is null,</dt>
                <dd>
                  Let <var>seek time</var> be zero.
                </dd>
                <dt>If <code>currentTime &lt; timing.startDelay</code>,</dt>
                <dd>
                  Let <var>seek time</var> be
                  <code>timing.startDelay + animationDuration</code>.
                </dd>
                <dt>If <code>currentTime &gt;
                    timing.startDelay + animationDuration</code>,</dt>
                <dd>
                  Let <var>seek time</var> be <code>timing.startDelay</code>.
                </dd>
                <dt>Otherwise,</dt>
                <dd>
                  Let <var>seek time</var> be
                  <code>animationDuration - currentTime - startDelay</code>.
                </dd>
              </dl>
            </li>
            <li>
              Call <code>changePlaybackRate(-timing.playbackRate)</code>.
            </li>
            <li>
              Set <code>currentTime</code> to <var>seek time</var>.
            </li>
            <p>
              Exceptions:
            </p>
            <dl class="exceptions">
              <dt>DOMException of type
                  <code>NoModificationAllowedError</code></dt>
              <dd>
                Raised if this item is a linked item, that is, if
                <code>template</code> is not <code>null</code>
                (see <a href="#animation-templates" class="sectionRef"></a>).
              </dd>
            </dl>
          </dd>
          <dt>void cancel ()</dt>
          <dd>
            <p>
              Removes the timed item from its parent group.
              As a result, the timed item will no longer affect its target.
            </p>
            <p class="annotation">
              We will need to make this actually disassociate from its
              TimeSource once we introduce that concept.
            </p>
            <p>
              When cancelling a timed item, a <em>timingcancel</em> event is
              also fired at the item and its descendents using the following
              procedure:
            </p>
            <ol>
              <li>If <code>parentGroup</code> is <code>null</code>, return
                  immediately.
                  <span class="todo">(Is this right? Should be just dispatch the
                  event anyway with <code>null</code> <code>documentTime</code>
                  and <code>localTime</code>?)</span>
                  </li>
              <li>Record <code>parentGroup.currentTime</code> as <var>local
                  time</var>.</li>
              <li>Record the document time as <var>document time</var>
                  <span class="todo">(the concept of document time will be
                  explained properly once we introduce
                  <a>DocumentTimeSource</a>)</span>.</li>
              <li>Record the <code>currentIteration</code> as <var>iteration
                  index</var>.</li>
              <li>Remove this timed item from <code>parentGroup</code>
                  but do not dispatch a <em>timingend</em> event on this timed
                  item or any of its descendents.</li>
              <li>Dispatch a <em>timingcancel</em> event at this timed item and
                  its descendents with using the stored values for
                  <var>local time</var>, <var>document time</var>, and
                  <var>iteration index</var>.</li>
            </ol>
            <p>
              Exceptions:
            </p>
            <dl class="exceptions">
              <dt>DOMException of type
                  <code>NoModificationAllowedError</code></dt>
              <dd>
                Raised if this item is a linked item, that is, if
                <code>template</code> is not <code>null</code>
                (see <a href="#animation-templates" class="sectionRef"></a>).
              </dd>
            </dl>
            <p class="feedbackWanted">
              Is this exception necessary? It will depend how we approach group
              templates.
            </p>
          </dd>
        </dl>
        <div class="todo">
          <p>
            Do we need a means for getting the startTime etc. in document
            time (i.e. in terms of the root time container)?
          </p>
        </div>
      </section>
      <section>
        <h3>Timing model common definitions</h3>
        <p>
          In order to calculate various properties of the timing model the
          following common definitions are used.
        </p>
        <ul>
          <li><dfn>effective parent time</dfn> =
              <code>parentGroup.iterationTime</code> unless
              <code>parentGroup</code> or <code>parentGroup.iterationTime</code>
              is <code>null</code> in which case it is zero.</li>
        </ul>
      </section>
      <section>
        <h3>Calculating the iteration duration</h3>
        <p>
          The <dfn>iteration duration</dfn> is calculated according to the
          following steps:
        </p>
        <dl class="switch">
          <dt>
            If the <code>timing.duration</code> timing property is set
            to a numerical value greater than or equal to zero (including
            positive infinity),
          </dt>
          <dd>
            return <code>timing.duration</code>.
          </dd>
          <dt>
            Otherwise,
          </dt>
          <dd>
            return the item's <a>intrinsic duration</a>.
          </dd>
        </dl>
        <p>
          The value of an item's <dfn>intrinsic duration</dfn> depends on
          the type of the item.
        </p>
        <p>
          For animations the <a>intrinsic duration</a> is zero.
          The intrinsic duration for animation groups and media items
          is described under <a
      href="#the-intrinsic-duration-of-a-parallel-animation-group"
          class="sectionRef"></a>, <a
      href="#the-intrinsic-duration-of-a-sequence-animation-group"
          class="sectionRef"></a>,
          and <a
          href="#the-intrinsic-duration-of-a-media-item"
          class="sectionRef"></a>.
        </p>
        <div class="informative">
          <p>
            Since the intrinsic duration of an animation is zero, and the
            default <code>fillMode</code> when constructing an
            <code>Animation</code> is <em>forwards</em>, it is possible to
            create animations that simply set a property without any
            interpolation as follows,
          </p>
          <pre class='example sh_javascript'>
new Animation(elem, { display: 'none' });
          </pre>
          <p>
            This is particularly useful in combination with other animations or
            timed items. For example, fading an element before switching
            &lsquo;display&rsquo; to &lsquo;none&rsquo; can be achieved as
            follows,
          </p>
          <pre class='example sh_javascript'>
new SeqGroup(
  [
    new Animation(elem, { opacity: '0%' }, 1),
    new Animation(elem, { display: 'none' })
  ]
);
          </pre>
        </div>
      </section>
      <section>
        <h3>Calculating the intrinsic animation duration</h3>
        <p>
          In order to calculated the <a>intrinsic animation duration</a> we
          first define the <a>repeated duration</a> as follows:
        </p>
        <blockquote>
          <dfn>repeated duration</dfn> =
            <code><a>iteration duration</a> *
                  <a>timing.iterationCount</a></code>
        </blockquote>
        <p>
          The <dfn>intrinsic animation duration</dfn> is calculated according to
          the following steps:
        </p>
        <ol>
          <li>
            If <code>timing.playbackRate</code> is zero, return
            <code>Infinity</code>.
          </li>
          <li>
            Otherwise, return <code><a>repeated duration</a>
            / abs(<code>timing.playbackRate</code>)</code>.
          </li>
        </ol>
      </section>
      <section>
        <h3>Calculating the item time</h3>
        <p>
          The <dfn>item time</dfn> is calculated according to the following
          equation:
        </p>
        <blockquote>
          <code><var>item time</var> = parentGroup.iterationTime
            - startTime - timeDrift</code>
        </blockquote>
        <p>
          If either <code>parentGroup</code> or
          <code>parentGroup.iterationTime</code> is <code>null</code>, the
          <var>item time</var> is <code>null</code>.
        </p>
        <p class="todo">
          Need to define this for the document timeline.
        </p>
      </section>
      <section>
        <h3>Calculating the animation time</h3>
        <p>
          The <dfn>animation time</dfn> is based on the <a>item time</a>
          and <var>start delay</var>.
          It is defined only when the timed item is <a>in effect</a> and is
          calculated according to the following steps:
        </p>
        <ol>
          <li>
            If <a>item time</a> is <code>null</code>, return <code>null</code>.
          </li>
          <li>
            If <code><a>item time</a> &lt; timing.startDelay</code>
            the result depends on the <var>fill mode</var> as follows,
            <dl class="switch">
              <dt>
                If the <var>fill mode</var> is <em>backwards</em> or
                <em>both</em>,
              </dt>
              <dd>
                return zero.
              <dd>
              <dt>
                Otherwise,
              </dt>
              <dd>
                return <code>null</code>.
              </dd>
            </dl>
          </li>
          <li>
            If <code><a>item time</a> &lt;
            timing.startTime + animationDuration</code>, return
            <code><a>item time</a> - timing.startDelay</code>.
          </li>
          <li>
            Otherwise, the result depends on the <var>fill mode</var> as
            follows,
            <dl class="switch">
              <dt>
                If the <var>fill mode</var> is <em>forwards</em> or
                <em>both</em>,
              </dt>
              <dd>
                return <code>animationDuration</code>.
              <dd>
              <dt>
                Otherwise,
              </dt>
              <dd>
                return <code>null</code>.
              </dd>
            </dl>
          </li>
        </ol>
      </section>
      <section>
        <h3>Calculating the iteration time</h3>
        <p>
          The iteration time is calculated by first applying the animation's
          <code>playbackRate</code> and <code>iterationStart</code> properties
          to produce the <a>adjusted animation time</a>
          The <a>adjusted animation time</a> is then divided into intervals
          resulting in the <a>unscaled iteration time</a>.
          Following this, timing manipulations specified on the timed item are
          applied to the <a>unscaled iteration time</a> to produce the
          <a>iteration time</a>.
        </p>
        <section>
          <h4>Calculating the adjusted animation time</h4>
          <p>
            Before the <a>animation time</a> can be converted to an <a>iteration
            time</a> we must factor in the animation's <var>playback rate</var>
            and <var>iteration start</var>.
            This is called the <a>adjusted animation time</a>.
          </p>
          <p>
            In order to calculate the <a>adjusted animation time</a> we first
            define the <a>start offset</a> as follows:
          </p>
          <blockquote>
            <dfn>start offset</dfn> =
              <code>iterationStart * <a>iteration duration</a></code>
          </blockquote>
          <p>
            The <dfn>adjusted animation time</dfn> is calculated according to
            the following steps:
          </p>
          <ol>
            <li>
              If the <a>animation time</a> is <code>null</code>, return
              <code>null</code>.
            </li>
            <li>
              Return the adjusted animation time based on the
              <code>timing.playbackRate</code> as follows,
              <dl class="switch">
                <dt>If <code>timing.playbackRate</code> is negative,</dt>
                <dd>
                Return <code>(<a>animation time</a> -
                              animationDuration) * timing.playbackRate
                        + <a>start offset</a></code>.
                </dd>
                <dt>Otherwise,</dt>
                <dd>
                  Return <code><a>animation time</a> * timing.playbackRate
                  + <a>start offset</a></code>.
                </dd>
            </li>
          </ol>
        </section>
        <section>
          <h4>Calculating the unscaled iteration time</h4>
          <p>
            The <dfn>unscaled iteration time</dfn> is calculated according to
            the following steps:
          </p>
          <ol>
            <li>
              If the <a>item time</a> is <code>null</code>,
              return <code>null</code>.
            </li>
            <li>
              If the <a>iteration duration</a> is zero, return zero.
            </li>
            <li>
              If <code><a>adjusted animation time</a> - <a>start
              offset</a></code> is equal to the <a>repeated duration</a>,
              <code>timing.iterationCount</code> is not zero,
              and <code>(timing.iterationCount + timing.iterationStart)
              % 1</code> is zero,
              return the <a>iteration duration</a>.
            </li>
            <li>
              Otherwise, return <code><a>adjusted animation time</a>
              % <var>iteration duration</var></code>.
            </li>
          </ol>
        </section>
        <section>
          <h4>Applying time manipulations</h4>
          <p>
            The <a>unscaled iteration time</a> is converted into the
            <dfn>iteration time</dfn> using the following steps:
          <ol>
            <li>
              If the <var>unscaled iteration time</var> is <code>null</code>,
              return <code>null</code>.
            </li>
            <li>
              Scale the time as follows:
              <dl class="switch">
                <dt>If <var>timing.timingFunction</var> is
                    a <a>TimingFunction</a> object,</dt>
                <dd>
                  <p>
                    Let <var>scaled iteration time</var> be
                    <code>unscaled iteration time *
                      timing.timingFunction.scaleTime(<var>unscaled iteration
                      time</var> / <a>iteration duration</a>)))</code>.
                  </p>
                </dd>
                <dt>Otherwise,</dt>
                <dd>
                  Let <var>scaled iteration time</var> be <var>unscaled
                  iteration time</var>.
                </dd>
              </dl>
            </li>
            <li>
              Calculate the <var>current direction</var> using the first
              matching condition from the following list:
              <dl class="switch">
                <dt>
                  If the direction is normal,
                </dt>
                <dd>Let the <var>current direction</var> be forwards.</dd>
                <dt>
                  If the direction is reverse,
                </dt>
                <dd>Let the <var>current direction</var> be reverse.</dd>
                <dt>
                  Otherwise,
                </dt>
                <dd>
                  <ol>
                    <li>
                      Let <var>d</var> be the <a>current iteration</a>.
                    </li>
                    <li>
                      If the direction is alternate-reverse increment
                      <var>d</var> by 1.
                    </li>
                    <li>
                      If the animation is not animating, and the
                      <code>animationDuration</code> is a positive multiple of
                      the <a>iteration duration</a> increment <var>d</var>
                      by 1.
                    </li>
                    <li>
                      If <code><var>d</var> % 2 == 0</code>, let the
                      <var>current direction</var> be forwards, otherwise let
                      the <var>current direction</var> be reverse.
                    </li>
                  </ol>
                </dd>
              </dl>
            </li>
            <li>
              If the <var>current direction</var> is forwards then return
              the <var>scaled iteration time</var>.
              <p>
                Otherwise, return the <a>iteration duration</a>
                - <var>scaled iteration time</var>.
              </p>
            </li>
          </ol>
          <p class="note">
            Applying the reverse behavior after applying the timing function
            means that ease-in becomes ease-out on reverse, however it avoids
            jumps in values when reversing part-way.
          </p>
        </section>
        <section>
          <h4>Calculating the time fraction</h4>
          <p>
            The <dfn>time fraction</dfn> is calculated according to the
            following steps:
          </p>
          <dl class="switch">
            <dt>
              If the <a>iteration duration</a> is zero,
            </dt>
            <dd>
              <p>
                the <a>time fraction</a> is as follows.
              </p>
              <dl class="switch">
                <dt>
                  If <a>item time</a> &lt; <code>timing.startDelay</code>,
                </dt>
                <dd>
                  Return the result of recalculating the iteration time using an
                  item time of zero and an iteration duration of 1.
                </dd>
                <dt>
                  Otherwise,
                </dt>
                <dd>
                  Return the result of recalculating the iteration time using an
                  item time of <code>timing.iterationCount</code> and an
                  iteration duration of 1.
                </dd>
              </dl>
            </dd>
            <dt>
              Otherwise,
            </dt>
            <dd>
              Return <a>iteration time</a> / <a>iteration duration</a>.
            </dd>
          </dl>
          <p class="note">
            Since <a href="#scaling-the-time">timing functions</a> are allowed
            to produce output times outside the range [0,1] it is possible that
            the value calculated for a <a>time fraction</a> also lies outside
            this range.
          </p>
        </section>
        <section>
          <h4>Calculating the current iteration</h4>
          <p>
            The <dfn>current iteration</dfn> can be calculated from the
            following steps:
          </p>
          <ol>
            <li>
              If the <a>item time</a> is <code>null</code>, return
              <code>null</code>.
            </li>
            <li>
              If the <a>adjusted animation time</a> is zero, return zero.
            </li>
            <li>
              If the <a>iteration duration</a> is zero, return
              <code>floor(timing.iterationStart + timing.iterationCount)</code>.
            </li>
            <li>
              If the <a>unscaled iteration time</a> equals the <a>iteration
              duration</a>, return <code>timing.iterationStart
              + timing.iterationCount - 1</code>.
            </li>
            <li>
              Return <code>floor(<a>adjusted animation time</a> /
              <a>iteration duration</a>)</code>.
              <p class="note">
                If the <a>iteration duration</a> is infinite, the
                result of <code>floor(<a>adjusted animation time</a> /
                <a>iteration duration</a>)</code> will be zero as defined by
                IEEE 754-2008.
              </p>
            </li>
          </ol>
        </section>
      </section>
      <section>
        <h3>Pausing a timed item</h3>
        <div class="informative">
          <p>
            Timed items may be paused and resumed independently of the parent
            animation group they belong to.
            The effect is that the time of the item lags behind that of its
            parent.
            This lag is called the <var>time drift</var> and acts as an
            additional delay added to the <var>start time</var> of the item.
          </p>
          <p>
            Timed elements that do not have a parent animation group may still
            be paused and resumed.
            However, except for the case of the document timeline, there will be
            no observable effect until the element is attached to a parent
            animation group.
          </p>
        </div>
        <p>
          Pausing and seeking are realised using two additional inputs to the
          timing model, the <dfn>time drift</dfn> which is exposed as the
          <code>timeDrift</code> property on the <a>TimedItem</a> interface, and
          the <dfn>pause start time</dfn> which is internal to the model.
          Both the <var>time drift</var> and <var>pause start time</var> are
          initially zero.
        </p>
        <p>
          The pausing behavior is realised through the specific steps defined
          for calculating and updating the <code>locallyPaused</code> and
          <code>timeDrift</code> properties of the <a>TimedItem</a> interface.
        </p>
      </section>
      <section>
        <h3>Seeking a timed item</h3>
        <div class="informative">
          <p>
            Seeking, like pausing, has the effect of causing a timed item's
            time to drift from that of its parent animation group.
            Consequently, it is also uses the <a>time drift</a> and
            <a>pause start time</a> concepts on which pausing is based.
          </p>
        </div>
        <p>
          Seeking is performed in response to a change to a timed item's
          <code>currentTime</code> property and is realised by adjusting the
          <code>timeDrift</code> property or the internal <a>pause start
          time</a> of the item as follows:
        </p>
        <ol>
          <li>Let <var>seek time</var> be the new value to which
              <code>currentTime</code> should be set.</li>
          <li>The steps for adjusting the item time depend on the state of the
              <code>locallyPaused</code> property as follows:
            <dl class="switch">
              <dt>If <code>locallyPaused</code> is true,</dt>
              <dd>
                Set <a>pause start time</a> to <var>seek time</var>.
              </dd>
              <dt>If <code>locallyPaused</code> is false,</dt>
              <dd>
                Set the stored value for <code>timeDrift</code> to
                the result of evaluating
                <code><a>effective parent time</a> - startTime -
                      <var>seek time</var></code>.
              </dd>
            </dl>
          </li>
        </ol>
        <p class="note">
          Note that the <code>currentTime</code> property is not actually set
          directly but is updated to the seek time as a result of the
          calculation outlined in the decsription of the
          <code>currentTime</code> property on the <a>TimedItem</a> interface.
        </p>
        <p>
          The animation events dispatched when a seek is performed are described
          in <a href="#event-dispatch-during-seeking" class="sectionRef"></a>.
        </p>
      </section>
    </section>

    <section>
      <h2>Scaling the time</h2>
      <div class="informative">
        <p>
          It is often desirable to control the rate at which an animation
          progresses.
          For example, easing the rate of animation can create a sense of
          momentum and produce a more natural effect.
          Conversely, in other situations such as when modelling a discrete
          change, a smooth transition is undesirable and instead it is necessary
          for the animation to progress in a series of distinct steps.
        </p>
        <p>
          For such situations Web Animations provides a variety of timing
          functions that scale the progress of an animation.
          In situations where the timing functions defined here are
          insufficient, it is possible to provide a custom script-based timing
          function.
        </p>
        <p>
          In all cases, timing functions take an input time and produce a scaled
          output time.
        </p>
        <p class="todo">
          Diagram
        </p>
        <p>
          Such timing functions can be applied to an iteration of an animation
          as a whole via the <a>TimedItem</a> interface or to a segment of
          a keyframe animation via the <a>KeyframeAnimationEffect</a>
          interface.
        </p>
      </div>
      <section>
        <h3>The <code>TimingFunction</code> interface</h3>
        <p>
          The timing functions provided by Web Animations share a common
          <a>TimingFunction</a> interface as defined below.
        </p>
        <dl title="interface TimingFunction" class="idl">
          <dt>double scaleTime()</dt>
          <dd>
            <p>
              Takes an input time fraction in the range [0, 1] and applies some
              transformation on the value to produce an output time fraction
              (typically, but not necessarily, also in the range [0, 1]).
            </p>
            <dl class="parameters">
              <dt>double time</dt> <!-- Oh yeah! -->
              <dd>
                The input time fraction.
              </dd>
              <dt>TimedItem? item</dt>
              <dd>
                <p>
                  The <a>TimedItem</a> for which the time scaling operation is
                  being performed.
                </p>
                <p>
                  Some timing functions, for example, may produce different
                  results depending on the animation values involved to produce
                  an even rate of change.
                </p>
                <p>
                  This may be <code>null</code>, for example, when invoked
                  directly by user code for the purpose of testing or re-using
                  the scaling operation in another context.
                </p>
                <p>
                  Implementations of this interface for which there is no
                  meaningful result in the absence of a <a>TimedItem</a> will
                  simply return <code>time</code> unchanged when
                  <code>item</code> is <code>null</code>.
                </p>
              </dd>
            </dl>
          </dd>
          <dt>TimingFunction clone()</dt>
          <dd>
            <p>
              For implementations of this interface that have local state,
              produces an identical but independent copy of this object.
              For implementations without local state, returns the same object.
            </p>
          </dd>
          <dt>static TimingFunction? createFromString(DOMString spec)</dt>
          <dd>
            <p>
              Creates a new <a>TimingFunction</a> object based on a string-based
              specification (e.g. "ease-in").
            </p>
            <p>
              The acceptable values and their meanings are those defined for the
              <a
              href="http://www.w3.org/TR/css3-transitions/#transition-timing-function-property">transition-timing-function</a>
              property in CSS Transitions [[!CSS3-TRANSITIONS]].
            </p>
            <p>
              In addition to the values defined in CSS Transitions, this method
              extends the <code>steps()</code> function notation to allow
              &lsquo;middle&rsquo; as a transition point keyword (e.g.
              <code>steps(3, middle)</code>) corresponding to the
              &lsquo;middle&rsquo; <a>StepPosition</a> value.
              Similarly, the keyword &lsquo;steps-middle&rsquo; is recognized by
              and given the meaning <code>steps(1, middle)</code>.
            </p>
            <p>
              Strings that specify a cubic-bezier timing function result in
              a new <a>SplineTimingFunction</a> being returned.
              Strings that specify a stepping function produce a new
              <a>StepTimingFunction</a>.
            </p>
            <p>
              If <code>spec</code> is unrecognized, <code>null</code> is
              returned.
              User agents that provide debugging feedback SHOULD report the
              unrecognized value.
            </p>
            <p class="issue">
              So the string <code>cubic-bezier(...)</code> produces
              a <a>SplineTimingFunction</a>.
              That's a bit confusing.
              But <code>CubicBezierTimingFunction</code> is a lot to type and
              not very user-friendly.
            </p>
            <p class="issue">
              Should we make the &lsquo;linear&rsquo; keyword return
              <code>null</code> as well?
              If we do, we need to be careful to update the constructor for
              <a>Timing</a> so that it doesn't throw an exception in that case
              (or report anything to the console).
            </p>
          </dd>
        </dl>
      </section>
      <section>
        <h3>Scaling using a cubic Bzier curve</h3>
        <p>
          A common method of producing easing effects is to use a cubic Bzier
          curve to scale the time.
          The endpoints of the curve are fixed at (0,0) and (1,1) while two
          control points <var>P1</var> and <var>P2</var> define the shape of the
          curve.
          Provided the <var>x</var> values of <var>P1</var> and <var>P2</var>
          lie within the range [0,1] such a curve produces a function that is
          used to map input times (the <var>x</var> values) onto output times
          (the <var>y</var> values).
          This arrangement is illustrated below.
        </p>
        <div class="figure">
          <img src="img/cubic-bezier-timing-curve.svg" width="500">
        </div>
        <p class="caption">
          A cubic Bzier curve used as a timing function.<br>
          The shape of the curve is determined by the location of the control
          points <var>P1</var> and <var>P2</var>.<br>
          Input time fractions serve as <var>x</var> values of the curve, whilst
          the <var>y</var> values are the output time fractions.
        </p>
        <p>
          The curves produced by the keywords accepted by the
          <a href="#widl-TimingFunction-createFromString-TimingFunction-DOMString-spec"
          class="idlType"><code>Timing.createFromString</code></a>
          method are illustrated below.
        </p>
        <div class="figure">
          <img src="img/curve-keywords.svg" width="500">
        </div>
        <p class="caption">
          The timing functions produced by each of the keyword values.
        </p>
        <section>
          <h4>The <code>SplineTimingFunction</code> interface</h4>
          <p>
            Cubic bzier curve based timing functions are represented using
            the <code>SplineTimingFunction</code> interface defined below.
          </p>
          <dl title="interface SplineTimingFunction : TimingFunction"
            class="idl">
            <dt>Constructor (sequence&lt;double&gt; points)</dt>
            <dd>
              <p>
                Creates a new <a>SplineTimingFunction</a> object and initializes
                the <code>points</code> member to the passed in list of
                <code>points</code>.
              </p>
              <p class="annotation">
                It would be more convenient for authors if the passed in list of
                points could be longer than four items and we simply read the
                first four items and ignored the rest.
                However, applications may begin to depend on that behavior and
                we could not easily allow this object to take longer lists (to
                represent more complex curves) in the future without adding
                a separate constructor for that purpose.
              </p>
              <p>
                Exceptions:
              </p>
              <dl class="exceptions">
                <dt>DOMException of type <code>IndexSizeError</code></dt>
                <dd>
                  Raised if any of the <var>x</var> values in
                  <code>points</code> is outside the range [0, 1]
                  or if the length of <code>points</code> is not 4 items.
                </dd>
              </dl>
            </dd>
            <dt>attribute sequence&lt;double&gt; points</dt>
            <dd>
              <p>
                A sequence of four real numbers representing the coordinates of
                the two control points in the following sequence
                <var>&lt;p1-x&gt;</var> <var>&lt;p1-y&gt;</var>
                <var>&lt;p2-x&gt;</var> <var>&lt;p2-y&gt;</var>.
              </p>
              <p>
                Each of the <var>x</var> values (i.e. <var>p1-x</var> and
                <var>p2-x</var>) must be in the range [0, 1].
              </p>
              <p>
                Exceptions:
              </p>
              <dl class="exceptions">
                <dt>DOMException of type <code>IndexSizeError</code></dt>
                <dd>
                  Raised on setting if an <var>x</var> value is outside the
                  range [0, 1].
                </dd>
                <dt>DOMException of type
                    <code>InvalidModificationError</code></dt>
                <dd>
                  Raised on attempting to alter the length of
                  <code>points</code>.
                </dd>
              </dl>
            </dd>
            <dt>double scaleTime(double time, TimedItem? item)</dt>
            <dd>
              Applies the timing function produced by the cubic Bzier curve
              with points (0,0), (<code>points[0], points[1]</code>),
              (<code>points[2]</code>, <code>points[3]</code>), (1, 1).
              Returns the resulting <var>y</var> value when the <var>x</var>
              value is <code>max(0, min(1, time))</code>.
            </dd>
            <dt>TimingFunction clone()</dt>
            <dd>
              Returns a copy of this object.
            </dd>
          </dl>
        </section>
      </section>
      <section>
        <h3>Timing in discrete steps</h3>
        <p>
          It is possible to scale an animation's timing so that the animation
          occurs in a series of discrete steps using a stepping function.
        </p>
        <p>
          A stepping function divides the input time into a specified number of
          intervals that are equal in duration.
          The output time, starting at zero, rises by an amount equal to the
          interval duration once during each interval at the transition point
          which may be either the start, midpoint, or end of the interval.
        </p>
        <p>
          In keeping with Web Animation's model for endpoint exclusive interval
          timing (see <a href="#interval-timing" class="sectionRef"></a>), the
          output time at the transition point is the time <em>after</em>
          applying the increase (i.e. the top of the step).
        </p>
        <p>
          Some example step timing functions are illustrated below.
        </p>
        <div class="figure">
          <img src="img/step-timing-func-examples.svg" width="700">
        </div>
        <p class="caption">
          Example step timing functions.
          In each case the domain is the input time fraction whilst the range
          represents the output time fraction produced by the step function.<br>
          The first row shows the function for each transition point when only
          one step is specified whilst the second row shows the same for three
          steps.
        </p>
        <section>
          <h4>The <code>StepPosition</code> enumeration</h4>
          <p>
            The point within a step interval at which the change in value occurs
            is specified using one of the <a>StepPosition</a> enumeration
            values.
          <dl title="enum StepPosition" class="idl">
            <dt>start</dt>
            <dd>
              The change in value occurs at the beginning of the interval.
            </dd>
            <dt>middle</dt>
            <dd>
              The change in value occurs at the midpoint of the interval.
            </dd>
            <dt>end</dt>
            <dd>
              The change in value occurs at the end of the interval.
            </dd>
          </dl>
        </section>
        <section>
          <h4>The <code>StepTimingFunction</code> interface</h4>
          <p>
            Step timing functions are represented by the
            <a>StepTimingFunction</a> interface.
          </p>
          <dl title="interface StepTimingFunction : TimingFunction" class="idl">
            <dt>Constructor (unsigned integer numSteps,
                             optional StepPosition position = 'end')</dt>
            <dd>
              <p>
                Creates a new <a>StepTimingFunction</a> with the specified
                number of steps and transition point.
              </p>
              <p>
                Exceptions:
              </p>
              <dl class="exceptions">
                <dt>DOMException of type <code>IndexSizeError</code></dt>
                <dd>
                  Raised if <code>numSteps</code> is zero.
                </dd>
              </dl>
            </dd>
            <dt>attribute unsigned integer numSteps</dt>
            <dd>
              <p>
                A number greater than or equal to one representing the number of
                steps in the function.
              </p>
              <p>
                Exceptions:
              </p>
              <dl class="exceptions">
                <dt>DOMException of type <code>IndexSizeError</code></dt>
                <dd>
                  Raised on setting if the number of steps is zero.
                </dd>
              </dl>
            </dd>
            <dt>attribute StepPosition position</dt>
            <dd>
              The point within each interval at which the change in value
              occurs.
            </dd>
            <dt>double scaleTime(double time, TimedItem? item)</dt>
            <dd>
              Returns the value of applying the step function defined by
              <a>numSteps</a> and <a>position</a> with input <var>time</var>.
              The behavior of the step function is described in <a
              href="#timing-in-discrete-steps" class="sectionRef"></a>.
            </dd>
            <dt>TimingFunction clone()</dt>
            <dd>
              Returns a copy of this object.
            </dd>
          </dl>
        </section>
      </section>
      <section>
        <h3>The <code>SmoothTimingFunction</code> interface</h3>
        <div class="todo">
          <p>
            Need help from someone who knows math.
            We'd like to be able to have a function with many extrema.
            Ideally, something like Catmull-Rom curves would be great where you
            could just say:
          </p>
          <p>
            <tt>[ 0: 0, 0.7: 1, 0.8: 0.9, 1: 1 ]</tt>
          </p>
          <p>
            And you'd get a smooth curve that goes to the full value and bounces
            back a bit then finishes.
          </p>
          <p>
            The trouble is that Catmull-Rom curves won't necessarily give you
            a function even if you sort the <var>x</var> values.
          </p>
        </div>
        <dl title="
[Constructor (sequence&lt;double&gt; points)]
          interface SmoothTimingFunction : TimingFunction" class="idl">
          <dt>attribute sequence&lt;double&gt; points</dt>
          <dd>
            TBD
          </dd>
        </dl>
      </section>
    </section>

    <section>
      <h2>Grouping and synchronization</h2>
      <div class="informative">
      <p>
        While it is possible to set the timing properties of animations
        individually, it is often useful to bundle animations together and
        control their timing as a group.
      </p>
      <p>
        This can be used to share common timing properties as illustrated below:
      </p>
      <div class="figure">
        <img src="img/grouping-delay.svg" width="800">
      </div>
      <p class="caption">
        Using groups to share common timing properties.<br>
        (a) Shows setting a delay of 5 seconds on individual animations.<br>
        (b) Produces the same effect by setting the delay on the group.
      </p>
      <p>
        As well as sharing timing information, by grouping animations together
        they can be seeked, paused, and stopped as a unit.
      </p>
      </div>
      <section class="informative">
        <h3>Relationship of group time to child time</h3>
        <p>
          The timing of the children of a group is based on the timing of the
          group. Specifically, times for the children are based on the parent's
          <em>iteration time</em>. That is, the children animate <em>inside</em>
          an iteration of the parent.
        </p>
        <p>
          As an example, consider repetition. If a group has an iteration count
          of 2, then the children of of the group will all play twice since they
          effectively play <em>inside</em> the group's iterations.
        </p>
        <div class="figure">
          <img src="img/grouping-repetition.svg" width="600">
        </div>
        <p class="caption">
          Since children of an animation group base their timing on the group's
          <var>iteration time</var>, when the group repeats, the children play
          again.
        </p>
        <p>
          If an iteration count is specified for the children of a group as well
          as for the group the effect is as if the iteration count of the group
          was multiplied with the iteration count of the children.
        </p>
        <div class="figure">
          <img src="img/grouping-repetition-and-animation-repetition.svg"
            width="600">
        </div>
        <p class="caption">
          Specifying an iteration count of 2 on an animation group and an
          iteration count of 3 on one of its children results in that child
          playing 6 times.
        </p>
        <p>
          A further result of the children of a group basing their timing on the
          group's <var>iteration time</var> is that they cannot animate outside
          of the group's <a>animation interval</a>.
          This is because the <var>iteration time</var> of a group will not
          change outside its animation interval.
          This allows groups to clip the playback of their children.
        </p>
        <div class="figure">
          <img src="img/grouping-clipping.svg" width="600">
        </div>
        <p class="caption">
          In the first instance, an animation has a negative delay and an
          infinite iteration count.<br>
          However, when a similar animation is placed inside a group with
          a specified duration it has the effect of clipping the animation's
          duration.
        </p>
        <p>
          Some further consequences of group children basing their timing on
          their parent group's <var>iteration time</var> are:
        </p>
        <ul>
          <li>
            Setting the playback rate of an animation group will speed up or
            slow down all children.
          </li>
          <li>
            Changing the playback direction of an animation group will change
            the direction of all children.
          </li>
          <li>
            Applying a timing function to an animation group will affect the
            playback rate of all children.
          </li>
        </p>
      </section>
      <section class="informative">
        <h3>Types of groups</h3>
        <p>
          Groups can be used to provide synchronization behavior for its
          children.
          For example, one type of group runs its children in parallel, whilst
          another type runs the children in sequence.
        </p>
        <p>
          Compare the two arrangements illustrated below:
        </p>
        <div class="figure">
          <img src="img/grouping-types.svg" width="600">
        </div>
        <p class="caption">
          Two types of animation groups.<br>
          (a) is a parallel group where all the children run simultaneously.<br>
          (b) is a sequence group where the children run in turn.
        </p>
        <p>
          Groups can also contain other groups which allows for more
          sophisticated synchronization.
        </p>
        <div class="figure">
          <img src="img/grouping-nesting.svg" width="600">
        </div>
        <p class="caption">
          A sequence animation group that contains a parallel animation group as
          a child.<br>
          The parallel group waits for the previous child of the sequence
          group to finish, and then the children of the parallel group play
          simultaneously.
          After they have finished the next child of the sequence group plays.
        </p>
        <p>
          Web Animations defines two types of animation groups.
        </p>
        <dl>
          <dt>Parallel groups</dt>
          <dd>
            Children of the group play simultaneously.
            The start time of children is taken as relative to the start of the
            current iteration of the group, that is, it is in the group's
            <em>iteration time space</em>.
          </dd>
          <dt>Sequence groups</dt>
          <dd>
            Children of the group play in turn beginning with the first child
            and proceeding to the last.
            Any start time specified on children is ignored and replaced with
            the time calculated using the procedure in <a
            href="#the-start-time-of-children-of-a-sequence-animation-group"
            class="sectionRef"></a>.
          </dd>
        </dl>
      </section>
      <section>
        <h3>The document timeline</h3>
        <p class="todo">
          Move all this to its own section later on.
        </p>
        <p>
          We have previously referred to the document timeline as the context in
          which animation takes places.
          Likewise we have referred to the <em>document time space</em> as the
          master time space which contains other time spaces.
          The document timeline is, in fact, a parallel animation group
          with the following special properties:
        </p>
        <ul>
          <li>
            It cannot be appended as a child of another group. As a result the
            <code>parentGroup</code> property returns <code>null</code>.
          </li>
          <li>
            Calls to <code>cancel()</code> will result in a DOMException of type
            HierarchyRequestError being thrown.
          </li>
          <li>
            <p>
              For properties that represent times in <em>parent iteration time
              space</em> a time space whose zero time is 00:00:00 UTC on
              1 January 1970 is used.
            </p>
            <p>
              As a result, the <var>parent iteration time</var> is the number of
              seconds from 00:00:00 UTC on 1 January 1970 to the current moment
              in UTC time.
            </p>
            <p class="issue">
              We should use a monotonically increasing timestamp here.
              Not one that can potentially skip due to clock adjustments.
            </p>
          </li>
          <li>
            It is initially paused as described in <a
              href="#initial-state-of-the-document-timeline"
              class="sectionRef"></a>.
          </li>
        </ul>
        <p class="todo">
          Move/copy exception behavior to the relevant properties / methods.
        </p>
        <section>
          <h4>Initial state of the document timeline</h4>
          <p>
            Unlike other timed items, the document timeline is initially paused.
            The moment at which the timeline becomes unpaused is defined in <a
              href="#start-of-the-timeline" class="sectionRef"></a>.
          </p>
          <p>
            On creating an <code>AnimationGroupInstance</code> corresponding to
            the document timeline, the following steps are performed.
          </p>
          <ol>
            <li>
              Set the <var>start time</var> to the current <var>parent
              iteration time</var> (i.e. the number of seconds since 00:00:00
              UTC on 1 January 1970).
            </li>
            <li>
              Set the <var>pause state</var> to <code>true</code>.
            </li>
          </ol>
          <p class="note">
            By setting the <var>start time</var> to the <var>parent iteration
            time</var> and then pausing the timeline, the start time is always
            well-defined.
            Furthermore, seeking the timeline before it is unpaused provides
            intuitive results without special casing the algorithm for seeking
            (see <a href="#seeking-a-timed-item" class="sectionRef"></a>).
          </p>
        </section>
        <section>
          <h4>Start of the timeline</h4>
          <p>
            The time at which the timeline will be automatically unpaused is
            determined by the <code>timelineStart</code> property on the
            <code>Document</code> object (see <a
            href="#extensions-to-the-document-interface"
            class="sectionRef"></a>). It can have the following values:
          </p>
          <dl title="enum AnimStartType" class="idl">
            <dt>onload</dt>
            <dd>
              <p>
                The moment immediately prior to dispatching the "load" event for
                the document.
              </p>
              <p>
                For HTML documents, this is the moment after the <a
                  href="http://dev.w3.org/html5/spec/dom.html#current-document-readiness">current
                  document readiness</a> has changed to "complete" but before
                dispatching the load event.  In terms of the timings defined in
                <a
                  href="http://test.w3.org/webperf/specs/NavigationTiming/">NAVIGATION-TIMING</a>
                <span class="todo">(Need to add NAVIGATION-TIMING to the
                  biblio)</span>, this occurs between the <em>domComplete</em>
                and <em>loadEventStart</em> timings.
              </p>
              <p>
                This is the default value.
              </p>
            </dd>
            <dt>onstart</dt>
            <dd>
              <p>
                The moment after the user agent stops parsing but before running
                scripts that are designated to execute when parsing finishes.
              </p>
              <p>
                For HTML documents, this occurs after updating the <a
                  href="http://dev.w3.org/html5/spec/dom.html#current-document-readiness">current
                  document readiness</a> to "interactive" (see <a
                href="http://dev.w3.org/html5/spec/the-end.html#the-end">the
                specified behavior for the end of parsing</a>), that is,
                after the <em>domInteractive</em> timing.
              </p>
            </dd>
            <dt>manual</dt>
            <dd>
              A moment infinitely distant in the future. That is, animation will
              not begin until <code>unpause</code> is called on the timeline.
            </dd>
          </dl>
          <p>
            For the <var>onload</var> and <var>onstart</var> values, it is not
            sufficient to simply the record the appropriate time and seek the
            animations accordingly at a later moment.
            Rather, the timeline must be actually unpaused at the appropriate
            moment such that scripts that execute during page loading (for
            example, in response to the load event) can make assumptions about
            the pause state of the timeline.
          </p>
          <p>
            Any call to <code>pause</code> or <code>unpause</code> on the
            timeline disables the automatic unpause behavior defined by the
            <code>timelineStart</code> property on the document.
            It is as if the <code>timelineStart</code> property were set to
            <var>manual</var>.
          </p>
          <div class="note">
            <p>
              The ability for script to override the <code>timelineStart</code>
              property by calling <code>pause</code> to indefinitely postpone
              the start of animation is necessary for backwards compatibility
              with SVG.
            </p>
            <p>
              This override behavior applies even if the timeline has already
              been unpaused since changing the <code>timelineStart</code>
              property could return the timeline to a state where the automatic
              unpause behavior would otherwise apply.
            </p>
          </div>
        </section>
        <section>
          <h4>Changing the timeline start</h4>
          <p>
            The <code>timelineStart</code> property may be changed at any time.
            The result of changing this property is as follows:
          </p>
          <ol>
            <li>
              If <code>pause</code> or <code>unpause</code> has been called on
              the timeline, return immediately.
            </li>
            <li>
              Let <var>autostart</var> be the moment at which the timeline would
              be unpaused corresponding to the new value of
              <code>timelineStart</code> as defined in <a
              href="#start-of-the-timeline" class="sectionRef"></a>.
            </li>
            <li>
              Let <var>now</var> be the <var>parent iteration time</var>.
            </li>
            <li>
              If <var>autostart</var> &le; <var>now</var>, set the
              <var>pause state</var> to false.
            </li>
            <li>
              If <var>autostart</var> &gt; <var>now</var>, set the <var>start
              pause state</var> to true.
            </li>
            <li>
              If the pause state is newly true seek the timeline to
              <var>autostart</var> - <var>now</var>.
            </li>
            <li>
              If the pause state is newly false seek the timeline to 0.
            </li>
          </ol>
        </section>
        <section>
          <h4>Extensions to the <code>Document</code> interface</h4>
          <p>
            To provide access to the document timeline the following extensions
            to the <code>Document</code> interface are required.
          </p>
          <dl title="partial interface Document" class="idl">
            <dt>readonly attribute ParGroup animationTimeline</dt>
            <dd>
              The animation group corresponding to the root of the document.
              This group exhibits the special behavior described for the root
              animation group in <a href="#the-document-timeline"
              class="sectionRef"></a>.
            </dd>
            <dt>attribute AnimStartType timelineStart</dt>
            <dd>
              Sets the time at which the animation timeline will begin animating
              unless it is overridden by script as defined in <a
              href="#start-of-the-timeline" class="sectionRef"></a>.
              Changes to this property are defined in <a
              href="#changing-the-timeline-start" class="sectionRef"></a>.
              Initialized to "onload".
            </dd>
          </dl>
        </section>
        <section>
          <h3>Timeline of document resources</h3>
          <p>
            Documents may include external animated resources, for example, via
            the <code>&lt;object&gt;</code> or <code>&lt;use&gt;</code>
            elements. These external resources will often have their own
            Document object and their own timeline. In order to synchronize
            these timelines the same approaches can be applied as with described
            under <a href="#synchronizing-with-media" class="sectionRef"></a>.
          </p>
        </section>
      </section>
      <section>
        <h3>The <code>AnimationGroup</code> interface</h3>
        <p>
          Represents a list of timed items.
        </p>
        <p>
          The <code>AnimationGroup</code> interface supports indexed
          properties with indices in the range 0 &le; <var>index</var> &lt;
          <code>group.size</code>. 
        </p>
        <dl title="interface AnimationGroup : TimedItem"
          class="idl">
          <dt>readonly attribute unsigned long length</dt>
          <dd>
            The number of timed items in the group.
          </dd>
          <dt>readonly attribute AnimationGroupTemplate? template</dt>
          <dd>
            <p>
              For linked animation groups (see <a href="#animation-templates"
              class="sectionRef"></a>), the <a>AnimationGroupTemplate</a> object
              from which this object derives its values.
              For animations that are not linked to a template, this property is
              <code>null</code>.
            </p>
            <p class="feedbackWanted">
              Make this writeable?
            </p>
          </dd>
          <dt>void clear ()</dt>
          <dd>
            <p>
              Removes all child timed items from the group.
            </p>
            <p>
              Exceptions:
            </p>
            <dl class="exceptions">
              <dt>DOMException of type
                  <code>NoModificationAllowedError</code></dt>
              <dd>
                Raised if this group is a linked group, that is, if
                <code>template</code> is not <code>null</code>
                (see <a href="#animation-templates" class="sectionRef"></a>).
              </dd>
            </dl>
          </dd>
          <dt>getter TimedItem? (unsigned long index)</dt>
          <dd>
            <p>
              Returns the item at <code>index</code>.
              If <code>index</code> is greater than or equal to
              <code>length</code> returns <code>null</code>.
            </p>
          </dd>
          <dt>setter TimedItem (unsigned long index, TimedItem newItem)</dt>
          <dd>
            <p>
              Replaces the item at <code>index</code> with <code>newItem</code>
              by calling <code>splice(index, 1, newItem)</code>.
            </p>
            <p>
              No attempt is made to check if the item at <code>index</code> is
              already <code>newItem</code>. In such a case, <code>newItem</code>
              will be removed from this group and re-added as per the usual
              operation of <code>slice</code>.
            </p>
            <p>
              Returns <code>newItem</code>.
            </p>
            <p>
              Exceptions:
            </p>
            <dl class="exceptions">
              <dt>DOMException of type <code>HierarchyRequestError</code></dt>
              <dd>
                Raised if <code>newItem</code> is the timeline for a document
                (see <a href="#the-document-timeline" class="sectionRef"></a>).
              </dd>
              <dt>DOMException of type <code>IndexSizeError</code></dt>
              <dd>
                Raised if <code>index</code> is outside of the range 0 &le;
                <var>index</var> &lt; <code>group.length</code>.
              </dd>
              <dt>DOMException of type
                  <code>NoModificationAllowedError</code></dt>
              <dd>
                Raised if this group is a linked group, that is, if
                <code>template</code> is not <code>null</code>
                (see <a href="#animation-templates" class="sectionRef"></a>).
              </dd>
            </dl>
            <div class="note">
              <p>
                Whilst <code>splice</code> allows negative indices,
                WebIDL requires index property setters to take an index of type
                <code>unsigned long</code> and hence <code>index</code> is
                restricted to the range 0 &le; <var>index</var> &lt;
                <code>group.length</code>.
              </p>
            </div>
          </dd>
          <dt>sequence&lt;TimedItem&gt; add (TimedItem newItem,
                                             TimedItem... otherItems)</dt>
          <dd>
            <p>
              Add <code>newItem</code> and each <code>otherItems</code> as the
              last item(s) in the group by calling <code>splice(group.length, 0,
              newItem, otherItem1, ... otherItemN)</code>.
            </p>
            <p>
              Returns a sequence containing the added items:
              <code>[newItem, otherItem1, ... otherItemN]</code>.
            </p>
            <p>
              Exceptions:
            </p>
            <dl class="exceptions">
              <dt>DOMException of type <code>HierarchyRequestError</code></dt>
              <dd>
                Raised if any of the items to add is the timeline for a document
                (see <a href="#the-document-timeline" class="sectionRef"></a>).
                If this exception is thrown none of the <code>newItem</code>
                objects will be added to the group.
              </dd>
              <dt>DOMException of type
                  <code>NoModificationAllowedError</code></dt>
              <dd>
                Raised if this group is a linked group, that is, if
                <code>template</code> is not <code>null</code>
                (see <a href="#animation-templates" class="sectionRef"></a>).
              </dd>
            </dl>
          </dd>
          <dt>sequence&lt;TimedItem&gt; remove (
                long index, optional unsigned long count = 1)</dt>
          <dd>
            <p>
              Removes the item(s) at <code>index</code> by calling
              <code>splice(index, count)</code>.
            </p>
            <p>
              Returns the removed items.
            </p>
            <p>
              Exceptions:
            </p>
            <dl class="exceptions">
              <dt>DOMException of type
                  <code>NoModificationAllowedError</code></dt>
              <dd>
                Raised if this group is a linked group, that is, if
                <code>template</code> is not <code>null</code>
                (see <a href="#animation-templates" class="sectionRef"></a>).
              </dd>
            </dl>
          </dd>
          <dt>
            sequence&lt;TimedItem&gt; splice ()
          </dt>
          <dd>
            <p>
              Modifies the list of children of this group by first removing
              <code>deleteCount</code> items from <code>start</code> followed by
              adding <code>newItems</code> at the same point.
            </p>
            <p>
              The operation of slice is based on <a
                href="http://www.ecma-international.org/publications/files/ECMA-ST-ARCH/ECMA-262%205th%20edition%20December%202009.pdf#page=140">ECMAScript 5's
                Array.prototype.splice</a>.
            </p>
            <p>
              Returns a sequence of the items removed from group during the
              removal step (regardless of whether these items were re-added
              during the addition step).
            </p>
            <dl class="parameters">
              <dt>long start</dt>
              <dd>
                The index at which items should be removed and inserted.
                Negative indices represent an offset from the end of the list of
                items.
                This value is clamped to the range [-<code>length</code>,
                <code>length</code>].
              </dd>
              <dt>unsigned long deleteCount</dt>
              <dd>
                The number of items to remove from the group beginning at
                <code>start</code>.
                Negative values are clamped to zero, and all other values are
                clamped such that
                0 &lt; <code>start</code> + <code>deleteCount</code> &le;
                length.
              </dd>
              <dt>sequence&lt;TimedItem&gt; newItems</dt>
              <dd>
                The items to be added at <code>start</code>.
                Each item, if it already has a parent group (including this
                group), is first removed from its parent group before being
                added to this group.
              </dd>
            </dl>
            <p>
              Exceptions:
            </p>
            <dl class="exceptions">
              <dt>DOMException of type <code>HierarchyRequestError</code></dt>
              <dd>
                Raised if any of the items in <code>newItem</code> is the
                timeline for a document (see <a href="#the-document-timeline"
                class="sectionRef"></a>).
              </dd>
              <dt>DOMException of type
                  <code>NoModificationAllowedError</code></dt>
              <dd>
                Raised if this group is a linked group, that is, if
                <code>template</code> is not <code>null</code>
                (see <a href="#animation-templates" class="sectionRef"></a>).
              </dd>
            </dl>
          </dd>
          <dt>
            sequence&lt;TimedItem&gt; splice (long start,
              unsigned long deleteCount, TimedItem... newItem)
          </dt>
          <dd>
            An overload of <code>splice</code> to take a variadic list of items
            rather than requiring a sequence.
            The operation is identical to <code>splice(unsigned long start,
            unsigned long deleteCount, sequence&lt;TimedItem&gt;
            newItems)</code>.
          </dd>
          <dt>long indexOf (TimedItem item)</dt>
          <dd>
            Returns the index of <code>item</code> within the group.
            If <code>item</code> is not in the group, returns <code>-1</code>.
          </dd>
          <dt>AnimationGroupTemplate? unlink()</dt>
          <dd>
            <p class="todo">
              Makes this group independent of the template with which it is
              associated if any.
              See <a href="#animation-templates" class="sectionRef"></a>.
              Does this recurse through children and unlink them too?
            </p>
            <p>
              After this method returns, the <code>template</code>
              property will be <code>null</code>.
            </p>
            <p>
              Returns the previous value of <code>template</code>.
            </p>
          </dd>
          <dt>sequence&lt;Animation&gt; getActiveAnimations ()</dt>
          <dd>
            Returns all descendent <code>Animation</code> objects
            that are <a>in effect</a>.
            The returned sequence is a snapshot (i.e. not live) representing the
            state of animations that corresponds to the time returned by the
            <code>iterationTime</code> property of this
            <code>AnimationGroup</code> object when this method was
            called.
          </dd>
          <dt>sequence&lt;Animation&gt; getAnimationsForElement (AnimationTarget
          elem)</dt>
          <dd>
            Returns all descendent <code>Animation</code> objects
            whose <code>targetElement</code> is <code>elem</code>.
            As with <code>getActiveAnimations</code>, the returned sequence is
            a snapshot (i.e. not live) representing the state of animation
            when this method was called.
          </dd>
        </dl>
      </section>
      <section>
        <h3>Parallel animation groups</h3>
        <p>
          Parallel animation group run their children such they potentially play
          simultaneously.
          The start time of each child depends on its own <code>startTime</code>
          property.
        </p>
        <section>
          <h4>The intrinsic duration of a parallel animation group</h4>
          <p>
            The intrinsic duration of a parallel animation group is
            the maximum of the <code>endTime</code> properties of each
            child <code>TimedItem</code>.
          </p>
          <p>
            If the group has no children then the intrinsic duration is zero.
          </p>
        </section>
        <section>
          <h4>The <code>ParGroup</code> interface</h4>
          <p>
            Parallel animation groups are represented by <code>ParGroup</code>
            objects.
          </p>
          <dl title="interface ParGroup : AnimationGroup" class="idl">
            <dt>Constructor ()</dt>
            <dd>
              <dl class="parameters">
                <dt>sequence&lt;TimedItem&gt;? children</dt>
                <dd>
                  <p>
                    A sequence of timed items to add as children of this group.
                  </p>
                  <p>
                    These children are appended in sequence using the semantics
                    as the <code><a>AnimationGroup</a>.add</code> method.
                  </p>
                </dd>
                <dt>optional (double or TimingDictionary or Timing)? timing</dt>
                <dd>
                  <p>
                    The timing properties of the new animation group.
                  </p>
                  <p>
                    If this parameter is a <code>double</code>, then it
                    specifies the duration of a single iteration of the
                    animation group, that is, the <a>iteration duration</a>, in
                    seconds.
                    In this case, the <code>timing</code> property of the new
                    <a>ParGroup</a> object is set to a new <a>Timing</a>
                    object constructed from a <a>TimingDictionary</a> object
                    with the <code>duration</code> property set to the
                    <code>double</code> value specified here, and all other
                    properties set to their default values.
                  </p>
                  <p>
                    Similarly, if this parameter is <code>null</code>, the
                    <code>timing</code> property is set to a new <a>Timing</a>
                    object constructed from a <a>TimingDictionary</a> object
                    with all properties set to their default values.
                  </p>
                  <p>
                    If this parameter is of type <a>TimingDictionary</a>, then
                    the passed-in dictionary is used to construct a new
                    <a>Timing</a> object which is then assigned to the
                    <code>timing</code> property of the new <a>ParGroup</a>
                    object.
                  </p>
                  <p>
                    If this parameter is a <a>Timing</a> object, it is directly
                    assigned to the <code>timing</code> property of the new
                    <a>ParGroup</a> object.
                    It is <em>not</em> copied.
                    In this way <a>Timing</a> objects can be shared between
                    <a>TimedItem</a> objects.
                  </p>
                  <p>
                    Finally, if this parameter is not specified, it is as if
                    a value of <code>null</code> were specified.
                  </p>
                </dd>
                <dt>optional AnimationGroup? parentGroup</dt>
                <dd>
                  The group to which the newly created animation group should be
                  appended as a child.
                  If not specified, the animation will be appended to the
                  document timeline.
                  If <code>null</code>, the animation group will not be appended
                  to any group.
                </dd>
                <dt>optional double startTime</dt>
                <dd>
                  <p>
                    The <a>start time</a> of the newly generated animation group
                    expressed in seconds in the <a>iteration time space</a> of
                    the <a>AnimationGroup</a> to which it is (or will be)
                    appended.
                  </p>
                  <p>
                    If not specified, the current <a>iteration time</a> of the
                    <a>AnimationGroup</a> to which the animation is appended (as
                    determined by the <code>parentGroup</code> parameter) will
                    be used.
                    If <code>parentGroup</code> is <code>null</code>, and
                    the <code>startTime</code> is not specified, a time of zero
                    will be used.
                  </p>
                </dd>
              </dl>
            </dd>
          </dl>
        </section>
      </section>
      <section>
        <h3>Sequence animation groups</h3>
        <p>
          Sequence animation groups run their children in turn
          following their order in the group.
          This ordering is achieved by adjusting the <var>start time</var> of
          each child in the group.
        </p>
        <div class="informative">
          <p>
            Since the <var>start delay</var> is added to the <var>start
            time</var>, it can be used to adjust the timing of the <a>animation
            interval</a> relative to calculated <var>start time</var> as shown
            in the following diagram.
          </p>
          <div class="figure">
            <img src="img/sequence-groups-and-start-delays.svg" width="600">
          </div>
          <p>
            A negative <var>start delay</var> can be used to cause the
            <a>animation interval</a> of two children to overlap.
            Note that the <var>start delay</var> affects the <var>start
            time</var> of subsequent children in the group.
          </p>
        </div>
        <section>
          <h4>The start time of children of a sequence animation group</h4>
          <p>
            The start time for the children of a sequence animation group
            is calculated according to the following procedure:
          </p>
          <ol>
            <li>Let the <var>accumulated start time</var> be zero.
            <li>
              Iterate over each child in the group beginning with the first item
              in the group and proceeding to the last.
              For each child perform the following steps:
              <ol>
                <li>
                  Let <var>child</var> be the current child.
                </li>
                <li>
                  Let <code><var>child</var>.startTime</code> be
                  <var>accumulated start time</var>.
                </li>
                <li>
                  Let <var>accumulated start time</var> be
                  <code><var>child</var>.endTime</code>.
                </li>
              </ol>
            </li>
          </ol>
          <p class="note">
            When <code>animationDuration</code> is positive infinity the
            behavior is defined by IEEE 754-2008.
            As a result, if any of the children of a sequence animation group
            has an infinite animation duration, any children that occur
            later in the sequence will not play.
          </p>
        </section>
        <section>
          <h4>The intrinsic duration of a sequence animation group</h4>
          <p>
            The instrinsic duration of a sequence animation group is
            equivalent to the <var>start time</var> of a hypothetical child
            appended to the group's children using the procedure described in <a
            href="#the-start-time-of-children-of-a-sequence-animation-group"
            class="sectionRef"></a>.
          </p>
        </section>
        <section>
          <h4>The <code>SeqGroup</code> interface</h4>
          <p>
            Sequence animation groups are represented by <code>SeqGroup</code>
            objects.
          </p>
          <dl title="interface SeqGroup : AnimationGroup"
            class="idl">
            <dt>
            Constructor (sequence&lt;TimedItem&gt;? children,
                optional (double or TimingDictionary or Timing)? timing,
                optional AnimationGroup? parentGroup,
                optional double startTime)
            </dt>
            <dd>
              The meaning and handling of each of the parameters in this
              constructor is identical to the constructor for
              <a>ParGroup</a>.
            </dd>
          </dl>
        </section>
      </section>
    </section>

    <section>
      <h2>Animation values</h2>
      <div class="informative">
        <p>
          The Web Animations <em>animation model</em> takes the <a>time
          fraction</a>s produced by the <em>timing model</em> for a given
          <a>Animation</a> and applies it as the input to the <em>animation
          effect</em> defined for the <a>Animation</a> object.
          The output of each <em>animation effect</em> is then combined using
          a global animation stack before being applied to the target property
          (see <a href="#combining-animations" class="sectionRef"></a>).
        </p>
        <p>
          The entry-point to the <em>animation model</em> is the
          <a>AnimationEffect</a> or <a>CustomAnimationEffect</a> object
          associated with each <a>Animation</a>.
          These objects describe how animation values should be calculated for
          the <a>Animation</a> for any given time.
          <a>AnimationEffect</a> serves as an abstract interface of which
          several concrete subclasses are provided.
        </p>
      </div>
      <section>
        <h3>The <code>AnimationEffect</code> interface</h3>
        <dl title="interface AnimationEffect" class="idl">
          <dt>attribute CompositeOperation operation</dt>
          <dd>
            <p>
              The operation used to composite this animation with the stack, as 
              specified by one of the <a>CompositeOperation</a> enumeration
              values.
            </p>
            <p>
              This value defaults to <code>"replace"</code>
            </p>
          </dd>
          <dt>attribute CompositeOperation accumulateOperation</dt>
          <dd>
            <p>
              The operation used to composite each iteration of this animation
              with the result of compositing the previous animation, as
              specified by one of the <a>CompositeOperation</a> constants
              defined in this interface.
            </p>
            <p>
              This value defaults to <code>"replace"</code>.
            </p>
          </dd>
          <dt>any sample (double? timeFraction, double currentIteration,
                          AnimationTarget? target, any underlyingValue)</dt>
          <dd>
            <div class="todo">
              <p>
                Define this here?<br>
                Potentially this should be an interface that script could
                provide its own object for.
              </p>
              <p>
                Implementations of the function would be expected to produce the
                same result given the same parameters so the implementation
                could cache the result and not call the function when the
                parameters were the same. 
              </p>
              <p>
                <code>timeFraction</code> would be a number typically in the
                range [0.0, 1.0].
                <code>null</code> values indicate the function should no longer
                affect the target.
              </p>
              <p>
                Pass in <code>isSeeking</code> as a flag?
                Tempting to pass in <code>aPreviousTimeFraction</code> but
                I think functions that need that can track it themselves?
                Although that requires a new instance of the function for each
                target.
              </p>
            </div>
          </dd>
          <dt>AnimationEffect clone ()</dt>
          <dd>
            <p>
              Creates and returns a new object of the same type as this object's
              most-derived interface such that it will produce the same output
              as this object.
            </p>
            <p class="todo">
              We either need a more rigorous definition here or (probably
              better) a sets of steps on a per-subclass basis.
            </p>
          </dd>
          <dt>static AnimationEffect? createFromProperties ()</dt>
          <dd>
            <p>
              Creates an <a>AnimationEffect</a> representing the passed-in
              collection of properties.
            </p>
            <div class="note">
              <p>
                Note that this method requires handling the passed in parameter
                in a manner not yet supported by Web IDL and hence this method
                is ECMAScript-specific.
              </p>
              <p>
                Since accessing the properties of an ECMAScript user object can
                have side effects, the manner in which these properties is
                accessed is important.
                In light of this consideration the following procedure has the
                following properties:
              </p>
              <ul>
                <li>Every property is read only once.</li>
                <li>Properties are read in a well-defined order.</li>
                <li>Properties corresponding to unsupported target properties or
                    attributes are not read.</li>
              </ul>
            </div>
            <p>
              The interpretation of the passed-in <code>properties</code> object
              can be described in three parts.
            </p>
            <p><strong>Part 1 &ndash; Determine the set of
               animation properties</strong></p>
            <ol>
              <li>Create a list, <var>supported properties</var>, of property
                  names and attribute names that can be animated by the
                  implementation.</li>
              <li>Let <var>animation properties</var> be an empty sequence.</li>
              <li>Iterate through the properties of <code>properties</code>. For
                  each <var>property</var> in <code>properties</code>, if
                  <var>property</var> also exists in <var>supported
                  properties</var> based on a case-sensitive comparison, append
                  <var>property</var> to <var>animation properties</var>.
                  <p class="note">
                    Whilst the iteration order for properties of an ECMAScript
                    object is implementation-dependent, the order here is not
                    significant to the outcome as <var>animation
                    properties</var> will be sorted before being iterated over.
                  </p>
                  <p class="issue">
                    How do we handle <code>operation</code> and
                    <code>compositeOperation</code>? We'd like to be able to
                    list them in the same property bag but that would mean we
                    could never animate properties of the same name.
                  </p>
              </li>
            </ol>
            <p><strong>Part 2 &ndash; Create the <a>AnimationEffect</a>
               objects</strong></p>
            <p>
              The <a>AnimationEffect</a> object produced depends on the length
              of <var>animation properties</var> as follows:
            </p>
            <dl class="switch">
              <dt>If <var>animation properties</var> is of zero length,</dt>
              <dd>
                return <code>null</code>.
                <div class="note">
                  <p>
                    This behaviour of returning <code>null</code> allows
                    alternative animation effects to be provided based on the
                    capabilities of the user agent as follows:
                  </p>
                  <pre class="example sh_javascript">
elem.animate(
  AnimationEffect.createFromProperties({ transform: 'translate(-100px)' }) ||
  AnimationEffect.createFromProperties({ top: '-100px' }),
  3);
                  </pre>
                </div>
              </dd>
              <dt>If <var>animation properties</var> has only one element,</dt>
              <dd>
                <ol>
                  <li>Let <var>name</var> be the value of the element
                      in <var>animation properties</var>.</li>
                  <li>Let <var>value</var> be the value of
                      <code>properties.<var>name</var></code>.</li>
                  <li>Return a new <a>KeyframeAnimationEffect</a> object
                      according to the steps in part 3 below based on
                      <var>name</var> and <var>value</var>.</li>
                </ol>
              </dd>
              <dt>Otherwise,</dt>
              <dd>
                <ol>
                  <li>Let <var>group</var> be a newly constructed
                      <a>GroupedAnimationEffect</a>.</li>
                  <li>Sort <var>animation properties</var> lexicographically by
                      the Unicode codepoints that define each property
                      name.</li>
                  <li>For user agents that support both a prefixed and an
                      unprefixed version of some CSS properties, remove all
                      prefixed properties from <var>animation properties</var>
                      where the corresponding unprefixed version is also
                      present.</li>
                  <li>Iterate through <var>animation properties</var>. For each
                      <var>name</var> in <var>animation properties</var>:
                    <ol>
                      <li>Let <var>value</var> be the value of
                          <code>properties.<var>name</var></code>.</li>
                      <li>Create a new <a>KeyframeAnimationEffect</a>,
                          <var>effect</var> object according to the steps in
                          part 3 below based on <var>name</var> and
                          <var>value</var>.</li>
                      <li>Append <var>effect</var> to <var>group</var>.
                    </ol>
                  </li>
                  <li>Return <var>group</var>.
                </ol>
              </dd>
            </dl>
            <p><strong>Part 3 &ndash; Create each
               <a>KeyframeAnimationEffect</a> object</strong></p>
            <p>
              Based on a given <var>name</var> and <var>value</var>, a new
              <a>KeyframeAnimationEffect</a> is created as follows:
            </p>
            <dl class="switch">
              <dt>If <var>value</var> is not of type <code>(DOMString or
              sequence&lt;(<a>KeyframeDictionary</a> or
              DOMString)&gt;)</code>,</dt>
              <dd>
                Throw a <code>TypeError</code> as defined by [[!ECMA-262]].
              </dd>
              <dt>Otherwise,</dt>
              <dd>
                Construct a new <a>KeyframeAnimationEffect</a> by calling
                <code>KeyframeAnimationEffect(<var>name</var>,
                <var>value</var>)</code>.
              </dd>
            </dl>
            <dl class="parameters">
              <dt>object properties</dt>
              <dd>
                An object whose object properties represent the CSS properties
                or element attributes to be animated.
                The values corresponding to these properties are the animation
                values to be applied as described above.
              </dd>
            </dl>
          </dd>
        </dl>
      </section>
      <section>
        <h3>The <code>CompositeOperation</code> enumeration</h3>
        <dl title="enum CompositeOperation" class="idl">
          <dt>replace</dt>
          <dd>
            The animation should replace the value it is composited with.
          </dd>
          <dt>accumulate</dt>
          <dd>
            The animation should add to the value it is composited with.
            The meaning of addition is dependent on the type of animation.
          </dd>
          <dt>merge</dt>
          <dd>
            The animation should merge with the value it is composited with.
            The meaning of merge is dependent on the type of animation.
            The duration of the merge is the calculated animation duration
            of the <code>AnimationTemplate</code> containing this
            <code>AnimationEffect</code>.
          </dd>
        </dl>
      </section>
      <section>
        <h3>The <code>KeyframeAnimationEffect</code> interface</h3>
        <dl title="interface KeyframeAnimationEffect : AnimationEffect"
          class="idl">
          <dt>Constructor (DOMString property,
      (DOMString or sequence&lt;(KeyframeDictionary or DOMString)&gt;) frames,
      optional CompositeOperation operation = "replace",
      optional CompositeOperation compositeOperation = "replace")</dt>
          <dd>
            <p>
              Creates a new <a>KeyframeAnimationEffect</a> object for the
              specified property from the given list of keyframes.
            </p>
            <p>
              The list of keyframes may be a sequence of
              <a>KeyframeDictionary</a> dictionaries, a sequence of
              <code>DOMString</code>s, a combination of both, or
              a single <code>DOMString</code>.
            </p>
            <p>
              <code>DOMString</code>s are used to create keyframes with an
              offset of 1.
              When the list of keyframes is a sequence consisting entirely of
              <code>DOMString</code>s the offsets of the newly created
              <a>Keyframe</a>s are distributed evenly from 0 to 1.
            </p>
            <p>
              The <var>property</var>, <var>operation</var> and
              <var>compositeOperation</var> arguments are assigned to the
              attributes of the same names.
            </p>
            <p>
              The <var>frames</var> argument is processed as follows:
            </p>
            <ol>
              <li>Let <var>effect</var> be the
                  <a>KeyframeAnimationEffect</a> currently under construction.
              </li>
              <li>
                <p>
                  The processing of <var>frames</var> depends on its type as
                  follows:
                </p>
                <dl class="switch">
                  <dt>If <var>frames</var> is a <code>DOMString</code>,</dt>
                  <dd>
                    <ol>
                      <li>
                        Let <var>frame</var> be a new <a>Keyframe</a>
                        constructed from a <a>KeyframeDictionary</a> whose
                        <code>value</code> member is set to
                        <var>frames</var> and whose other members are set
                        to their default values.
                      </li>
                      <li>
                        Call
                <code><var>effect</var>.frames.add(<var>frame</var>)</code>.
                      </li>
                    </ol>
                  </dd>
                  <dt>If <var>frames</var> is a sequence of <code>(DOMString
                      or <a>KeyframeDictionary</a>)</code>,</dt>
                  <dd>
                    <ol>
                      <li>Set a flag <var>all strings</var> to
                          <code>true</code>.</li>
                      <li>
                        For each <var>item</var> in <var>frames</var>:
                        <ol>
                          <li>
                            <dl class="switch">
                              <dt>If <var>item</var> is
                                  a <code>DOMString</code>,</dt>
                              <dd>
                                Let <var>frame</var> be a new <a>Keyframe</a>
                                constructed from a <a>KeyframeDictionary</a>
                                whose <code>value</code> member is set to
                                <var>item</var> and whose other members are
                                set to their default values.
                              </dd>
                              <dt>Otherwise (<var>item</var> is
                                  a <a>KeyframeDictionary</a>),</dt>
                              <dd>
                                <ol>
                                  <li>
                                    Let <var>frame</var> be a new
                                    <a>Keyframe</a> constructed by calling
                                    <code>Keyframe(<var>item</var>)</code>.
                                  </li>
                                  <li>
                                    Set <var>all strings</var> to
                                    <code>false</code>.
                                  </li>
                                </ol>
                              </dd>
                            </dl>
                          </li>
                          <li>
                            Call
                <code><var>effect</var>.frames.add(<var>frame</var>)</code>.
                          </li>
                        </ol>
                      </li>
                      <li>If flag <var>all strings</var> is
                          <code>true</code> call
                        <code><var>effect</var>.frames.distribute()</code>.
                      </li>
                    </ol>
                  </dd>
                </dl>
              </li>
            </ol>
          </dd>
          <dt>attribute DOMString property</dt>
          <dd>
            The name of the target property or attribute.
          </dd>
          <dt>readonly attribute KeyframeList frames</dt>
          <dd>
            The series of values that make up this effect sorted by their
            offset within the iteration duration of the animation.
          </dd>
        </dl>
      </section>
      <section>
        <h3>The <code>KeyframeList</code> interface</h3>
        <p>
          The <a>KeyframeList</a> object is a collection of <a>Keyframe</a>
          objects sorted by the offset of each <a>Keyframe</a>.
        </p>
        <dl title="interface KeyframeList" class="idl">
          <dt>readonly attribute unsigned long length</dt>
          <dd>
            The number of frames in the list.
          </dd>
          <dt>void clear ()</dt>
          <dd>
            Removes all frames from this list.
          </dd>
          <dt>getter Keyframe? (unsigned long index)</dt>
          <dd>
            Returns the frame at <code>index</code> if it exists or
            <code>null</code> otherwise.
          </dd>
          <dt>Keyframe add((Keyframe or KeyframeDictionary) frame)</dt>
          <dd>
            <p>
              Adds <var>frame</var> to the list such that the list remains
              sorted by the offset of the frames.
            </p>
            <p>
              If <var>frame</var> is of type <a>KeyframeDictionary</a> then
              a <a>Keyframe</a> object is first constructed by calling
              <code>Keyframe(<var>frame</var>)</code> before adding the
              newly constructed <a>Keyframe</a> to the list.
            </p>
            <p>
              If there already exists a frame in this list with offset
              <code><var>frame</var>.offset</code>, the newly added
              <var>frame</var> will appear in the list <em>after</em> the
              already existing frames in the list with the same offset.
            </p>
            <p>
              If <var>frame</var> is already part of another <a>KeyframeList</a>
              it is first removed from that list before being added to this
              list.
            </p>
            <p>
              Exceptions:
            </p>
            <dl class="exceptions">
              <dt>DOMException of type <code>IndexSizeError</code></dt>
              <dd>
                Raised if <var>frame</var> is a <a>KeyframeDictionary</a> whose
                offset is outside the range [0,1] or missing.
              </dd>
            </dl>
          </dd>
          <dt>Keyframe? remove(unsigned long index)</dt>
          <dd>
            Removes the frame at position <var>index</var> and returns it.
            If index is outside the range [0, length), then <code>null</code> is
            returned.
          </dd>
          <dt>long indexOf(Keyframe frame)</dt>
          <dd>
            Returns the index of <var>frame</var> within the list. If
            <var>frame</var> is not a member of the list, returns
            <code>-1</code>.
          </dd>
          <dt>KeyframeList distribute()</dt>
          <dd>
            <p>
              Adjusts the offsets of the frames in the list such that the
              offsets are spaced equidistantly whilst maintaining their current
              order and such that the first frame (when there are multiple
              frames) has offset 0 and the last frame (if any) has offset 1.
            </p>
            <p>
              For <var>frame</var> at position <var>i</var> in the list where
              0 &le; <var>i</var> &lt; <code>length</code>, an offset will be
                assigned equal to <code>i / (length - 1)</code> unless
                <code>length</code> is 1 in which case it will be given offset
                1.
            </p>
            <p>
              After applying the changes, this list is returned.
            </p>
          </dd>
        </dl>
        <div class="annotation">
          <p>
            The following changes for making keyframes easier to work with in
            future have been proposed:
          </p>
          <pre class="example sh_javascript">
// Currently you have to do this
effect.frames.add({ property: 'left', offset: 0.3, value: '100px' }); 

// It would be nice if you could also do this
effect.frames.add(0.3, 'left', '100px');

// Also, fetching by offset would be good

// Returns the last frame with offset 0.3 if there is one.
// If there is none, does the interpolation and returns a new frame? 
var frame = effect.frames['0.3']; 
          </pre>
        </div>
      </section>
      <section>
        <h3>The <code>Keyframe</code> interface</h3>
        <p>
          A <a>Keyframe</a> represents a moment within an animation that has
          a specified value to be applied to the target property or attribute.
          In between such moments values may be interpolated or filled based on
          the <a>TimingFunction</a> specified on the <a>TimedItem</a> where the
          <a>Keyframe</a> is used, or on the previous <a>Keyframe</a>.
        </p>
        <div class="issue">
          <p>
            Currently a <a>Keyframe</a> can only target a single property which
            is defined on the <a>KeyframeAnimationEffect</a>.
            This is different to CSS.
            Is this something we want to change?
            It would complicate the API, of course, but is it worth it?
          </p>
        </div>
        <p>
          <dl title="interface Keyframe" class="idl">
            <dt>Constructor (KeyframeDictionary dictionary)</dt>
            <dd>
              <p>
                Creates a new <a>Keyframe</a> object using the parameters
                specified in <var>dictionary</var>.
              </p>
              <p>
                <code><var>dictionary</var>.offset</code> is clamped to the
                range [0, 1] before setting.
              </p>
            </dd>
            <dt>attribute DOMString value</dt>
            <dd>
              The value to assign to the target attribute or property at the
              given offset.
            </dd>
            <dt>attribute double offset</dt>
            <dd>
              <p>
                A value between 0 and 1 inclusive representing the offset
                within the iteration duration of the animation where this value
                should appear.
              </p>
              <p>
                If this keyframe belongs to a <a>KeyframeList</a>, changes to
                this value cause the <a>KeyframeList</a> to be immediately
                re-sorted using a stable sort such that all children are ordered
                by their offset but children with identical offsets retain their
                relative position in the list.
              </p>
              <p>
                Exceptions:
              </p>
              <dl class="exceptions">
                <dt>DOMException of type <code>IndexSizeError</code></dt>
                <dd>
                  Raised on setting a value outside the range [0,1].
                </dd>
              </dl>
            </dd>
            <dt>attribute TimingFunction? timingFunction</dt>
            <dd>
              <p>
                The timing function to apply between this keyframe and the
                next keyframe in any <a>KeyframeList</a> in which this object
                appears.
              </p>
              <p>
                May be <code>null</code> in which case linear interpolation will
                be used.
              </p>
            </dd>
          </dl>
        </p>
      </section>
      <section>
        <h3>The <code>KeyframeDictionary</code> dictionary</h3>
        <p>
          To simplify creation of <a>Keyframe</a> objects
          a <code>KeyframeDictionary</code> can be used.
        </p>
        <p>
          The members of the dictionary correspond to attributes in the
          <a>Keyframe</a> interface which provides a more complete description
          of their meaning and usage.
        </p>
        <dl title="dictionary KeyframeDictionary" class="idl">
          <dt>DOMString value = ""</dt>
          <dd>
            The value to assign to the target attribute or property at the given
            offset.
          </dd>
          <dt>double offset = 1</dt>
          <dd>
            A value between 0 and 1 (inclusive) representing the offset within
            the iteration duration of the animation where this value should
            appear.
          </dd>
          <dt>TimingFunction? timingFunction = null</dt>
          <dd>
            The timing function to apply between this keyframe and the
            next keyframe in any <a>KeyframeList</a> in which this object
            appears.
          </dd>
        </dl>
      </section>
      <section>
        <h3>The <code>PathAnimationEffect</code> interface</h3>
        <dl title="[Constructor] interface PathAnimationEffect
          : AnimationEffect" class="idl">
          <dt>attribute SVGPathSegList segments</dt>
          <dd>
            The list of segments that make up this path.
          </dd>
          <dt>attribute boolean rotate</dt>
          <dd>
            True if objects animating along this path should be rotated
            such that their positive x axis is aligned with the direction of
            movement along the path.
          </dd>
        </dl>
      </section>
      <section>
        <h3>The <code>GroupedAnimationEffect</code> interface</h3>
        <p>
          The <code>GroupedAnimationEffect</code> interface represents a
          set of animation effects that share the same
          <code>AnimationTemplate</code> parent.
        </p>
        <p class="todo">
          If the group contains multiple effects that target the same property
          does order in the group matter? If so, we need to add a means for
          re-ordering the group other than popping and pushing. For example,
          <code>insertBefore</code>.
        </p>
        <dl title="interface GroupedAnimationEffect : AnimationEffect"
          class="idl">
          <dt>Constructor (object properties)</dt>
          <dd>
            <p class="todo">
              TBD whilst we decide whether we need this interface or whether we
              can merge it with <a>KeyframeAnimationEffect</a> somehow.
            </p>
          </dd>
          <dt>readonly attribute unsigned long length</dt>
          <dd>
            The number of animation effects in the group.
          </dd>
          <dt>void clear()</dt>
          <dd>
            Removes all effects from this group.
          </dd>
          <dt>getter AnimationEffect? (unsigned long index)</dt>
          <dd>
            Returns the effect at <var>index</var> if it exists, or
            <code>null</code> otherwise.
          </dd>
          <dt>AnimationEffect add(AnimationEffect effect)</dt>
          <dd>
            <p>
              Appends <code>effect</code> to the end of the group such that
              <code>group.indexOf(<var>effect</var>)</code> equals
              <code>group.length - 1</code>.
            </p>
            <p class="todo">
              I'm assuming that <a>AnimationEffect</a>s can be shared amongst
              animations and groups.
              Or does <var>effect</var> need to be removed from any previous
              <a>AnimationEffect</a>s or <a>Animation</a>s first?
            </p>
          </dd>
          <dt>AnimationEffect? remove(unsigned long index)</dt>
          <dd>
            Removes the effect at <code>index</code> and returns it. If
            <var>index</var> is outside the range [0, <code>length</code>), then
            <code>null</code> is returned.
          </dd>
          <dt>long indexOf(AnimationEffect effect)</dt>
          <dd>
            Returns the index of <var>effect</var> within the group.
            If <var>effect</var> is not a member of the group, returns
            <code>-1</code>.
          </dd>
        </dl>
      </section>
      <section>
        <h3>Calculating animation values</h3>
        <div class="todo">
          This section needs more detail on when sampling is done.
          It also needs to be specified that an <a>Animation</a> with
          a <code>null</code> <a>AnimationEffect</a> still fires events.
        </div>
        <section>
          <h4>Calculating the animation value from an iteration value</h4>
          <p>
            If the <a>current iteration</a> is zero, or the 
            <var>accumulateOperation</var> is
            <code>"replace"</code>, then the 
            <var>animation value</var> is simply the iteration value, as
            defined below.
          </p>
          <p>
            When the animation time equals the iteration duration for the 
            first time for an animation, the current 
            <var>animation value</var> should be retained as the
            <var>end value</var> for the animation.
          </p>
          <p class="todo">
            Need to revise this definition since we can't assume the time at
            the end of the first iteration will be visited (we might be
            playing backwards, or have a <var>iteration start</var> greater
            than 1).
          </p>
          <p>
            If the <a>current iteration</a> is not zero and the
            <var>accumulateOperation</var> is
            <code>"accumulate"</code> then the 
            <var>animation value</var> is the <var>end value</var> accumulated
            <a>current iteration</a> times, with the 
            <var>iteration value</var> accumulated on top.
          </p>
          <p>
            If the <a>current iteration</a> is not zero and the
            <var>accumulateOperation</var> is
            <code>"merge"</code> then the
            <var>animation balue</var> is the <var>end value</var> merged
            with the <var>iteration value</var>, with an interpolation
            parameter equal to the current <var>time fraction</var>
          </p>
          <p class="todo">
            Need to review the following algorithms to check they still make
            sense now that the iteration fraction is not necessarily in the
            range [0, 1].
          </p>
        </section>
        <section>              
          <h4>Calculating the iteration value for a 
            <code>KeyframeAnimationEffect</code></h4>
          <p>
            When an <code>AnimationTemplate</code> contains a pointer to a
            <code>KeyframeAnimationEffect</code> <var>keyframes</var>, the
            <var>animation value</var> for that animation at given current time
            <var>t</var> is calculated according to the following steps:
          </p>
          <ol>
            <li>
              Convert <var>t</var> to the <var>time fraction</var> 
              (see <a href="#calculating-the-time-fraction"
              class="sectionRef"></a>).
            </li>
            <li>
              Generate a <var>sorted frame list</var> by sorting the list of
              <code>Keyframe</code> objects contained within the
              <code>KeyframeList</code> object stored in <var>keyframes.frames</var> 
              by their <var>offset</var>.
              If there are no frames in the <var>sorted frame list</var>
              then no animation occurs and the <var>iteration value</var> is
              just the <var>base value</var> of the property being animated.
            </li>
            <li>
              Otherwise, find the <var>after frame</var> by iterating through
              the <var>sorted frame list</var> until the last
              <code>Keyframe</code> with an <var>offset</var>
              larger than the <var>time fraction</var> is
              encountered.
            </li>
            <li>
              If the <var>after frame</var> is the first frame in the
              <var>sorted frame list</var>, then construct a 
              <var>before frame</var> with an <var>offset</var> of 0 and a
              value equal to the <var>base value</var> of the property being
              animated.
            </li>
            <li>
              If the <var>after frame</var> does not exist (i.e. all frames
              have an <var>offset</var> less than the <var>time 
              fraction</var>) then construct an <var>after frame</var> with
              an <var>offset</var> of 1 and a value equal to the
              <var>base value</var> of the property being animated, and
              Set the <var>before frame</var> to the last frame in the 
              <var>sorted frame list</var>.
            </li> 
            <li>
              Otherwise (the <var>after frame</var> exists and is not the
              first frame in the <var>sorted frame list</var>) set the 
              <var>before frame</var> to the frame immediately prior to the
              <var>after frame</var> in the <var>sorted frame list</var>.
            </li>
            <li>
              The <var>local time function</var> is the
              <var>timingFunction</var> of the <var>before frame</var>, if 
              it exists; otherwise the <var>timingFunction</var> of the
              <code>Animation</code> interface's <var>timing</var> attribute.
            </li>
            <li>
              Find the <var>local time fraction</var> by subtracting
              the <var>offset</var> of the <var>before frame</var> from
              the <var>time fraction</var>, then dividing the result
              by the difference between the <var>offset</var> of the
              <var>after frame</var> and the <var>offset</var> of the
              <var>before frame</var>.
            <li>
              Calculate the <var>effective time fraction</var> by applying
              the <var>local time function</var> to the <var>local time
              fraction</var>.
            <li>
              Calculate the <var>animation value</var> by linearly 
              interpolating the values of the <var>before frame</var> and
              <var>after frame</var>, using the 
              <var>effective time fraction</var> as interpolation parameter (see <a href="#linear-interpolation" class="sectionRef"></a>).
            </li>
          </ol>
        </section>
        <section>
          <h4>Calculating the iteration value for a 
            <code>PathAnimationEffect</code></h4>
          <p>
            When an <code>AnimationTemplate</code> contains a pointer to a
            <code>PathAnimationEffect</code> and <var>rotate</var> is set
            to false, the <var>animation value</var> for that animation at
            given current time <var>t</var> is the transform defined by a
            translation equal to the location on the path at <var>t</var>.
          </p>
          <p>
            When <var>rotate</var> is set to true, the
            <var>animation value</var> is the transform defined by the above
            translation followed by a rotation defined by the following
            process:
          </p>
          <ol>
            <li>
              Calculate the <var>normal</var> to the path at <var>t</var> (see <a href="#calculating-the-normal-to-a-path" class="sectionRef"></a>).
            </li>
            <li>
              Determine the <var>normal rotation</var>, which is given by 
              <var>atan2(normal.y, normal.x).
            </li>
            <li>
              The <var>rotation</var> is the transform that rotates by
              the <var>normal rotation</var>.
            </li>
          </ol>
        </section>
        <section>
          <h4>Calculating the iteration value for a 
            <code>GroupedAnimationEffect</code></h4>
          <p>
            When an <code>AnimationTemplate</code> contains a pointer to a
            <code>GroupedAnimationEffect</code>, the <var>animation
            value</var> for that animation at given current time <var>t</var> 
            is calculated by following the procedure outlined in
            <a href="#resolving-animation-stacks" class="sectionRef"></a>, 
            treating the list of <code>AnimationEffect</code> objects 
            contained within the <code>GroupedAnimationEffect</code> as 
            the animation stack and using an initial animation value 
            of 0 for all simple properties and id for transform.
          </p>
        </section>
      </section>
      <section>
        <h3>Custom animation effects</h3>
        <div class="informative">
          <p>
            In some situations the animation effects provided by Web Animations
            may be insufficient.
            For example, the animation effects defined here are only able to
            target certain CSS properties and DOM attributes.
            They are unable, therefore, to modify the <a
            href="#http://www.w3.org/TR/SVG11/struct.html#__svg__SVGSVGElement__currentScale"><code>currentScale</code></a>
            property of an SVG element to smoothly zoom the viewport without
            affecting the document content.
          </p>
          <p>
            In such cases where the provided animation effects do not provided
            needed functionality, an animation effect defined by script may be
            used.
            Such animation effects receive a time fraction from the timing
            model and are responsible for producing the animation effect
            corresponding to the specified time.
          </p>
          <p>
            Using an animation effect defined in script it is possible to
            animate not only previously un-animatable attributes and properties,
            but potentially anything that is accessible via script, including
            even producing audio or creating vibrations.
          </p>
          <p>
            For example, using an animation effect that draws to a <a
            href="http://www.w3.org/TR/html5/the-canvas-element.html#the-canvas-element"><code>canvas</code></a>
            element it is possible to produce a complex animated effect
            featuring patterns that may be difficult to create using CSS or
            SVG.
            Compared to using the <a
            href="http://www.w3.org/TR/animation-timing/">WindowAnimationTiming</a>
            interface, this approach ensures the animation is frame-rate
            independent and can be paused, reversed, eased with timing effects,
            accelerated, synchronized with other animations, and be controlled
            in the same manner as any other Web Animations animation without any
            additional programming.
          </p>
        </div> <!-- informative -->
        <div class="annotation">
          <p>
            I think we want two types of custom animation effects.
            Following is the general-purpose animate-anything kind of effect.
            The other type, which is not defined here, is the one that can
            participate in the animation sandwich just like any other.
          </p>
          <p>
            This, second, native-like animation effect, would have the
            following features:
          </p>
          <ul>
            <li>Shares the same function signature as
                <code><a>AnimationEffect</a>.sample</code></li>
            <li>Gets passed the underlying value and passes out the animated
                value.</li>
            <li>Has a target property and is sorted against other
                <a>AnimationEffect</a> objects (including platform
                objects)</li>
            <li>Can be added as a child of
                a <a>GroupedAnimationEffect</a>.</li>
          </ul>
          <p>
            That's a bit more difficult since you have to be careful that the
            custom effect doesn't do anything naughty while you're in the
            middle of compositing the animation sandwich.
            I think we should postpone this until Web Animations 2.
          </p>
        </div>
        <section>
          <h4>Execution order of custom animation effects</h4>
          <p>
            Custom animation effects allow authors to define animation effects
            using script.
            Such animation effects are not limited to a single CSS property or
            DOM attribute and therefore the steps for assessing their order of
            execution differs from regular animation effects.
          </p>
          <p>
            Custom animation effects are executed after all other
            <a>AnimationEffect</a> objects have completed and applied their
            effects to their targets.
          </p>
          <p class="issue">
            Need to define this more precisely.
            Are styles flushed?
            Presumably they are.
            Can we suspend reflow for the duration of executing the script-based
            animation effects and just do it once afterwards?
          </p>
          <p>
            Within the set of custom animation effects, the order of execution
            is mostly the same as that for other animation effects and is
            defined in <a href="#the-global-animation-stack"
            class="sectionRef"></a>.
            However, custom animation effects may also override this
            ordering through the <code>priority</code> attribute, which, if
            defined, specifies the priority of the effects with lower numbers
            are executed sooner.
          </p>
          <p>
            In deciding which of two <a>CustomAnimationEffect</a> objects,
            <var>A</var> and <var>B</var>, should be executed the following
            rules are applied.
          </p>
          <ol>
            <li>Sort <var>A</var> and <var>B</var> based on their
                <code>priority</code> such that lower priorities are sorted
                first.
                If either does not have a defined <code>priority</code>,
                then treat the priority as being positive infinity for the
                purposes of sorting.</li>
            <li>If <var>A</var> and <var>B</var> have the same priority,
                sort according to the <code>startTime</code>s of the
                <a>TimedItem</a>s with which <var>A</var> and <var>B</var> are
                associated such that earlier start times are sorted first.
            <li>If <var>A</var> and <var>B</var> have the same priority and
                start time, sort by the position of the corresponding
                <a>Animation</a> objects occur within the animation tree (see
                issue below).</li>
          </ol>
          <p>
            Items sorted earlier, are executed first.
          </p>
          <p class="issue">
            That last point is quite wrong. I don't think we've specified
            exactly what script order is in <a
            href="#the-global-animation-stack" class="sectionRef"></a>.
            But I wonder if it makes more sense to effectively enumerate all the
            script-based nodes in the animation tree using some well-defined
            order and use that index.
            Can that be done efficiently?
          </p>
        </section>
        <section>
          <h4>The <code>CustomAnimationEffect</code> callback interface</h4>
          <p>
            Custom animation effects can be defined in script using the
            <a>CustomAnimationEffect</a> interface.
          </p>
          <p class="issue">
            Should this be a dictionary?
            I'd like to make <code>clone</code> optional.
          </p>
          <div title="callback interface CustomAnimationEffect" class="idl">
            <dt>attribute unsigned integer priority</dt>
            <dd>
              The order in which this animation effect will be executed in
              relation to other custom animation effects such that items with
              a lower priority are executed earlier as defined in <a
              href="#execution-order-of-custom-animation-effects"
              class="sectionRef"></a>.
            </dd>
            <dt>void sample ()</dt>
            <dd>
              The callback used to produce the animation effect corresponding to
              the sample time determined by the timing model.
              <dl class="parameters">
                <dt>double? timeFraction</dt>
                <dd>
                  The distance within a single iteration of the animation effect
                  of the current sample.
                  When this is <code>null</code>, the callback object SHOULD
                  remove the animation effect.
                </dd>
                <dt>double currentIteration</dt>
                <dd>
                  The current iteration index beginning with zero for the first
                  iteration.
                </dd>
                <dt>AnimationTarget? target</dt>
                <dd>
                  The element to which the effect should be applied if any.
                  When this method is called as a result of this object being
                  associated with an <a>Animation</a> object, it will be
                  <code><a>Animation</a>.targetElement</code>
                </dd>
              </dl>
            </dd>
            <dt>CustomAnimationEffect clone ()</dt>
            <dd>
              Creates an independent copy of this object.
            </dd>
          </div>
          <p class="issue">
            Do we need to pass in the <a>TimedItem</a> as well?
            If possible I'd prefer not to but it may necessary for some types of
            effect.
            Might be an additional parameter to add later if it proves
            necessary?
          </p>
          <p class="issue">
            I think we will also need to pass the previous time fraction.
            Animations will often use this to check if they are paused, playing
            in reverse etc.
            They can track this themselves but then you need a separate object
            everywhere you use it.
          </p>
        </section>
      </section>
    </section>

    <section>
      <h2>Primitive animation operations</h2>
      <section>
        <h3>Linear interpolation</h3>
        <section>
          <h4>Linear interpolation of paths</h4>
          <p class="todo">Write me</p>
        </section>
        <section>
          <h4>Linear interpolation of transforms</h4>
          <p class="todo">Write me</p>        
        </section>
        <section>
          <h4>Linear interpolation of primitive values</h4>
          <p class="todo">Write me</p>
        </section>
      </section>
      <section>
        <h3>Calculating the normal to a path</h3>
        <p class="todo">Write me</p>
      </section>
    </section>
    <section>
      <h2>Combining animations</h2>
      <section>
        <h3>The Global Animation Stack</h3>
        <p>
          When multiple <a>in effect</a> animations target the same element, the
          animations are ordered into a stack which resolves how those 
          animations combine.
          This stack is sorted by animation <var>start time</var>.
          Where multiple animations have the same start time, those animations
          are sorted in document order (for animations from the DOM) and script
          order (for animations from the API). Script animations are always
          sorted after DOM animations.
        </p>
        <p>
          Other operations also generate animation stacks - for example, 
          grouping multiple animations using a 
          <code>GroupedAnimationEffect</code>.
        </p>
        <p>
          An animation stack may be thought of as a single stack with all
          animations sorted into it, or a stack per animating element, as
          animations on one element cannot effect the course of animations on 
          another element.
        </p>
        <p class="note">
          The start time of an animation refers to the time when the animation
          is specified to begin as recorded in the
          <code>TimedItem.startTime</code> property, that is, before applying
          any <var>start delay</var>.
        </p>
        <p class="note">
          The stacking order of animations is independent of the
          current play direction of individual animations and animation
          groups.
        </p>
      </section>
      <section>
        <h3>Resolving Animation Stacks</h3>
        <p>
          In order to resolve an animation stack, an initial animation
          value is required for each element and property animated by the
          stack.
          To calculate a current animation value for elements and properties
          from an animation stack, an animation value is generated for each
          animation in the stack 
          (see <a href="#calculating-animation-values" class="sectionRef"></a>).
          The cumulative animation result for each element and property is first
          initialised to the relevant initial animation value.
          Starting at the bottom of the stack (i.e. earliest start time) and
          working up, as animation results are encountered for an element
          and property, these are merged into the cumulative animation result
          using the animation combinator stored in the 
          <code>AnimationEffect</code> that generated the result.
          Once all animation results in the stack are processed, the resulting
          cumulative animation values are the current animation values for
          each property of each element that is animated.
        </p>
      </section>
      <section>
        <h3>Animation combinators</h3>
        <p>
          When an animation applies to a target and property that animations
          earlier in the animation stack have already applied to, the
          cumulative animation result from the stack is composited with the new
          animation to produce a new cumulative animation result.
          The possible combinators are defined by the <a>CompositeOperation</a>
          enumeration.
        </p>
        <section>
          <h4>The REPLACE combinator</h4>
          <p>
            When an animation <code>a</code> is composited over a cumulative
            animation result <code>c</code> using the REPLACE combinator, the
            new cumulative animation result is always <code>a</code>.
          </p>
        </section>
        <section>
          <h4>The ACCUMULATE combinator</h4>
          <p>
            When a path animation <code>a</code> is composited over a
            cumulative animation result <code>c</code> using the ACCUMULATE
            combinator, the effective transform of <code>a</code> is calculated.
            This transform is then post-multiplied to the cumulative animation
            result to generate a new cumulative animation result.
          </p>
          <p>
            When a transform animation <code>a</code> is composited over a
            cumulative animation result <code>c</code> using the ACCUMULATE
            combinator, <code>a</code> is post-multiplied to the cumulative
            animation result to generate a new cumulative animation result.
          </p>
          <p>
            When a simple animation (i.e. an animation which is not a path
            animation nor a transform animation) <code>a</code> is composited
            over a cumulative animation result <code>c</code> using the
            ACCUMULATE combinator, the new cumulative animation result is the
            sum of <code>a</code> and <code>c</code>, clipped if necessary to
            the appropriate domain.
          </p>
        </section>
        <section>
          <h4>The MERGE combinator</h4>
          <p>
            All MERGE operators are governed by an interpolation parameter
            <code>p</code> that is calculated as the ratio of
            <code>(currentTime - parent.startTime)
            / parent.animationDuration</code>, where <code>parent</code> is the
            <code>AnimationTemplate</code> which references the
            <code>AnimationEffect</code> that is being composited.
          </p>
          <p>
            When a path animation <code>a</code> is composited over a
            cumulative animation result <code>c</code> using the MERGE
            combinator, the effective transform of <code>a</code> is
            calculated.
            This transform is then interpolated with <code>c</code> using the
            rules provided in [[!CSS3-2D-TRANSFORMS]] to provide the new
            cumulative animation result.
          </p>
          <p>
            When a transform animation <code>a</code> is composited over a
            cumulative animation result <code>c</code> using the MERGE
            combinator, <code>a</code> is interpolated with <code>c</code>
            using the rules provide in [[!CSS3-2D-TRANSFORMS]] to provide the 
            new cumulative animation result.
          </p>
          <p>
            When a simple animation <code>a</code> is composited over a
            cumulative animation result <code>c</code> using the MERGE
            combinator, the new cumulative animation result is calculated as
            the weighted sum of <code>a</code> and <code>c</code>, with weights
            of <code>(1-p)</code> and <code>p</code> respectively.
          </p>
        </section>
      </section>
      <section>
        <h3>Current values, animation values, and the override stylesheet</h3>
        <section>
          <h4>Current values</h4>
          <p>
            The <var>current value</var> of a given property and object is the
            value generated for that property by computing a current style for
            that object without taking the override stylesheet into account.
          </p>
        </section>
        <section>
          <h4>The override stylesheet</h4>
          <p>
            The override stylesheet contains output animation values and
            acts with a higher priority than all other stylesheets. However,
            !important rules from all other stylesheets act with a higher priority
            than the override stylesheet.

            The override stylesheet is regenerated for each timepoint in a
            document using the process described below.
          </p>
        </section>
        <section>
          <h4>Animation values</h4>
          <p class="todo">
            We already have a section with the heading "animation values".
            Ideally they should be unique so they're easy to target by named
            anchor.
          </p>
          <p>
            Animation values for all animated properties are generated at
            each time point according to the following process, then inserted
            into the override stylesheet.
          </p>
          <ol>
            <li>
              A global animation stack is generated as described in 
              <a href="#the-global-animation-stack" class="sectionRef"></a>.
            </li>
            <li>
              An initial animation value is generated by taking the current
              style for each object (ignoring the override stylesheet) and
              extracting a value for each animated property.
            </li>
            <li>
              The global animation stack is resolved using the initial animation
              value and the process in 
              <a class="sectionRef" href="#resolving-animation-stacks"></a>.
            </li>
            <li>
              The current animation values generated by this process are inserted
              into the override stylesheet.
            </li>
            <p class="todo">
              Do we need to work out how to use the override stylesheet for
              elements that don't have an id but are targetted for animations?
            </p>
          </ol>
        </section>
      </section>
    </section>

    <section>
      <h2>Animation templates</h2>
      <div class="informative">
      <p>
        It is sometimes necessary to apply the same animation effect to a series
        of targets.
        Animation templates provide a means for the same set of animation
        properties to be applied repeatedly to a number of targets
        whilst maintaining a link such that changes to the template are
        reflected at each place where the template is applied.
      </p>
      <p>
        In concrete terms, an <a>AnimationTemplate</a> object is used to create
        multiple <a>Animation</a> objects each of which maintains a link back to
        the template via its <code>template</code> property.
        Such <a>Animation</a> objects are said to be <dfn>linked</dfn> to
        a template.
      </p>
      <p>
        The timing and animation parameters of <a>linked</a> animations cannot
        be modified directly.
        Rather, changes are made to the template which is then echoed to all
        animations linked to the same template.
        In order to modify the timing and animation parameters of
        a <a>linked</a> animation directly, it must first be unlinked using the
        <code>unlink</code> method.
      </p>
      <p>
        Note that run-time properties of a <a>linked</a> animation such as its
        <var>start time</var> and <var>time drift</var> can still be modified.
        Only those properties attached to the <code>timing</code> and
        <code>effect</code> properties of a <a>linked</a> <a>Animation</a>
        object are read-only.
      </p>
      <p>
        Unlinked animations can be linked to a template by:
      </p>
      <ul>
        <li>assigning the <var>template</var> property to an
        <a>AnimationTemplate</a> <span class="todo">(Is this right? Are we going
        to do this?)</span>, or</li>
        <li>calling <code>templatize</code> to create a new
        <a>AnimationTemplate</a> with properties set to reflect the current
        state of the <a>Animation</a> object on which it is called.</li>
      </ul>
      <p class="todo">
        Provide some javascript sample here demonstrating?
      </p>
      </div> <!-- informative -->
      <section>
        <h3>The <code>AnimationTemplate</code> interface</h3>
        <p>
          <dl title="[Constructor] interface AnimationTemplate : TimedTemplate"
            class="idl">
            <dt>attribute (AnimationEffect or CustomAnimationEffect)
              effect</dt> <dd>
              The animation effect to apply.
            </dd>
          </dl>
        </p>
      </section>
      <section>
        <h3>The <code>TimedTemplate</code> interface</h3>
        <p>
          Both the timing of an <code>AnimationTemplate</code> and the methods
          for creating an <code>Animation</code> from an
          <code>AnimationTemplate</code> are specified on the
          <code>TimedTemplate</code> since this behavior is shared with
          animation groups (see <a href="#group-templates"
          class="sectionRef"></a>).
        </p>
        <p class="todo">
          Should we allow live lists to be passed in? i.e. selectors etc.?
        </p>
        <dl title="interface TimedTemplate" class="idl">
          <dt>attribute Timing timing</dt>
          <dd>
            The timing parameters to use for generated timed items.
          </dd>
          <dt>TimedItem animate ()</dt>
          <dd>
            <p>
              Creates an independent <code>TimedItem</code> and appends it
              to <code>element.ownerDocument.animationTimeline</code>.
            </p>
            <p>
              This allows the following sort of usage:
            </p>
            <pre class="example sh_javascript">
              anim.animate(document.getElementById("a"));
            </pre>
            <p>
              The specific steps for instantiating a
              <code>TimedTemplate</code> depends on its concrete type and is
              described in <a href="#instantiating-an-animationtemplate"
              class="sectionRef"></a> and <a
              href="#instantiating-an-animationgrouptemplate"
              class="sectionRef"></a>.
            </p>
            <dl class="parameters">
              <dt>AnimationTarget target</dt>
              <dd>
                The element or pseudo-element to be targetted.
              </dd>
              <dt>optional double startTime</dt>
              <dd>
                <p>
                  The start time for the generated animations
                  expressed in seconds in the iteration time space of the
                  <code>AnimationGroup</code> to which it is
                  appended (see <a href="#time-spaces" class="sectionRef"></a>).
                </p>
                <p>
                  If this parameter is not specified it will default to the
                  current iteration time of the
                  <code>AnimationGroup</code> to which it is
                  appended if it is not <code>null</code>, otherwise it will
                  default to zero.
                </p>
              </dd>
            </dl>
          </dd>
          <dt>sequence&lt;TimedItem&gt; animate ()</dt>
          <dd>
            <p>
              Creates a series of independent <code>TimedItem</code>
              objects, one for each element in <code>target</code>.
              As with <code>animate(AnimationTarget target, double
              startTime)</code> each such <code>TimedItem</code> object is
              appended to <code>element.ownerDocument.animationTimeline</code>.
            </p>
            <p>
              This allows the following sort of usage:
            </p>
            <pre class="example sh_javascript">
  anim.animate([document.getElementById("a"), document.getElementById("b")]);
  anim.animate(document.querySelectorAll("div.warning"));
  anim.animate(document.getElementsByTagName("button"));
  anim.animate(document.getElementById("group").childNodes);
            </pre>
            <p>
              The specific steps for instantiating a
              <code>TimedTemplate</code> depends on its concrete type and is
              described in <a href="#instantiating-an-animationtemplate"
              class="sectionRef"></a> and <a
              href="#instantiating-an-animationgrouptemplate"
              class="sectionRef"></a>.
            </p>
            <dl class="parameters">
              <dt>sequence&lt;Node&gt; targets</dt>
              <dd>
                An sequence of <code>Node</code>s to be animated.
                Any nodes in the sequence that are not of type
                <code>ELEMENT_NODE</code> will be ignored.
              </dd>
              <dt>optional double startTime</dt>
              <dd>
                As with <code>animate(AnimationTarget target, optional double
                  startTime)</code>.
              </dd>
            </dl>
          </dd>
          <dt>TimedItem animateWithParent ()</dt>
          <dd>
            <p>
              Similar to <code>animate</code>, this method creates
              independent <code>TimedItem</code> object(s) for the
              elements in <code>target</code>.
              However, the resulting items are appended to the given
              <code>parentGroup</code>, if provided.
              If <code>parentGroup</code> is <code>null</code>, the
              <code>TimedItem</code> objects will not be added to any
              group.
            </p>
            <dl class="parameters">
              <dt>AnimationTarget target</dt>
              <dd>
                As with <code>animate</code>.
              </dd>
              <dt>AnimationGroup? parentGroup</dt>
              <dd>
                The animation group to which animations should be appended.
              </dd>
              <dt>optional double startTime</dt>
              <dd>
                <p>
                  The start time for the generated animations
                  expressed in seconds in the iteration time space of the
                  <code>AnimationGroup</code> to which it is
                  appended (see <a href="#time-spaces" class="sectionRef"></a>).
                </p>
                <p>
                  If this parameter is not specified it will default to the
                  current iteration time of <code>parentGroup</code>.
                  If <code>parentGroup</code> is <code>null</code>,
                  this parameter will default to zero.
                </p>
              </dd>
            </dl>
          </dd>
          <dt>sequence&lt;TimedItem&gt; animateWithParent (
            sequence&lt;Node&gt; targets,
            AnimationGroup? parentGroup,
            optional double startTime)</dt>
          <dd>
            As with <code>animateWithParent(AnimationTarget target,
              AnimationGroup? parentGroup,
              optional double startTime)</code> except
            one <code>TimedItem</code> is created for each
            <code>Node</code> in <code>target</code> that is of type
            <code>ELEMENT_NODE</code>.
          </dd>
          <dt>TimedItem animateLive (AnimationTarget target,
            optional double startTime)</dt>
          <dd>
            As with <code>animate</code> with the exception that the
            <code>TimedItem</code> objects generated by this method are
            live.
          </dd>
          <dt>sequence&lt;TimedItem&gt; animateLive (
            sequence&lt;Node&gt; targets, optional double startTime)</dt>
          <dd>
            As with <code>animate</code> with the exception that the
            <code>TimedItem</code> objects generated by this method are
            live.
          </dd>
          <dt>TimedItem animateLiveWithParent
            (AnimationTarget target, AnimationGroup? parentGroup,
             optional double startTime)</dt>
          <dd>
            As with <code>animateWithParent</code> with the exception that the
            animations generated by this method are live.
          </dd>
          <dt>sequence&lt;TimedItem&gt; animateLiveWithParent
            (sequence&lt;Node&gt; targets, AnimationGroup? parentGroup,
             optional double startTime)</dt>
          <dd>
            As with <code>animateWithParent</code> with the exception that the
            animations generated by this method are live.
          </dd>
        </dl>
      </section>
      <section>
        <h3>Instantiating an <code>AnimationTemplate</code></h3>
        <p>
          The procedure for instantiating an <code>AnimationTemplate</code>,
          <var>template</var>, given a list of target elements and an optional
          <var>parent group</var>, is as follows:
        </p>
        <ol>
          <li>
            Create an empty sequence of <code>Animation</code> objects.
          </li>
          <li>
            For each <var>element</var> in the list of target elements:
            <ol>
              <li>
                Create a new <code>Animation</code> object, <var>anim</var>.
              </li>
              <li>
                Set the <code>timing</code> and <code>effect</code>
                properties of <var>anim</var> to copies
                <code>template.timing</code> and
                <code>template.effect</code>.
              </li>
              <li>
                If <var>parentGroup</var> is not specified, let
                <var>parentGroup</var> be
                <code><var>element</var>.ownerDocument.animationTimeline</code>.
              </li>
              <li>
                Append <var>element</var> to <var>parentGroup</var>.
              </li>
              <li>
                Append <var>element</var> to the sequence of
                <code>Animation</code> objects.
              </li>
            </ol>
          </li>
          <li>
            Return the sequence of <code>Animation</code> objects.
          </li>
        </ol>
      </section>
      <section>
        <h3>Group templates</h3>
        <p>
          As with animations, templates can also be created for animation
          groups.
        </p>
        <p class="todo">
          Lots of questions here about how this should work.
        </p>
      </section>
      <section>
        <h3>The <code>AnimationGroupTemplate</code> interface</h3>
        <p class="todo">
          TBD
        </p>
        <dl title="interface AnimationGroupTemplate : TimedTemplate"
          class="idl">
          <dt>void clear ()</dt>
          <dd>
            Removes all child items from the group.
          </dd>
          <dt>getter TimedTemplate? (unsigned long index)</dt>
          <dd>
            Returns the template item at <code>index</code>.
            If <code>index</code> is greater than or equal to
            <code>length</code> returns <code>null</code>.
          </dd>
          <dt>setter TimedTemplate (unsigned long index,
                                    TimedTemplate newItem)</dt>
          <dd>
            <p>
              Replaces the item at <code>index</code> with
              <code>newItem</code> by calling
              <code>splice(index, 1, newItem)</code>.
            </p>
            <p>
              Returns <code>newItem</code>.
            </p>
            <p>
              The behavior of this method is identical to
              the equivalent setter in <code>AnimationGroup</code>
              except that DOMExceptions of type HierarchyRequestError are not
              thrown.
            </p>
          </dd>
          <dt>sequence&lt;TimedTemplate&gt; add (
                TimedTemplate newItem, TimedTemplate... otherItems)</dt>
          <dd>
            <p>
              Add <code>newItem</code> and each <code>otherItems</code> as the
              last item(s) in the group by calling <code>splice(group.length, 0,
              newItem, otherItem1, ... otherItemN)</code>.
            </p>
            <p>
              Returns a sequence containing the added items:
              <code>[newItem, otherItem1, ... otherItemN]</code>.
            </p>
          </dd>
          <dt>sequence&lt;TimedTemplate&gt; remove (
                long index, optional unsigned long count = 1)</dt>
          <dd>
            <p>
              Removes the item(s) at <code>index</code> by calling
              <code>splice(index, count)</code>.
            </p>
            <p>
              Returns the removed items.
            </p>
          </dd>
          <dt>
            sequence&lt;TimedTemplate&gt; splice ()
          </dt>
          <dd>
            <p>
              Modifies the list of children of this group by first removing
              <code>deleteCount</code> items from <code>start</code> followed by
              adding <code>newItems</code> at the same point.
            </p>
            <p>
              Returns a sequence of the items removed from group during the
              removal step (regardless of whether these items were re-added
              during the addition step).
            </p>
            <p>
              As with <code>AnimationGroup.slice</code> the operation of
              slice is based on <a
              href="http://www.ecma-international.org/publications/files/ECMA-ST-ARCH/ECMA-262%205th%20edition%20December%202009.pdf#page=140">ECMAScript
              5's Array.prototype.splice</a>.
            </p>
            <p>
              The operation of this method is identical to that of
              <code>AnimationGroup.slice</code> with the notable difference
              that DOMExceptions of type HierarchyRequestError are not thrown
              since there is no <code>AnimationGroupTemplate</code>
              corresponding to a document timeline.
            </p>
            <dl class="parameters">
              <dt>long start</dt>
              <dd>
                The index at which items should be removed and inserted.
                Negative indices represent an offset from the end of the list of
                items.
                This value is clamped to the range [-<code>length</code>,
                <code>length</code>].
              </dd>
              <dt>unsigned long deleteCount</dt>
              <dd>
                The number of items to remove from the group beginning at
                <code>start</code>.
                Negative values are clamped to zero, and all other values are
                clamped such that
                0 &lt; <code>start</code> + <code>deleteCount</code> &le;
                length.
              </dd>
              <dt>sequence&lt;TimedTemplate&gt; newItems</dt>
              <dd>
                The items to be added at <code>start</code>.
                Each item, if it already has a parent group (including this
                group), is first removed from its parent group before being
                added to this group.
              </dd>
            </dl>
          </dd>
          <dt>
            sequence&lt;TimedTemplate&gt; splice (long start,
              unsigned long deleteCount, TimedTemplate... newItem)
          </dt>
          <dd>
            An overload of <code>splice</code> to take a variadic list of items
            rather than requiring a sequence.
            The operation is identical to <code>splice(unsigned long start,
            unsigned long deleteCount, sequence&lt;TimedTemplate&gt;
            newItems)</code>.
          </dd>
          <dt>long indexOf (TimedTemplate item)</dt>
          <dd>
            Returns the index of <code>item</code> within the group.
            If <code>item</code> is not in the group, returns <code>-1</code>.
          </dd>
        </dl>
      </section>
      <section>
        <h3>The <code>ParGroupTemplate</code> interface</h3>
        <p>
          <a>ParGroup</a> objects can be created from <a>ParGroupTemplate</a>
          objects.
        </p>
        <dl title="[Constructor] interface ParGroupTemplate
          : AnimationGroupTemplate"
          class="idl">
        </dl>
      </section>
      <section>
        <h3>The <code>SeqGroupTemplate</code> interface</h3>
        <p>
          <a>SeqGroup</a> objects can be created from <a>SeqGroupTemplate</a>
          objects.
        </p>
        <dl title="[Constructor] interface SeqGroupTemplate
          : AnimationGroupTemplate" class="idl">
        </dl>
      </section>
      <section>
        <h3>Instantiating an <code>AnimationGroupTemplate</code></h3>
        <p class="todo">
          TBD. This is probably all wrong.
        </p>
        <p>
          The procedure for creating an <code>AnimationGroup</code> from
          an <code>AnimationGroupTemplate</code>, <var>template</var>,
          given a list of target elements, and optionally given a <var>parent
          group</var> follows.
        </p>
        <p>
          Note that <code>ParGroupTemplate</code> objects produce
          <code>ParGroup</code> objects and likewise
          <code>SeqGroupTemplate</code> objects produce <code>SeqGroup</code>
          objects.
          In the following description the <code>AnimationGroupTemplate</code>
          and <code>AnimationGroup</code> types should be substituted with the
          concrete types in use.
        </p>
        <ol>
          <li>
            Create an empty sequence to hold the generated
            <code>AnimationGroup</code> objects.
          </li>
          <li>
            For each <var>element</var> in the list of target elements:
            <ol>
              <li>
                Create a new <code>AnimationGroup</code> object,
                <var>group</var>.
              </li>
              <li>
                Set the <code>timing</code> property of <var>group</var> to
                a copy of <code>template.timing</code>.
              </li>
              <li>
                For each <var>child</var> in <var>template</var>, call
                <code><var>child</var>.animateWithParent(<var>element</var>,
                <var>group</var>, <code>startTime</code>)</code> or
                <code><var>child</var>.animateLiveWithParent(<var>element</var>,
                <var>group</var>, <code>startTime</code>)</code> depending on
                whether this procedure was invoked with <code>animate</code> or
                <code>animateLive</code>.
              </li>
              <li>
                If <var>parentGroup</var> is not specified, let
                <var>parentGroup</var> be
                <code><var>element</var>.ownerDocument.animationTimeline</code>.
              </li>
              <li>
                Append <var>group</var> to <var>parentGroup</var>.
              </li>
              <li>
                Append <var>group</var> to the sequence of
                <code>AnimationGroup</code> objects.
              </li>
            </ol>
          </li>
          <li>
            Return the sequence of <code>AnimationGroup</code> objects.
          </li>
        </ol>
      </section>
    </section>

    <section>
      <h2>Synchronizing with media</h2>
      <div class="todo">
        Currently investigating integration with HTML5's MediaController object.
      </div>
      <section>
        <h3>The <code>MediaItem</code> interface</h3>
        <dl title="interface MediaItem : TimedItem" class="idl">
          <dt>attribute HTMLMediaElement element</dt>
          <dd>
            A pointer to the element?
          </dd>
        </dl>
      </section>
    </section>

    <section>
      <h2>Timing events</h2>
      <p>
        As timed items play they report changes to their status through
        <a>TimingEvent</a>s.
      </p>
      <div class="annotation">
        <p><strong>Relationship to CSS and SVG events</strong></p>
        <p>
          CSS defines <code>AnimationEvent</code>s and
          <code>TransitionEvent</code>s and SVG defines <code>TimeEvent</code>s.
          The proposal here is to dispatch <a>TimingEvent</a>s in parallel to
          these events.
          This has the following properties:
        </p>
        <ul>
          <li>It is possible to register for <em>just</em> CSS animation events,
          or <em>just</em> CSS transition events, or <em>just</em> SVG time
          events, or <em>all</em> animation-related events
          (by registering for the timing events defined here).</li>
          <li>Backwards compatibility&mdash;existing content continues to work
          as is.</li>
        </ul>
        <p>
          An alternative is to make CSS and SVG events subclass
          <a>TimingEvent</a> and just fire the one event.
          Two issues arrive with this.
          Firstly, the event type would change on the subclasses so it wouldn't
          be possible to catch all "start" events, for example.
          Secondly, the propagation path for SVG events is different since they
          are fired at the animation template element rather than the animation
          target element.
        </p>
        <p>
          Nevertheless, there may be alternative approaches here such as
          augmenting CSS Animation events only and firing them from the API
          (although that may cause compatibility issues when SVG animations
          start reporting events to content expecting only CSS animations).
        </p>
      </div>
      <section>
        <h3>The <code>TimingEvent</code> interface</h3>
        <dl title="interface TimingEvent : Event" class="idl">
          <dt>Constructor
              (DOMString type, optional TimingEventInit eventInitDict)</dt>
          <dd>
            Constructs a new <a>TimingEvent</a> object as described in <a
            href="http://dvcs.w3.org/hg/domcore/raw-file/tip/Overview.html#constructing-events">Constructing
            events</a> [[!DOM4]].
          </dd>
          <dt>attribute double documentTime</dt>
          <dd>
            <p>
              The <code>currentTime</code> of the <a>DocumentTimeSource</a> with
              which the <a>TimedItem</a> is associated when the event was
              dispatched.
            </p>
            <div class="annotation">
              <p>
                I think document time will be much more useful than global time.
                For the rarer case that you want to synchronise animations
                between documents using events, I anticipate
                <a>DocumentTimeSource</a> will have a method to convert
                a document to global time and vice-versa and/or convert times
                from one <a>DocumentTimeSource</a> to another
                <a>DocumentTimeSource</a>.
              </p>
              <p>
                When we come to define animations that aren't necessarily linked
                to a document time source we'll need to make this nullable or
                redefine it to mean "root time source".
              </p>
            </div>
          </dd>
          <dt>attribute double localTime</dt>
          <dd>
            <p>
              The <code>iterationTime</code> of the <a>TimeSource</a> with which
              the <a>TimedItem</a> is associated when the event was dispatched.
              For animations that do not belong to an <a>AnimationGroup</a> this
              will be equal to <code>documentTime</code>.
            </p>
            <p class="annotation">
              If we allow animations to be associated with, for example,
              MediaControllers, we'll need to revise the above description to
              cover more than just <a>AnimationGroup</a>s.
            </p>
            <p class="annotation">
              If we rename <a>item time</a> to local time we'll need to rename
              this.
              Note that the time given here is in <em>parent iteration
              time</em>.
              This is the same time space used for <code>startTime</code> and
              <code>endTime</code>.
              This is the most useful time space if, for example, you receive
              a timing event and want to add a new animation that synchronises
              with the item that dispatched the event by adding it to the same
              time source (e.g. group).
            </p>
          </dd>
          <dt>attribute unsigned long? iterationIndex</dt>
          <dd>
            The value of <code>currentIteration</code> on the target
            <a>TimedItem</a> when the event was dispatched.
          </dd>
        </dl>
        <p class="issue">
          Suggestions for naming? CSS has taken <code>AnimationEvent</code> and
          <code>TransitionEvent</code> and SVG has <code>TimeEvent</code>.
          Call it <code>SyncEvent</code>?
          Or we could just augment <code>AnimationEvent</code> since it has
          a similar propagation path.
        </p>
        <dl title="dictionary TimingEventInit" class="idl">
          <dt>double documentTime = 0</dt>
          <dd></dd>
          <dt>double localTime = 0</dt>
          <dd></dd>
          <dt>double iterationIndex = 0</dt>
          <dd></dd>
        </dl>
      </section>
      <section>
        <h3>Types of <a>TimingEvent</a></h3>
          <dt>timingstart</dl>
          <dd>
            Occurs at the moment when an item enters an <a>animation
            interval</a> (from either direction).
            <ul>
              <li>Bubbles: yes</li>
              <li>Cancelable: no</li>
            </ul>
          </dd>
          <dt>timingiteration</dl>
          <dd>
            Occurs at the moment when a repeating item's
            <code>currentIteration</code> changes excluding changes to and from
            <code>null</code>.
            <ul>
              <li>Bubbles: yes</li>
              <li>Cancelable: no</li>
            </ul>
          </dd>
          <dt>timingend</dl>
          <dd>
            Occurs at the moment when an item leaves an <a>animation
            interval</a> (from either direction).
            <ul>
              <li>Bubbles: yes</li>
              <li>Cancelable: no</li>
            </ul>
          </dd>
          <dt>timingcancel</dl>
          <dd>
            Occurs when <code>TimedItem.cancel</code> is called.
            In this case, a <em>timingend</em> event is not fired
            (see the description of
             <a href="#widl-TimedItem-cancel-void">TimedItem.cancel</a>).
            <ul>
              <li>Bubbles: yes</li>
              <li>Cancelable: no</li>
            </ul>
          </dd>
        </dl>
        <p class="annotation">
          The naming here is not great.
          Would <code>syncstart</code> be any better?
          If we augment <code>AnimationEvent</code> then at least we could use
          <code>animationstart</code> etc.
        </p>
        <div class="issue">
          <p>
            Other potential event types for a later version:
          </p>
          <ul>
            <li><em>pause</em> &mdash;
              fires whenever <code>paused</code> is newly true.<br>
              Use case: show a graphic overlay to mark a cartoon as paused.<br>
              Likewise <em>unpause</em>.</li>
            <li><em>seek</em> &mdash;
              fires whenever <code>currentTime</code> is set on the item or an
              ancestor.<br>
              Use case: Acts as a signal that intermediate events may have been
              dropped (see <a href="#event-dispatch-during-seeking"
              class="sectionRef"></a>).
              For example, if you have an iteration event handler that assumes
              it will get one call per iteration, then a seek event would be
              a cue that you need to check <code>iterationIndex</code> and
              adjust.
              Also, if you were implementing something like SVG's syncbase
              timing with script you often need to do some bookkeeping on
              a seek.
            </li>
            <li><em>directionchange</em> &mdash;
              fires whenever the effective direction of the item changes (due to
              the direction attribute, changes to playbackRate, calling reverse
              etc. on either the item or an ancestor)<br>
              Use case: update UI to represent rewinding;
              stop audio when playing backwards to prevent secretly encoded
              messages being revealed.
            </li>
            <li><em>newanimation</em> &mdash;
              fires whenever a new <a>Animation</a> object is created.
              Use case: a timeline debugger. You want to show all animations
              that are playing or yet-to-play.
              Using this event (and <code>document.getActiveAnimations</code>?)
              you could build up a timegraph.
              <p>
                I think this sort of event and this sort of use case would fit
                the MutationObserver pattern well.
                We could introduce a whole class of mutation records targetted
                at debugging (e.g. <em>timewindowchange</em>)
              </p>
          </ul>
          <p>
            Also, although this is a bit different to a regular event (since
            it's qualified by a parameter), it seems like it might be nice to be
            able to do something like:
          </p>
          <pre class='example sh_javascript'>
            anim.onprogress(0.8,
             function() {
              // Issue a request to prefetch the next episode
             });
          </pre>
          <p>
            It would be called whenever you got a sample where
            <code>iterationTime</code> &ge; <var>progress</var> was newly true.
          </p>
        </div>
        <p>
          The <a
          href="http://www.w3.org/TR/DOM-Level-3-Events/#glossary-propagation-path">propagation
          path</a> for all events depends on the <a>TimedItem</a> where the
          status change took place.
          If the item is an <a>Animation</a> with an <a>AnimationEffect</a>
          <var>effect</var>, and <code><var>effect</var>.targetElement</code> is
          not <code>null</code>, the propagation path follows the usual <a
          href="http://www.w3.org/TR/DOM-Level-3-Events/#event-flow">DOM event
          flow</a> from <code>DefaultView</code> down the parent chain to
          <code><var>effect</var>.targetElement</code> and finally to the
          <a>TimedItem</a> where the status change took place.
          Otherwise, the propagation path is simply the <code>TimedItem</code>
          object itself.
        </p>
        <p class="note">
          Note that unlike <code>AnimationEvent</code>s and
          <code>TransitionEvent</code>s in CSS, and <code>TimeEvent</code>s in
          SVG which target an Element, the target of a <a>TimingEvent</a> is
          a <a>TimedItem</a>.
        </p>
        <p>
          Since Web Animations makes no guarantees about the time between
          successive frames of animation, it is possible that the time when
          a change in state that should produce an event is scheduled to occur
          does not line up with a frame.
        </p>
        <p>
          As such, the events that should be dispatched when sampling the model
          is based on the interval between samples as follows.
        </p>
        <ul>
          <li>
            Let <var>previous sample</var> be the moment when the timing model
            was last sampled, recorded in document time.
            If there was no previous sample, then let <var>previous sample</var>
            be -1.
          </li>
          <li>
            Let <var>current sample</var> be the current document time.
          </li>
          <li>
            Let <var>progress interval</var> be the interval (<var>previous
            sample</var>, <var>current sample</var>].
          </li>
        </ul>
        <p>
          The events to be dispatched are therefore those whose document time
          lies within <var>progress interval</var>.
        </p>
        <div class="issue">
          <p>
            This description fails to account for newly-added animations,
            removed animations, and other tree surgery.
            For example, if I have a sample at t=3s, I add an animation whose
            animation interval starts at t=2s, and then conduct another sample
            at t=4s, the <em>timingstart</em> event should fire even though the
            event's document time lies outside the progress interval.
          </p>
          <p>
            We could possibly fix this by making the previous sample times and
            current sample times per-<a>TimedItem</a> but that won't work for
            repeating groups.
            Needs work.
          </p>
        </div>
        <div class="issue">
          <p>
            This last part here requires calculating document times (both for
            testing against the progress interval and also for filling in the
            <code>documentTime</code> property of the event) and that's hard to
            calculate since our current model allows non-invertible timing
            functions on groups.
            That means you can't easily just traverse the descendants (by child
            and iteration) and generate a list of interval and iteration
            boundaries then filter out the ones that don't fit in the interval
            because you can't easily convert from local time to document time.
          </p>
          <p>
            You can, of course, convert from document time to local time
            and while that's probably enough to tell if there was an interval or
            iteration edge or not, it's not enough to determine the exact time
            at which it occurred (to fill in the event parameters).
          </p>
          <p>
            A complex example is where you have an group whose iteration time
            goes from 0 to 1.5 to 0.7 back to 1.
            Suppose you have a child animation that finishes its animation
            interval at 80% of the way through the parent's iteration interval.
            It would then finish, do nothing, then start reversing part-way,
            then finish again.
            In that case I think you expect to get: start, finish, start,
            finish.
          </p>
          <p>
            It's probably not impossible, so long as we allow for the fact that
            the inverse may have several (even equal) roots but it sounds tricky
            and possibly expensive to calculate on each iteration.
          </p>
          <p>
            I think we might need to re-consider allowing non-invertible timing
            functions on groups.
            Alternatively we could say that the children of a group with
            a non-interval timing function don't generate events.
            Or, alternatively again, that they occur on the non-transformed
            times.
          </p>
          <p>
            This final options of making event times untransformed times is not
            such a bad option, especially if we split time transformations into
            a separate step and perhaps even a separate interface.
            It's similar to some vector graphics editing programs that provide
            bitmap filter effects&mdash;often the bounding box of the filtered
            shape reflects the dimensions of the vector shape and not that of
            the bitmapped result.
          </p>
          <p>
            Also, in the case of an animation that bounces back and forth before
            resting at its final value, it's probably more useful to get just
            one end event when it finally rests than lots of little end/start
            events each time it crosses the 1.0 iteration time boundary.
          </p>
        </div>
        <div class="issue">
          <p>
            One implementation issue with events is that sometimes you find you
            suddenly have a large backlog of events to dispatch and this may
            have an adverse impact on performance.
            Some such situations include:
          </p>
          <ul>
            <li>
              You have a short iteration duration, e.g. 50ms, then you get put
              in a background tab and throttled really low.
              On the next sample, you might have hundreds of iteration events to
              dispatch.
            </li>
            <li>
              You have an arrangement of animations such that they keep spawning
              new ones for ever.
              You can easily get this in SVG using syncbase timing or in the
              model here by using repeating groups.
              In this case, you can have a lot of events to dispatch if you get
              throttled low.
              Once you have a global clock, you also encounter this situation
              when the computer goes to sleep since when it wakes up it will
              have a lot of start/end/iteration events to catch up on.
            </li>
          </ul>
          <p>
            It seems like the Mutation Observer pattern might help here except,
            firstly, that might prevent simple usage such as:
          </p>
          <pre class='example sh_javascript'>
elem.animate({ opacity: '0%' }, 1).onend =
   function() { elem.parentNode.removeChild(elem); };
          </pre>
          <p>
            Secondly, even using the observer pattern doesn't relieve the
            implementation of having to walk through the model and determine
            all the mutations that have occured and their corresponding times
            and this could be expensive if the computer has been asleep for
            a few days.
          </p>
          <p>
            Another option might be to set some implementation requirements that
            allow dropping events or automatic pausing when the time between
            samples is protracted (such as the device going to sleep).
          </p>
        </div>
      </section>
      <section>
        <h3>Event dispatch during seeking</h3>
        <p>
          The previous description of event dispatch applies when the timing
          model is sampled during normal playback (whether forwards or
          backwards).
          However, when a seek is performed by setting the
          <code>currentTime</code> of a <a>TimedItem</a>,
          a different behavior is employed.
          In effect, event dispatch is supressed until the seek is completed.
          After the seek has completed, events are dispatched based on comparing
          the before and after state of each <a>TimedItem</a> affected by the
          seek.
          Iteration events are not dispatched.
        </p>
        <p class="annotation">
          Supressing events during seeking is necessary to provide performant
          seeking.
          It is also arguably the more intuitive behavior as, for example,
          when rewinding a cartoon one probably does not expect a bucketload of
          events to arrive as a result of traversing backwards over each
          <a>TimedItem</a>.
        </p>
        <p class="issue">
          Should iteration events be dispatched?
        </p>
        <p>
          The procedure is as follows:
        </p>
        <ol>
          <li>Define a <a>TimedItem</a> as <dfn>active</dfn> if and only if
            <code>currentTime</code> &ge; <code>timing.startDelay</code> and
            <code>currentTime</code> &lt; <code>timing.startDelay</code> +
                                          <code>animationDuration</code>.</li>
          <dd></dd>
          <li>Prior to performing the seek on <var>item</var>,
              record whether it is <a>active</a> or not.</li>
          <li>If <var>item</var> is an <a>AnimationGroup</a> record whether each
              descendent <a>TimedItem</a> is <a>active</a> or not.</li>
          <li>Perform the seek as described in <a href="#seeking-a-timed-item"
            class="sectionRef"></a>.</li>
          <li>For each <a>TimedItem</a> considered in steps 2 and 3, compare
              whether the item was <a>active</a> before the seek and
              whether it is <a>active</a> now and dispatch events as follows:
              <dl class="switch">
                <dt>If the item was previously <a>active</a> but, after seeking,
                    is no longer <a>active</a>,</dt>
                <dd>Dispatch a new <code>timingend</code> event with
                  <a>localTime</a> set to <code>endTime</code> and
                  <a>documentTime</a> set to the corresponding document
                  time.
                  <span class="todo">(Obviously this depends on being able
                    to convert from a local time to a document time as
                    discussed in the previous section.)
                </dd>
                <dt>If the item was previously not <a>active</a> but, after
                    seeking, is now <a>active</a>,</dt>
                <dd>Dispatch a new <code>timingstart</code> event with
                  <a>localTime</a> set to <code>startTime
                  + timing.startDelay + timeDrift</code> and
                  <a>documentTime</a> set to the corresponding document
                  time.
                </dd>
              </dl>
          </li>
        </ol>
        <p>
          The sequence of dispatched events is identical to that of events
          dispatched during regular sampling (see <a href="#sequence-of-events"
            class="sectionRef"></a>).
        </p>
      </section>
      <section>
        <h3>Sequence of events</h3>
        <p>
          <a>TimingEvent</a>s are categories as <a
          href="http://www.w3.org/TR/DOM-Level-3-Events/#sync-async">synchronous
          events</a> whose sequence is as follows:
        </p>
        <ol>
          <li>Events are ordered by <code>documentTime</code></li>
          <li>For events with the same <code>documentTime</code>,
              sort by event type from first to last as follows:
              <em>timingcancel</em>, <em>timingend</em>,
              <em>timingiteration</em>, <em>timingstart</em>.
              <p class="note">
                Note that sorting end events before start events is consistent
                with the end-point exclusive nature of timing in Web
                Animations (see <a href="#interval-timing"
                class="sectionRef"></a>).
                When animation A ends at the same time as animation B begins,
                we can imagine that animation A ends an incredibly short amount
                of time before animation B begins such that there is no overlap.
              </p>
          </li>
          <li>
            For events with the same <code>documentTime</code> and type,
            if the target <a>TimedItem</a>s participate in a tree made up of
            <a>AnimationGroup</a>s then the events are dispatched as if the tree
            was sampled breadth-first such that events attached to ancestor
            <a>TimedItem</a>s are dispatched first.
          </li>
        </ol>
        <p class="issue">
          What if the order is still unresolved, is it okay to leave it
          undefined?
          Can we use document order or script order here?
          It's tempting to use the same order as we use for compositing but
          remember that not everything that is timed is composited (e.g.
          groups).
        </p>
      </section>
    </section>

    <section>
      <h2>Animation of common data types</h2>
      <div class="todo">
      <p>
        Need to describe how to interpolate/add both:
        <ol>
          <li>Integers, floats, strings etc.</li>
          <li>CSS and SVG types (colors etc.)</li>
          <ul><li>Support for HSL (if the colors are specified in HSL we should
            interpolate in that notation; but it should also be possible to
            do so regardless of how the colors are specified)</li></ul>
        </ol>
      </p>
      <p>
        For transforms I think it's defined elsewhere so we can either just
        point to that spec, or just refer to the fact that other specs should
        define how their types should be supported (or not) for animation.
      </p>
      <p>
        Need to provide facility for smooth interpolation of arbitrary paths.
      </p>
    </div>
    </section>

    <section>
      <h2>Interaction with script</h2>
      <div class="todo">
        <p>
          Need to document when the model is updated. e.g. currentTime doesn't
          change within a script block unless you set it.
        </p>
      </div>
    </section>

    <section>
      <h2>Integration with Media Fragments</h2>
      <p>
        The Media Fragments specification [[MEDIA-FRAGMENTS]] defines a means
        for addressing a temporal range of a media resource.  For resources
        containing content animated with Web Animations the application of the
        temporal parameters is as follows:
      </p>
      <ol>
        <li>
          <p>
            If a begin time is specified, perform a seek on the document
            timeline passing in the specified begin time as the seek time (see
            <a href="#seeking-a-timed-item" class="sectionRef"></a>).
          </p>
          <p class="note">
            Note that seeking behavior is well-defined even when the document
            has yet to start and hence the seek can be performed regardless of
            the setting of the <code>timelineStart</code> property (see <a
            href="#start-of-the-timeline" class="sectionRef"></a>).
          </p>
        </li>
        <li class="todo">
          If an end time is specified... we need a way to say, "play this
          range", or "stop at this point" but in such a way that you can still
          seek beyond that range.
          (In order to be consistent with how hyperlinks work elsewhere such as
          document anchors, svg views, etc.)
          Perhaps we just make it an interal thing for now and in a future
          version add some means of playing a range, or better still, a series
          of ranges; something compatible with what we have for video.
        </li>
      </ol>
    </section>

    <section>
      <h2>Interaction with page display</h2>
      <p class="todo">
        What should be the behavior here? Should we pause on unload/pagehide?
        What does video do?
      </p>
    </section>

    <section>
      <h2>Making animation accessible</h2>
      <p class="todo">
        TBD. If we have triggers represented in the API, need a way to make
        these available to accessibility agents.
      </p>
      <p class="todo">
        TBD. Need a way to expose speed control etc.?
      </p>
      <p class="todo">
        TBD. Describe how to integrate with the <a
          href="http://www.whatwg.org/specs/web-apps/current-work/#timed-text-tracks">Timed
          Text API</a> and give examples of how to author content so it is
        accessible.
      </p>
    </section>

    <section>
      <h2>Implementation requirements</h2>
      <section>
        <h3>Discarding past animations</h3>
        <p>
          If implementations are required to preserve all state associated with
          animations then the resources required by an animation could continue
          to increase without limit over time. For long-running animations, and
          particularly those where animations are added dynamically, this could
          lead to degraded performance and eventual failure.
        </p>
        <div class="issue">
          <p>
            I'm not sure how to define this. We could say all animations with
            <code><var>end time converted to document time</var> &lt;
            <var>current document time</var> - 5min</code> can be discarded.
          </p>
          <p>
            That's fine, but what about crazy documents that put 1 million
            animations in a 5min span? Just leave that up to the browser.
            Also, what about mobile clients, is 5 min too long? Is this too
            prescriptive?
          </p>
          <p>
            Maybe, just make some suggestions (e.g. 1 min for mobile clients,
            5 min for desktop?) and then define an exception to throw if there
            is a seek to some time outside that window.
          </p>
          <p>
            Also, note that defining this in terms of past intervals is
            direction-specific but that's probably ok since most long-running
            animations will run forwards.
          </p>
        </div>
      </section>
    </section>

    <section class='appendix'>
      <h2>Acknowledgements</h2>
    </section>
  </body>
</html>
